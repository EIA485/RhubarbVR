#pragma warning disable IDE0044 // Add readonly modifier
#pragma warning disable IDE0018 // Inline variable declaration
#pragma warning disable IDE0059 // Unnecessary assignment of a value
#pragma warning disable IDE0034 // Simplify 'default' expression
#pragma warning disable IDE0011 // Add braces
#pragma warning disable IDE0065 // Misplaced using directive
#pragma warning disable IDE1006 // Naming Styles
#pragma warning disable IDE0046 // Convert to conditional expression
#pragma warning disable IDE0007 // Use implicit type
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Valve.Sockets
{
    using System.Runtime.InteropServices;

    public static partial class Native
    {
        public const String Library = "GameNetworkingSockets-x64";

        public enum ESteamIPType : int
        {
            Esteamiptypeipv4 = unchecked((int)0),

            Esteamiptypeipv6 = unchecked((int)1),
        }

        public const Native.ESteamIPType Esteamiptypeipv4 = ESteamIPType.Esteamiptypeipv4;

        public const Native.ESteamIPType Esteamiptypeipv6 = ESteamIPType.Esteamiptypeipv6;

        /// <summary>
        /// Steam universes.  Each universe is a self-contained Steam instance.
        /// </summary>
        public enum EUniverse : int
        {
            Euniverseinvalid = unchecked((int)0),

            Euniversepublic = unchecked((int)1),

            Euniversebeta = unchecked((int)2),

            Euniverseinternal = unchecked((int)3),

            Euniversedev = unchecked((int)4),

            /// <summary>
            /// k_EUniverseRC = 5,				// no such universe anymore
            /// </summary>
            Euniversemax,
        }

        public const Native.EUniverse Euniverseinvalid = EUniverse.Euniverseinvalid;

        public const Native.EUniverse Euniversepublic = EUniverse.Euniversepublic;

        public const Native.EUniverse Euniversebeta = EUniverse.Euniversebeta;

        public const Native.EUniverse Euniverseinternal = EUniverse.Euniverseinternal;

        public const Native.EUniverse Euniversedev = EUniverse.Euniversedev;

        /// <summary>
        /// k_EUniverseRC = 5,				// no such universe anymore
        /// </summary>
        public const Native.EUniverse Euniversemax = EUniverse.Euniversemax;

        /// <summary>
        /// General result codes
        /// </summary>
        public enum EResult : int
        {
            /// <summary>
            /// no result
            /// </summary>
            Eresultnone = unchecked((int)0),

            /// <summary>
            /// success
            /// </summary>
            Eresultok = unchecked((int)1),

            /// <summary>
            /// generic failure
            /// </summary>
            Eresultfail = unchecked((int)2),

            /// <summary>
            /// no/failed network connection
            /// </summary>
            Eresultnoconnection = unchecked((int)3),

            /// <summary>
            /// password/ticket is invalid
            /// </summary>
            Eresultinvalidpassword = unchecked((int)5),

            /// <summary>
            /// same user logged in elsewhere
            /// </summary>
            Eresultloggedinelsewhere = unchecked((int)6),

            /// <summary>
            /// protocol version is incorrect
            /// </summary>
            Eresultinvalidprotocolver = unchecked((int)7),

            /// <summary>
            /// a parameter is incorrect
            /// </summary>
            Eresultinvalidparam = unchecked((int)8),

            /// <summary>
            /// file was not found
            /// </summary>
            Eresultfilenotfound = unchecked((int)9),

            /// <summary>
            /// called method busy - action not taken
            /// </summary>
            Eresultbusy = unchecked((int)10),

            /// <summary>
            /// called object was in an invalid state
            /// </summary>
            Eresultinvalidstate = unchecked((int)11),

            /// <summary>
            /// name is invalid
            /// </summary>
            Eresultinvalidname = unchecked((int)12),

            /// <summary>
            /// email is invalid
            /// </summary>
            Eresultinvalidemail = unchecked((int)13),

            /// <summary>
            /// name is not unique
            /// </summary>
            Eresultduplicatename = unchecked((int)14),

            /// <summary>
            /// access is denied
            /// </summary>
            Eresultaccessdenied = unchecked((int)15),

            /// <summary>
            /// operation timed out
            /// </summary>
            Eresulttimeout = unchecked((int)16),

            /// <summary>
            /// VAC2 banned
            /// </summary>
            Eresultbanned = unchecked((int)17),

            /// <summary>
            /// account not found
            /// </summary>
            Eresultaccountnotfound = unchecked((int)18),

            /// <summary>
            /// steamID is invalid
            /// </summary>
            Eresultinvalidsteamid = unchecked((int)19),

            /// <summary>
            /// The requested service is currently unavailable
            /// </summary>
            Eresultserviceunavailable = unchecked((int)20),

            /// <summary>
            /// The user is not logged on
            /// </summary>
            Eresultnotloggedon = unchecked((int)21),

            /// <summary>
            /// Request is pending (may be in process, or waiting on third party)
            /// </summary>
            Eresultpending = unchecked((int)22),

            /// <summary>
            /// Encryption or Decryption failed
            /// </summary>
            Eresultencryptionfailure = unchecked((int)23),

            /// <summary>
            /// Insufficient privilege
            /// </summary>
            Eresultinsufficientprivilege = unchecked((int)24),

            /// <summary>
            /// Too much of a good thing
            /// </summary>
            Eresultlimitexceeded = unchecked((int)25),

            /// <summary>
            /// Access has been revoked (used for revoked guest passes)
            /// </summary>
            Eresultrevoked = unchecked((int)26),

            /// <summary>
            /// License/Guest pass the user is trying to access is expired
            /// </summary>
            Eresultexpired = unchecked((int)27),

            /// <summary>
            /// Guest pass has already been redeemed by account, cannot be acked again
            /// </summary>
            Eresultalreadyredeemed = unchecked((int)28),

            /// <summary>
            /// The request is a duplicate and the action has already occurred in the past, ignored this time
            /// </summary>
            Eresultduplicaterequest = unchecked((int)29),

            /// <summary>
            /// All the games in this guest pass redemption request are already owned by the user
            /// </summary>
            Eresultalreadyowned = unchecked((int)30),

            /// <summary>
            /// IP address not found
            /// </summary>
            Eresultipnotfound = unchecked((int)31),

            /// <summary>
            /// failed to write change to the data store
            /// </summary>
            Eresultpersistfailed = unchecked((int)32),

            /// <summary>
            /// failed to acquire access lock for this operation
            /// </summary>
            Eresultlockingfailed = unchecked((int)33),

            Eresultlogonsessionreplaced = unchecked((int)34),

            Eresultconnectfailed = unchecked((int)35),

            Eresulthandshakefailed = unchecked((int)36),

            Eresultiofailure = unchecked((int)37),

            Eresultremotedisconnect = unchecked((int)38),

            /// <summary>
            /// failed to find the shopping cart requested
            /// </summary>
            Eresultshoppingcartnotfound = unchecked((int)39),

            /// <summary>
            /// a user didn't allow it
            /// </summary>
            Eresultblocked = unchecked((int)40),

            /// <summary>
            /// target is ignoring sender
            /// </summary>
            Eresultignored = unchecked((int)41),

            /// <summary>
            /// nothing matching the request found
            /// </summary>
            Eresultnomatch = unchecked((int)42),

            Eresultaccountdisabled = unchecked((int)43),

            /// <summary>
            /// this service is not accepting content changes right now
            /// </summary>
            Eresultservicereadonly = unchecked((int)44),

            /// <summary>
            /// account doesn't have value, so this feature isn't available
            /// </summary>
            Eresultaccountnotfeatured = unchecked((int)45),

            /// <summary>
            /// allowed to take this action, but only because requester is admin
            /// </summary>
            Eresultadministratorok = unchecked((int)46),

            /// <summary>
            /// A Version mismatch in content transmitted within the Steam protocol.
            /// </summary>
            Eresultcontentversion = unchecked((int)47),

            /// <summary>
            /// The current CM can't service the user making a request, user should try another.
            /// </summary>
            Eresulttryanothercm = unchecked((int)48),

            /// <summary>
            /// You are already logged in elsewhere, this cached credential login has failed.
            /// </summary>
            Eresultpasswordrequiredtokicksession = unchecked((int)49),

            /// <summary>
            /// You are already logged in elsewhere, you must wait
            /// </summary>
            Eresultalreadyloggedinelsewhere = unchecked((int)50),

            /// <summary>
            /// Long running operation (content download) suspended/paused
            /// </summary>
            Eresultsuspended = unchecked((int)51),

            /// <summary>
            /// Operation canceled (typically by user: content download)
            /// </summary>
            Eresultcancelled = unchecked((int)52),

            /// <summary>
            /// Operation canceled because data is ill formed or unrecoverable
            /// </summary>
            Eresultdatacorruption = unchecked((int)53),

            /// <summary>
            /// Operation canceled - not enough disk space.
            /// </summary>
            Eresultdiskfull = unchecked((int)54),

            /// <summary>
            /// an remote call or IPC call failed
            /// </summary>
            Eresultremotecallfailed = unchecked((int)55),

            /// <summary>
            /// Password could not be verified as it's unset server side
            /// </summary>
            Eresultpasswordunset = unchecked((int)56),

            /// <summary>
            /// External account (PSN, Facebook...) is not linked to a Steam account
            /// </summary>
            Eresultexternalaccountunlinked = unchecked((int)57),

            /// <summary>
            /// PSN ticket was invalid
            /// </summary>
            Eresultpsnticketinvalid = unchecked((int)58),

            /// <summary>
            /// External account (PSN, Facebook...) is already linked to some other account, must explicitly request to replace/delete the link first
            /// </summary>
            Eresultexternalaccountalreadylinked = unchecked((int)59),

            /// <summary>
            /// The sync cannot resume due to a conflict between the local and remote files
            /// </summary>
            Eresultremotefileconflict = unchecked((int)60),

            /// <summary>
            /// The requested new password is not legal
            /// </summary>
            Eresultillegalpassword = unchecked((int)61),

            /// <summary>
            /// new value is the same as the old one ( secret question and answer )
            /// </summary>
            Eresultsameaspreviousvalue = unchecked((int)62),

            /// <summary>
            /// account login denied due to 2nd factor authentication failure
            /// </summary>
            Eresultaccountlogondenied = unchecked((int)63),

            /// <summary>
            /// The requested new password is not legal
            /// </summary>
            Eresultcannotuseoldpassword = unchecked((int)64),

            /// <summary>
            /// account login denied due to auth code invalid
            /// </summary>
            Eresultinvalidloginauthcode = unchecked((int)65),

            /// <summary>
            /// account login denied due to 2nd factor auth failure - and no mail has been sent
            /// </summary>
            Eresultaccountlogondeniednomail = unchecked((int)66),

            /// <summary>
            /// 
            /// </summary>
            Eresulthardwarenotcapableofipt = unchecked((int)67),

            /// <summary>
            /// 
            /// </summary>
            Eresultiptiniterror = unchecked((int)68),

            /// <summary>
            /// operation failed due to parental control restrictions for current user
            /// </summary>
            Eresultparentalcontrolrestricted = unchecked((int)69),

            /// <summary>
            /// Facebook query returned an error
            /// </summary>
            Eresultfacebookqueryerror = unchecked((int)70),

            /// <summary>
            /// account login denied due to auth code expired
            /// </summary>
            Eresultexpiredloginauthcode = unchecked((int)71),

            Eresultiploginrestrictionfailed = unchecked((int)72),

            Eresultaccountlockeddown = unchecked((int)73),

            Eresultaccountlogondeniedverifiedemailrequired = unchecked((int)74),

            Eresultnomatchingurl = unchecked((int)75),

            /// <summary>
            /// parse failure, missing field, etc.
            /// </summary>
            Eresultbadresponse = unchecked((int)76),

            /// <summary>
            /// The user cannot complete the action until they re-enter their password
            /// </summary>
            Eresultrequirepasswordreentry = unchecked((int)77),

            /// <summary>
            /// the value entered is outside the acceptable range
            /// </summary>
            Eresultvalueoutofrange = unchecked((int)78),

            /// <summary>
            /// something happened that we didn't expect to ever happen
            /// </summary>
            Eresultunexpectederror = unchecked((int)79),

            /// <summary>
            /// The requested service has been configured to be unavailable
            /// </summary>
            Eresultdisabled = unchecked((int)80),

            /// <summary>
            /// The set of files submitted to the CEG server are not valid !
            /// </summary>
            Eresultinvalidcegsubmission = unchecked((int)81),

            /// <summary>
            /// The device being used is not allowed to perform this action
            /// </summary>
            Eresultrestricteddevice = unchecked((int)82),

            /// <summary>
            /// The action could not be complete because it is region restricted
            /// </summary>
            Eresultregionlocked = unchecked((int)83),

            /// <summary>
            /// Temporary rate limit exceeded, try again later, different from k_EResultLimitExceeded which may be permanent
            /// </summary>
            Eresultratelimitexceeded = unchecked((int)84),

            /// <summary>
            /// Need two-factor code to login
            /// </summary>
            Eresultaccountlogindeniedneedtwofactor = unchecked((int)85),

            /// <summary>
            /// The thing we're trying to access has been deleted
            /// </summary>
            Eresultitemdeleted = unchecked((int)86),

            /// <summary>
            /// login attempt failed, try to throttle response to possible attacker
            /// </summary>
            Eresultaccountlogindeniedthrottle = unchecked((int)87),

            /// <summary>
            /// two factor code mismatch
            /// </summary>
            Eresulttwofactorcodemismatch = unchecked((int)88),

            /// <summary>
            /// activation code for two-factor didn't match
            /// </summary>
            Eresulttwofactoractivationcodemismatch = unchecked((int)89),

            /// <summary>
            /// account has been associated with multiple partners
            /// </summary>
            Eresultaccountassociatedtomultiplepartners = unchecked((int)90),

            /// <summary>
            /// data not modified
            /// </summary>
            Eresultnotmodified = unchecked((int)91),

            /// <summary>
            /// the account does not have a mobile device associated with it
            /// </summary>
            Eresultnomobiledevice = unchecked((int)92),

            /// <summary>
            /// the time presented is out of range or tolerance
            /// </summary>
            Eresulttimenotsynced = unchecked((int)93),

            /// <summary>
            /// SMS code failure (no match, none pending, etc.)
            /// </summary>
            Eresultsmscodefailed = unchecked((int)94),

            /// <summary>
            /// Too many accounts access this resource
            /// </summary>
            Eresultaccountlimitexceeded = unchecked((int)95),

            /// <summary>
            /// Too many changes to this account
            /// </summary>
            Eresultaccountactivitylimitexceeded = unchecked((int)96),

            /// <summary>
            /// Too many changes to this phone
            /// </summary>
            Eresultphoneactivitylimitexceeded = unchecked((int)97),

            /// <summary>
            /// Cannot refund to payment method, must use wallet
            /// </summary>
            Eresultrefundtowallet = unchecked((int)98),

            /// <summary>
            /// Cannot send an email
            /// </summary>
            Eresultemailsendfailure = unchecked((int)99),

            /// <summary>
            /// Can't perform operation till payment has settled
            /// </summary>
            Eresultnotsettled = unchecked((int)100),

            /// <summary>
            /// Needs to provide a valid captcha
            /// </summary>
            Eresultneedcaptcha = unchecked((int)101),

            /// <summary>
            /// a game server login token owned by this token's owner has been banned
            /// </summary>
            Eresultgsltdenied = unchecked((int)102),

            /// <summary>
            /// game server owner is denied for other reason (account lock, community ban, vac ban, missing phone)
            /// </summary>
            Eresultgsownerdenied = unchecked((int)103),

            /// <summary>
            /// the type of thing we were requested to act on is invalid
            /// </summary>
            Eresultinvaliditemtype = unchecked((int)104),

            /// <summary>
            /// the ip address has been banned from taking this action
            /// </summary>
            Eresultipbanned = unchecked((int)105),

            /// <summary>
            /// this token has expired from disuse; can be reset for use
            /// </summary>
            Eresultgsltexpired = unchecked((int)106),

            /// <summary>
            /// user doesn't have enough wallet funds to complete the action
            /// </summary>
            Eresultinsufficientfunds = unchecked((int)107),

            /// <summary>
            /// There are too many of this thing pending already
            /// </summary>
            Eresulttoomanypending = unchecked((int)108),

            /// <summary>
            /// No site licenses found
            /// </summary>
            Eresultnositelicensesfound = unchecked((int)109),

            /// <summary>
            /// the WG couldn't send a response because we exceeded max network send size
            /// </summary>
            Eresultwgnetworksendexceeded = unchecked((int)110),

            /// <summary>
            /// the user is not mutually friends
            /// </summary>
            Eresultaccountnotfriends = unchecked((int)111),

            /// <summary>
            /// the user is limited
            /// </summary>
            Eresultlimiteduseraccount = unchecked((int)112),

            /// <summary>
            /// item can't be removed
            /// </summary>
            Eresultcantremoveitem = unchecked((int)113),

            /// <summary>
            /// account has been deleted
            /// </summary>
            Eresultaccountdeleted = unchecked((int)114),

            /// <summary>
            /// A license for this already exists, but cancelled
            /// </summary>
            Eresultexistingusercancelledlicense = unchecked((int)115),

            /// <summary>
            /// access is denied because of a community cooldown (probably from support profile data resets)
            /// </summary>
            Eresultcommunitycooldown = unchecked((int)116),

            /// <summary>
            /// No launcher was specified, but a launcher was needed to choose correct realm for operation.
            /// </summary>
            Eresultnolauncherspecified = unchecked((int)117),

            /// <summary>
            /// User must agree to china SSA or global SSA before login
            /// </summary>
            Eresultmustagreetossa = unchecked((int)118),

            /// <summary>
            /// The specified launcher type is no longer supported; the user should be directed elsewhere
            /// </summary>
            Eresultlaunchermigrated = unchecked((int)119),

            /// <summary>
            /// The user's realm does not match the realm of the requested resource
            /// </summary>
            Eresultsteamrealmmismatch = unchecked((int)120),

            /// <summary>
            /// signature check did not match
            /// </summary>
            Eresultinvalidsignature = unchecked((int)121),

            /// <summary>
            /// Failed to parse input
            /// </summary>
            Eresultparsefailure = unchecked((int)122),

            /// <summary>
            /// account does not have a verified phone number
            /// </summary>
            Eresultnoverifiedphone = unchecked((int)123),
        }

        /// <summary>
        /// no result
        /// </summary>
        public const Native.EResult Eresultnone = EResult.Eresultnone;

        /// <summary>
        /// success
        /// </summary>
        public const Native.EResult Eresultok = EResult.Eresultok;

        /// <summary>
        /// generic failure
        /// </summary>
        public const Native.EResult Eresultfail = EResult.Eresultfail;

        /// <summary>
        /// no/failed network connection
        /// </summary>
        public const Native.EResult Eresultnoconnection = EResult.Eresultnoconnection;

        /// <summary>
        /// password/ticket is invalid
        /// </summary>
        public const Native.EResult Eresultinvalidpassword = EResult.Eresultinvalidpassword;

        /// <summary>
        /// same user logged in elsewhere
        /// </summary>
        public const Native.EResult Eresultloggedinelsewhere = EResult.Eresultloggedinelsewhere;

        /// <summary>
        /// protocol version is incorrect
        /// </summary>
        public const Native.EResult Eresultinvalidprotocolver = EResult.Eresultinvalidprotocolver;

        /// <summary>
        /// a parameter is incorrect
        /// </summary>
        public const Native.EResult Eresultinvalidparam = EResult.Eresultinvalidparam;

        /// <summary>
        /// file was not found
        /// </summary>
        public const Native.EResult Eresultfilenotfound = EResult.Eresultfilenotfound;

        /// <summary>
        /// called method busy - action not taken
        /// </summary>
        public const Native.EResult Eresultbusy = EResult.Eresultbusy;

        /// <summary>
        /// called object was in an invalid state
        /// </summary>
        public const Native.EResult Eresultinvalidstate = EResult.Eresultinvalidstate;

        /// <summary>
        /// name is invalid
        /// </summary>
        public const Native.EResult Eresultinvalidname = EResult.Eresultinvalidname;

        /// <summary>
        /// email is invalid
        /// </summary>
        public const Native.EResult Eresultinvalidemail = EResult.Eresultinvalidemail;

        /// <summary>
        /// name is not unique
        /// </summary>
        public const Native.EResult Eresultduplicatename = EResult.Eresultduplicatename;

        /// <summary>
        /// access is denied
        /// </summary>
        public const Native.EResult Eresultaccessdenied = EResult.Eresultaccessdenied;

        /// <summary>
        /// operation timed out
        /// </summary>
        public const Native.EResult Eresulttimeout = EResult.Eresulttimeout;

        /// <summary>
        /// VAC2 banned
        /// </summary>
        public const Native.EResult Eresultbanned = EResult.Eresultbanned;

        /// <summary>
        /// account not found
        /// </summary>
        public const Native.EResult Eresultaccountnotfound = EResult.Eresultaccountnotfound;

        /// <summary>
        /// steamID is invalid
        /// </summary>
        public const Native.EResult Eresultinvalidsteamid = EResult.Eresultinvalidsteamid;

        /// <summary>
        /// The requested service is currently unavailable
        /// </summary>
        public const Native.EResult Eresultserviceunavailable = EResult.Eresultserviceunavailable;

        /// <summary>
        /// The user is not logged on
        /// </summary>
        public const Native.EResult Eresultnotloggedon = EResult.Eresultnotloggedon;

        /// <summary>
        /// Request is pending (may be in process, or waiting on third party)
        /// </summary>
        public const Native.EResult Eresultpending = EResult.Eresultpending;

        /// <summary>
        /// Encryption or Decryption failed
        /// </summary>
        public const Native.EResult Eresultencryptionfailure = EResult.Eresultencryptionfailure;

        /// <summary>
        /// Insufficient privilege
        /// </summary>
        public const Native.EResult Eresultinsufficientprivilege = EResult.Eresultinsufficientprivilege;

        /// <summary>
        /// Too much of a good thing
        /// </summary>
        public const Native.EResult Eresultlimitexceeded = EResult.Eresultlimitexceeded;

        /// <summary>
        /// Access has been revoked (used for revoked guest passes)
        /// </summary>
        public const Native.EResult Eresultrevoked = EResult.Eresultrevoked;

        /// <summary>
        /// License/Guest pass the user is trying to access is expired
        /// </summary>
        public const Native.EResult Eresultexpired = EResult.Eresultexpired;

        /// <summary>
        /// Guest pass has already been redeemed by account, cannot be acked again
        /// </summary>
        public const Native.EResult Eresultalreadyredeemed = EResult.Eresultalreadyredeemed;

        /// <summary>
        /// The request is a duplicate and the action has already occurred in the past, ignored this time
        /// </summary>
        public const Native.EResult Eresultduplicaterequest = EResult.Eresultduplicaterequest;

        /// <summary>
        /// All the games in this guest pass redemption request are already owned by the user
        /// </summary>
        public const Native.EResult Eresultalreadyowned = EResult.Eresultalreadyowned;

        /// <summary>
        /// IP address not found
        /// </summary>
        public const Native.EResult Eresultipnotfound = EResult.Eresultipnotfound;

        /// <summary>
        /// failed to write change to the data store
        /// </summary>
        public const Native.EResult Eresultpersistfailed = EResult.Eresultpersistfailed;

        /// <summary>
        /// failed to acquire access lock for this operation
        /// </summary>
        public const Native.EResult Eresultlockingfailed = EResult.Eresultlockingfailed;

        public const Native.EResult Eresultlogonsessionreplaced = EResult.Eresultlogonsessionreplaced;

        public const Native.EResult Eresultconnectfailed = EResult.Eresultconnectfailed;

        public const Native.EResult Eresulthandshakefailed = EResult.Eresulthandshakefailed;

        public const Native.EResult Eresultiofailure = EResult.Eresultiofailure;

        public const Native.EResult Eresultremotedisconnect = EResult.Eresultremotedisconnect;

        /// <summary>
        /// failed to find the shopping cart requested
        /// </summary>
        public const Native.EResult Eresultshoppingcartnotfound = EResult.Eresultshoppingcartnotfound;

        /// <summary>
        /// a user didn't allow it
        /// </summary>
        public const Native.EResult Eresultblocked = EResult.Eresultblocked;

        /// <summary>
        /// target is ignoring sender
        /// </summary>
        public const Native.EResult Eresultignored = EResult.Eresultignored;

        /// <summary>
        /// nothing matching the request found
        /// </summary>
        public const Native.EResult Eresultnomatch = EResult.Eresultnomatch;

        public const Native.EResult Eresultaccountdisabled = EResult.Eresultaccountdisabled;

        /// <summary>
        /// this service is not accepting content changes right now
        /// </summary>
        public const Native.EResult Eresultservicereadonly = EResult.Eresultservicereadonly;

        /// <summary>
        /// account doesn't have value, so this feature isn't available
        /// </summary>
        public const Native.EResult Eresultaccountnotfeatured = EResult.Eresultaccountnotfeatured;

        /// <summary>
        /// allowed to take this action, but only because requester is admin
        /// </summary>
        public const Native.EResult Eresultadministratorok = EResult.Eresultadministratorok;

        /// <summary>
        /// A Version mismatch in content transmitted within the Steam protocol.
        /// </summary>
        public const Native.EResult Eresultcontentversion = EResult.Eresultcontentversion;

        /// <summary>
        /// The current CM can't service the user making a request, user should try another.
        /// </summary>
        public const Native.EResult Eresulttryanothercm = EResult.Eresulttryanothercm;

        /// <summary>
        /// You are already logged in elsewhere, this cached credential login has failed.
        /// </summary>
        public const Native.EResult Eresultpasswordrequiredtokicksession = EResult.Eresultpasswordrequiredtokicksession;

        /// <summary>
        /// You are already logged in elsewhere, you must wait
        /// </summary>
        public const Native.EResult Eresultalreadyloggedinelsewhere = EResult.Eresultalreadyloggedinelsewhere;

        /// <summary>
        /// Long running operation (content download) suspended/paused
        /// </summary>
        public const Native.EResult Eresultsuspended = EResult.Eresultsuspended;

        /// <summary>
        /// Operation canceled (typically by user: content download)
        /// </summary>
        public const Native.EResult Eresultcancelled = EResult.Eresultcancelled;

        /// <summary>
        /// Operation canceled because data is ill formed or unrecoverable
        /// </summary>
        public const Native.EResult Eresultdatacorruption = EResult.Eresultdatacorruption;

        /// <summary>
        /// Operation canceled - not enough disk space.
        /// </summary>
        public const Native.EResult Eresultdiskfull = EResult.Eresultdiskfull;

        /// <summary>
        /// an remote call or IPC call failed
        /// </summary>
        public const Native.EResult Eresultremotecallfailed = EResult.Eresultremotecallfailed;

        /// <summary>
        /// Password could not be verified as it's unset server side
        /// </summary>
        public const Native.EResult Eresultpasswordunset = EResult.Eresultpasswordunset;

        /// <summary>
        /// External account (PSN, Facebook...) is not linked to a Steam account
        /// </summary>
        public const Native.EResult Eresultexternalaccountunlinked = EResult.Eresultexternalaccountunlinked;

        /// <summary>
        /// PSN ticket was invalid
        /// </summary>
        public const Native.EResult Eresultpsnticketinvalid = EResult.Eresultpsnticketinvalid;

        /// <summary>
        /// External account (PSN, Facebook...) is already linked to some other account, must explicitly request to replace/delete the link first
        /// </summary>
        public const Native.EResult Eresultexternalaccountalreadylinked = EResult.Eresultexternalaccountalreadylinked;

        /// <summary>
        /// The sync cannot resume due to a conflict between the local and remote files
        /// </summary>
        public const Native.EResult Eresultremotefileconflict = EResult.Eresultremotefileconflict;

        /// <summary>
        /// The requested new password is not legal
        /// </summary>
        public const Native.EResult Eresultillegalpassword = EResult.Eresultillegalpassword;

        /// <summary>
        /// new value is the same as the old one ( secret question and answer )
        /// </summary>
        public const Native.EResult Eresultsameaspreviousvalue = EResult.Eresultsameaspreviousvalue;

        /// <summary>
        /// account login denied due to 2nd factor authentication failure
        /// </summary>
        public const Native.EResult Eresultaccountlogondenied = EResult.Eresultaccountlogondenied;

        /// <summary>
        /// The requested new password is not legal
        /// </summary>
        public const Native.EResult Eresultcannotuseoldpassword = EResult.Eresultcannotuseoldpassword;

        /// <summary>
        /// account login denied due to auth code invalid
        /// </summary>
        public const Native.EResult Eresultinvalidloginauthcode = EResult.Eresultinvalidloginauthcode;

        /// <summary>
        /// account login denied due to 2nd factor auth failure - and no mail has been sent
        /// </summary>
        public const Native.EResult Eresultaccountlogondeniednomail = EResult.Eresultaccountlogondeniednomail;

        /// <summary>
        /// 
        /// </summary>
        public const Native.EResult Eresulthardwarenotcapableofipt = EResult.Eresulthardwarenotcapableofipt;

        /// <summary>
        /// 
        /// </summary>
        public const Native.EResult Eresultiptiniterror = EResult.Eresultiptiniterror;

        /// <summary>
        /// operation failed due to parental control restrictions for current user
        /// </summary>
        public const Native.EResult Eresultparentalcontrolrestricted = EResult.Eresultparentalcontrolrestricted;

        /// <summary>
        /// Facebook query returned an error
        /// </summary>
        public const Native.EResult Eresultfacebookqueryerror = EResult.Eresultfacebookqueryerror;

        /// <summary>
        /// account login denied due to auth code expired
        /// </summary>
        public const Native.EResult Eresultexpiredloginauthcode = EResult.Eresultexpiredloginauthcode;

        public const Native.EResult Eresultiploginrestrictionfailed = EResult.Eresultiploginrestrictionfailed;

        public const Native.EResult Eresultaccountlockeddown = EResult.Eresultaccountlockeddown;

        public const Native.EResult Eresultaccountlogondeniedverifiedemailrequired = EResult.Eresultaccountlogondeniedverifiedemailrequired;

        public const Native.EResult Eresultnomatchingurl = EResult.Eresultnomatchingurl;

        /// <summary>
        /// parse failure, missing field, etc.
        /// </summary>
        public const Native.EResult Eresultbadresponse = EResult.Eresultbadresponse;

        /// <summary>
        /// The user cannot complete the action until they re-enter their password
        /// </summary>
        public const Native.EResult Eresultrequirepasswordreentry = EResult.Eresultrequirepasswordreentry;

        /// <summary>
        /// the value entered is outside the acceptable range
        /// </summary>
        public const Native.EResult Eresultvalueoutofrange = EResult.Eresultvalueoutofrange;

        /// <summary>
        /// something happened that we didn't expect to ever happen
        /// </summary>
        public const Native.EResult Eresultunexpectederror = EResult.Eresultunexpectederror;

        /// <summary>
        /// The requested service has been configured to be unavailable
        /// </summary>
        public const Native.EResult Eresultdisabled = EResult.Eresultdisabled;

        /// <summary>
        /// The set of files submitted to the CEG server are not valid !
        /// </summary>
        public const Native.EResult Eresultinvalidcegsubmission = EResult.Eresultinvalidcegsubmission;

        /// <summary>
        /// The device being used is not allowed to perform this action
        /// </summary>
        public const Native.EResult Eresultrestricteddevice = EResult.Eresultrestricteddevice;

        /// <summary>
        /// The action could not be complete because it is region restricted
        /// </summary>
        public const Native.EResult Eresultregionlocked = EResult.Eresultregionlocked;

        /// <summary>
        /// Temporary rate limit exceeded, try again later, different from k_EResultLimitExceeded which may be permanent
        /// </summary>
        public const Native.EResult Eresultratelimitexceeded = EResult.Eresultratelimitexceeded;

        /// <summary>
        /// Need two-factor code to login
        /// </summary>
        public const Native.EResult Eresultaccountlogindeniedneedtwofactor = EResult.Eresultaccountlogindeniedneedtwofactor;

        /// <summary>
        /// The thing we're trying to access has been deleted
        /// </summary>
        public const Native.EResult Eresultitemdeleted = EResult.Eresultitemdeleted;

        /// <summary>
        /// login attempt failed, try to throttle response to possible attacker
        /// </summary>
        public const Native.EResult Eresultaccountlogindeniedthrottle = EResult.Eresultaccountlogindeniedthrottle;

        /// <summary>
        /// two factor code mismatch
        /// </summary>
        public const Native.EResult Eresulttwofactorcodemismatch = EResult.Eresulttwofactorcodemismatch;

        /// <summary>
        /// activation code for two-factor didn't match
        /// </summary>
        public const Native.EResult Eresulttwofactoractivationcodemismatch = EResult.Eresulttwofactoractivationcodemismatch;

        /// <summary>
        /// account has been associated with multiple partners
        /// </summary>
        public const Native.EResult Eresultaccountassociatedtomultiplepartners = EResult.Eresultaccountassociatedtomultiplepartners;

        /// <summary>
        /// data not modified
        /// </summary>
        public const Native.EResult Eresultnotmodified = EResult.Eresultnotmodified;

        /// <summary>
        /// the account does not have a mobile device associated with it
        /// </summary>
        public const Native.EResult Eresultnomobiledevice = EResult.Eresultnomobiledevice;

        /// <summary>
        /// the time presented is out of range or tolerance
        /// </summary>
        public const Native.EResult Eresulttimenotsynced = EResult.Eresulttimenotsynced;

        /// <summary>
        /// SMS code failure (no match, none pending, etc.)
        /// </summary>
        public const Native.EResult Eresultsmscodefailed = EResult.Eresultsmscodefailed;

        /// <summary>
        /// Too many accounts access this resource
        /// </summary>
        public const Native.EResult Eresultaccountlimitexceeded = EResult.Eresultaccountlimitexceeded;

        /// <summary>
        /// Too many changes to this account
        /// </summary>
        public const Native.EResult Eresultaccountactivitylimitexceeded = EResult.Eresultaccountactivitylimitexceeded;

        /// <summary>
        /// Too many changes to this phone
        /// </summary>
        public const Native.EResult Eresultphoneactivitylimitexceeded = EResult.Eresultphoneactivitylimitexceeded;

        /// <summary>
        /// Cannot refund to payment method, must use wallet
        /// </summary>
        public const Native.EResult Eresultrefundtowallet = EResult.Eresultrefundtowallet;

        /// <summary>
        /// Cannot send an email
        /// </summary>
        public const Native.EResult Eresultemailsendfailure = EResult.Eresultemailsendfailure;

        /// <summary>
        /// Can't perform operation till payment has settled
        /// </summary>
        public const Native.EResult Eresultnotsettled = EResult.Eresultnotsettled;

        /// <summary>
        /// Needs to provide a valid captcha
        /// </summary>
        public const Native.EResult Eresultneedcaptcha = EResult.Eresultneedcaptcha;

        /// <summary>
        /// a game server login token owned by this token's owner has been banned
        /// </summary>
        public const Native.EResult Eresultgsltdenied = EResult.Eresultgsltdenied;

        /// <summary>
        /// game server owner is denied for other reason (account lock, community ban, vac ban, missing phone)
        /// </summary>
        public const Native.EResult Eresultgsownerdenied = EResult.Eresultgsownerdenied;

        /// <summary>
        /// the type of thing we were requested to act on is invalid
        /// </summary>
        public const Native.EResult Eresultinvaliditemtype = EResult.Eresultinvaliditemtype;

        /// <summary>
        /// the ip address has been banned from taking this action
        /// </summary>
        public const Native.EResult Eresultipbanned = EResult.Eresultipbanned;

        /// <summary>
        /// this token has expired from disuse; can be reset for use
        /// </summary>
        public const Native.EResult Eresultgsltexpired = EResult.Eresultgsltexpired;

        /// <summary>
        /// user doesn't have enough wallet funds to complete the action
        /// </summary>
        public const Native.EResult Eresultinsufficientfunds = EResult.Eresultinsufficientfunds;

        /// <summary>
        /// There are too many of this thing pending already
        /// </summary>
        public const Native.EResult Eresulttoomanypending = EResult.Eresulttoomanypending;

        /// <summary>
        /// No site licenses found
        /// </summary>
        public const Native.EResult Eresultnositelicensesfound = EResult.Eresultnositelicensesfound;

        /// <summary>
        /// the WG couldn't send a response because we exceeded max network send size
        /// </summary>
        public const Native.EResult Eresultwgnetworksendexceeded = EResult.Eresultwgnetworksendexceeded;

        /// <summary>
        /// the user is not mutually friends
        /// </summary>
        public const Native.EResult Eresultaccountnotfriends = EResult.Eresultaccountnotfriends;

        /// <summary>
        /// the user is limited
        /// </summary>
        public const Native.EResult Eresultlimiteduseraccount = EResult.Eresultlimiteduseraccount;

        /// <summary>
        /// item can't be removed
        /// </summary>
        public const Native.EResult Eresultcantremoveitem = EResult.Eresultcantremoveitem;

        /// <summary>
        /// account has been deleted
        /// </summary>
        public const Native.EResult Eresultaccountdeleted = EResult.Eresultaccountdeleted;

        /// <summary>
        /// A license for this already exists, but cancelled
        /// </summary>
        public const Native.EResult Eresultexistingusercancelledlicense = EResult.Eresultexistingusercancelledlicense;

        /// <summary>
        /// access is denied because of a community cooldown (probably from support profile data resets)
        /// </summary>
        public const Native.EResult Eresultcommunitycooldown = EResult.Eresultcommunitycooldown;

        /// <summary>
        /// No launcher was specified, but a launcher was needed to choose correct realm for operation.
        /// </summary>
        public const Native.EResult Eresultnolauncherspecified = EResult.Eresultnolauncherspecified;

        /// <summary>
        /// User must agree to china SSA or global SSA before login
        /// </summary>
        public const Native.EResult Eresultmustagreetossa = EResult.Eresultmustagreetossa;

        /// <summary>
        /// The specified launcher type is no longer supported; the user should be directed elsewhere
        /// </summary>
        public const Native.EResult Eresultlaunchermigrated = EResult.Eresultlaunchermigrated;

        /// <summary>
        /// The user's realm does not match the realm of the requested resource
        /// </summary>
        public const Native.EResult Eresultsteamrealmmismatch = EResult.Eresultsteamrealmmismatch;

        /// <summary>
        /// signature check did not match
        /// </summary>
        public const Native.EResult Eresultinvalidsignature = EResult.Eresultinvalidsignature;

        /// <summary>
        /// Failed to parse input
        /// </summary>
        public const Native.EResult Eresultparsefailure = EResult.Eresultparsefailure;

        /// <summary>
        /// account does not have a verified phone number
        /// </summary>
        public const Native.EResult Eresultnoverifiedphone = EResult.Eresultnoverifiedphone;

        /// <summary>
        /// Error codes for use with the voice functions
        /// </summary>
        public enum EVoiceResult : int
        {
            Evoiceresultok = unchecked((int)0),

            Evoiceresultnotinitialized = unchecked((int)1),

            Evoiceresultnotrecording = unchecked((int)2),

            Evoiceresultnodata = unchecked((int)3),

            Evoiceresultbuffertoosmall = unchecked((int)4),

            Evoiceresultdatacorrupted = unchecked((int)5),

            Evoiceresultrestricted = unchecked((int)6),

            Evoiceresultunsupportedcodec = unchecked((int)7),

            Evoiceresultreceiveroutofdate = unchecked((int)8),

            Evoiceresultreceiverdidnotanswer = unchecked((int)9),
        }

        public const Native.EVoiceResult Evoiceresultok = EVoiceResult.Evoiceresultok;

        public const Native.EVoiceResult Evoiceresultnotinitialized = EVoiceResult.Evoiceresultnotinitialized;

        public const Native.EVoiceResult Evoiceresultnotrecording = EVoiceResult.Evoiceresultnotrecording;

        public const Native.EVoiceResult Evoiceresultnodata = EVoiceResult.Evoiceresultnodata;

        public const Native.EVoiceResult Evoiceresultbuffertoosmall = EVoiceResult.Evoiceresultbuffertoosmall;

        public const Native.EVoiceResult Evoiceresultdatacorrupted = EVoiceResult.Evoiceresultdatacorrupted;

        public const Native.EVoiceResult Evoiceresultrestricted = EVoiceResult.Evoiceresultrestricted;

        public const Native.EVoiceResult Evoiceresultunsupportedcodec = EVoiceResult.Evoiceresultunsupportedcodec;

        public const Native.EVoiceResult Evoiceresultreceiveroutofdate = EVoiceResult.Evoiceresultreceiveroutofdate;

        public const Native.EVoiceResult Evoiceresultreceiverdidnotanswer = EVoiceResult.Evoiceresultreceiverdidnotanswer;

        /// <summary>
        /// Result codes to GSHandleClientDeny/Kick
        /// </summary>
        public enum EDenyReason : int
        {
            Edenyinvalid = unchecked((int)0),

            Edenyinvalidversion = unchecked((int)1),

            Edenygeneric = unchecked((int)2),

            Edenynotloggedon = unchecked((int)3),

            Edenynolicense = unchecked((int)4),

            Edenycheater = unchecked((int)5),

            Edenyloggedinelsewhere = unchecked((int)6),

            Edenyunknowntext = unchecked((int)7),

            Edenyincompatibleanticheat = unchecked((int)8),

            Edenymemorycorruption = unchecked((int)9),

            Edenyincompatiblesoftware = unchecked((int)10),

            Edenysteamconnectionlost = unchecked((int)11),

            Edenysteamconnectionerror = unchecked((int)12),

            Edenysteamresponsetimedout = unchecked((int)13),

            Edenysteamvalidationstalled = unchecked((int)14),

            Edenysteamownerleftguestuser = unchecked((int)15),
        }

        public const Native.EDenyReason Edenyinvalid = EDenyReason.Edenyinvalid;

        public const Native.EDenyReason Edenyinvalidversion = EDenyReason.Edenyinvalidversion;

        public const Native.EDenyReason Edenygeneric = EDenyReason.Edenygeneric;

        public const Native.EDenyReason Edenynotloggedon = EDenyReason.Edenynotloggedon;

        public const Native.EDenyReason Edenynolicense = EDenyReason.Edenynolicense;

        public const Native.EDenyReason Edenycheater = EDenyReason.Edenycheater;

        public const Native.EDenyReason Edenyloggedinelsewhere = EDenyReason.Edenyloggedinelsewhere;

        public const Native.EDenyReason Edenyunknowntext = EDenyReason.Edenyunknowntext;

        public const Native.EDenyReason Edenyincompatibleanticheat = EDenyReason.Edenyincompatibleanticheat;

        public const Native.EDenyReason Edenymemorycorruption = EDenyReason.Edenymemorycorruption;

        public const Native.EDenyReason Edenyincompatiblesoftware = EDenyReason.Edenyincompatiblesoftware;

        public const Native.EDenyReason Edenysteamconnectionlost = EDenyReason.Edenysteamconnectionlost;

        public const Native.EDenyReason Edenysteamconnectionerror = EDenyReason.Edenysteamconnectionerror;

        public const Native.EDenyReason Edenysteamresponsetimedout = EDenyReason.Edenysteamresponsetimedout;

        public const Native.EDenyReason Edenysteamvalidationstalled = EDenyReason.Edenysteamvalidationstalled;

        public const Native.EDenyReason Edenysteamownerleftguestuser = EDenyReason.Edenysteamownerleftguestuser;

        /// <summary>
        /// results from BeginAuthSession
        /// </summary>
        public enum EBeginAuthSessionResult : int
        {
            /// <summary>
            /// Ticket is valid for this game and this steamID.
            /// </summary>
            Ebeginauthsessionresultok = unchecked((int)0),

            /// <summary>
            /// Ticket is not valid.
            /// </summary>
            Ebeginauthsessionresultinvalidticket = unchecked((int)1),

            /// <summary>
            /// A ticket has already been submitted for this steamID
            /// </summary>
            Ebeginauthsessionresultduplicaterequest = unchecked((int)2),

            /// <summary>
            /// Ticket is from an incompatible interface version
            /// </summary>
            Ebeginauthsessionresultinvalidversion = unchecked((int)3),

            /// <summary>
            /// Ticket is not for this game
            /// </summary>
            Ebeginauthsessionresultgamemismatch = unchecked((int)4),

            /// <summary>
            /// Ticket has expired
            /// </summary>
            Ebeginauthsessionresultexpiredticket = unchecked((int)5),
        }

        /// <summary>
        /// Ticket is valid for this game and this steamID.
        /// </summary>
        public const Native.EBeginAuthSessionResult Ebeginauthsessionresultok = EBeginAuthSessionResult.Ebeginauthsessionresultok;

        /// <summary>
        /// Ticket is not valid.
        /// </summary>
        public const Native.EBeginAuthSessionResult Ebeginauthsessionresultinvalidticket = EBeginAuthSessionResult.Ebeginauthsessionresultinvalidticket;

        /// <summary>
        /// A ticket has already been submitted for this steamID
        /// </summary>
        public const Native.EBeginAuthSessionResult Ebeginauthsessionresultduplicaterequest = EBeginAuthSessionResult.Ebeginauthsessionresultduplicaterequest;

        /// <summary>
        /// Ticket is from an incompatible interface version
        /// </summary>
        public const Native.EBeginAuthSessionResult Ebeginauthsessionresultinvalidversion = EBeginAuthSessionResult.Ebeginauthsessionresultinvalidversion;

        /// <summary>
        /// Ticket is not for this game
        /// </summary>
        public const Native.EBeginAuthSessionResult Ebeginauthsessionresultgamemismatch = EBeginAuthSessionResult.Ebeginauthsessionresultgamemismatch;

        /// <summary>
        /// Ticket has expired
        /// </summary>
        public const Native.EBeginAuthSessionResult Ebeginauthsessionresultexpiredticket = EBeginAuthSessionResult.Ebeginauthsessionresultexpiredticket;

        /// <summary>
        /// Callback values for callback ValidateAuthTicketResponse_t which is a response to BeginAuthSession
        /// </summary>
        public enum EAuthSessionResponse : int
        {
            /// <summary>
            /// Steam has verified the user is online, the ticket is valid and ticket has not been reused.
            /// </summary>
            Eauthsessionresponseok = unchecked((int)0),

            /// <summary>
            /// The user in question is not connected to steam
            /// </summary>
            Eauthsessionresponseusernotconnectedtosteam = unchecked((int)1),

            /// <summary>
            /// The license has expired.
            /// </summary>
            Eauthsessionresponsenolicenseorexpired = unchecked((int)2),

            /// <summary>
            /// The user is VAC banned for this game.
            /// </summary>
            Eauthsessionresponsevacbanned = unchecked((int)3),

            /// <summary>
            /// The user account has logged in elsewhere and the session containing the game instance has been disconnected.
            /// </summary>
            Eauthsessionresponseloggedinelsewhere = unchecked((int)4),

            /// <summary>
            /// VAC has been unable to perform anti-cheat checks on this user
            /// </summary>
            Eauthsessionresponsevacchecktimedout = unchecked((int)5),

            /// <summary>
            /// The ticket has been canceled by the issuer
            /// </summary>
            Eauthsessionresponseauthticketcanceled = unchecked((int)6),

            /// <summary>
            /// This ticket has already been used, it is not valid.
            /// </summary>
            Eauthsessionresponseauthticketinvalidalreadyused = unchecked((int)7),

            /// <summary>
            /// This ticket is not from a user instance currently connected to steam.
            /// </summary>
            Eauthsessionresponseauthticketinvalid = unchecked((int)8),

            /// <summary>
            /// The user is banned for this game. The ban came via the web api and not VAC
            /// </summary>
            Eauthsessionresponsepublisherissuedban = unchecked((int)9),
        }

        /// <summary>
        /// Steam has verified the user is online, the ticket is valid and ticket has not been reused.
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponseok = EAuthSessionResponse.Eauthsessionresponseok;

        /// <summary>
        /// The user in question is not connected to steam
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponseusernotconnectedtosteam = EAuthSessionResponse.Eauthsessionresponseusernotconnectedtosteam;

        /// <summary>
        /// The license has expired.
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponsenolicenseorexpired = EAuthSessionResponse.Eauthsessionresponsenolicenseorexpired;

        /// <summary>
        /// The user is VAC banned for this game.
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponsevacbanned = EAuthSessionResponse.Eauthsessionresponsevacbanned;

        /// <summary>
        /// The user account has logged in elsewhere and the session containing the game instance has been disconnected.
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponseloggedinelsewhere = EAuthSessionResponse.Eauthsessionresponseloggedinelsewhere;

        /// <summary>
        /// VAC has been unable to perform anti-cheat checks on this user
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponsevacchecktimedout = EAuthSessionResponse.Eauthsessionresponsevacchecktimedout;

        /// <summary>
        /// The ticket has been canceled by the issuer
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponseauthticketcanceled = EAuthSessionResponse.Eauthsessionresponseauthticketcanceled;

        /// <summary>
        /// This ticket has already been used, it is not valid.
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponseauthticketinvalidalreadyused = EAuthSessionResponse.Eauthsessionresponseauthticketinvalidalreadyused;

        /// <summary>
        /// This ticket is not from a user instance currently connected to steam.
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponseauthticketinvalid = EAuthSessionResponse.Eauthsessionresponseauthticketinvalid;

        /// <summary>
        /// The user is banned for this game. The ban came via the web api and not VAC
        /// </summary>
        public const Native.EAuthSessionResponse Eauthsessionresponsepublisherissuedban = EAuthSessionResponse.Eauthsessionresponsepublisherissuedban;

        /// <summary>
        /// results from UserHasLicenseForApp
        /// </summary>
        public enum EUserHasLicenseForAppResult : int
        {
            /// <summary>
            /// User has a license for specified app
            /// </summary>
            Euserhaslicenseresulthaslicense = unchecked((int)0),

            /// <summary>
            /// User does not have a license for the specified app
            /// </summary>
            Euserhaslicenseresultdoesnothavelicense = unchecked((int)1),

            /// <summary>
            /// User has not been authenticated
            /// </summary>
            Euserhaslicenseresultnoauth = unchecked((int)2),
        }

        /// <summary>
        /// User has a license for specified app
        /// </summary>
        public const Native.EUserHasLicenseForAppResult Euserhaslicenseresulthaslicense = EUserHasLicenseForAppResult.Euserhaslicenseresulthaslicense;

        /// <summary>
        /// User does not have a license for the specified app
        /// </summary>
        public const Native.EUserHasLicenseForAppResult Euserhaslicenseresultdoesnothavelicense = EUserHasLicenseForAppResult.Euserhaslicenseresultdoesnothavelicense;

        /// <summary>
        /// User has not been authenticated
        /// </summary>
        public const Native.EUserHasLicenseForAppResult Euserhaslicenseresultnoauth = EUserHasLicenseForAppResult.Euserhaslicenseresultnoauth;

        /// <summary>
        /// Steam account types
        /// </summary>
        public enum EAccountType : int
        {
            Eaccounttypeinvalid = unchecked((int)0),

            /// <summary>
            /// single user account
            /// </summary>
            Eaccounttypeindividual = unchecked((int)1),

            /// <summary>
            /// multiseat (e.g. cybercafe) account
            /// </summary>
            Eaccounttypemultiseat = unchecked((int)2),

            /// <summary>
            /// game server account
            /// </summary>
            Eaccounttypegameserver = unchecked((int)3),

            /// <summary>
            /// anonymous game server account
            /// </summary>
            Eaccounttypeanongameserver = unchecked((int)4),

            /// <summary>
            /// pending
            /// </summary>
            Eaccounttypepending = unchecked((int)5),

            /// <summary>
            /// content server
            /// </summary>
            Eaccounttypecontentserver = unchecked((int)6),

            Eaccounttypeclan = unchecked((int)7),

            Eaccounttypechat = unchecked((int)8),

            /// <summary>
            /// Fake SteamID for local PSN account on PS3 or Live account on 360, etc.
            /// </summary>
            Eaccounttypeconsoleuser = unchecked((int)9),

            Eaccounttypeanonuser = unchecked((int)10),

            /// <summary>
            /// Max of 16 items in this field
            /// </summary>
            Eaccounttypemax,
        }

        public const Native.EAccountType Eaccounttypeinvalid = EAccountType.Eaccounttypeinvalid;

        /// <summary>
        /// single user account
        /// </summary>
        public const Native.EAccountType Eaccounttypeindividual = EAccountType.Eaccounttypeindividual;

        /// <summary>
        /// multiseat (e.g. cybercafe) account
        /// </summary>
        public const Native.EAccountType Eaccounttypemultiseat = EAccountType.Eaccounttypemultiseat;

        /// <summary>
        /// game server account
        /// </summary>
        public const Native.EAccountType Eaccounttypegameserver = EAccountType.Eaccounttypegameserver;

        /// <summary>
        /// anonymous game server account
        /// </summary>
        public const Native.EAccountType Eaccounttypeanongameserver = EAccountType.Eaccounttypeanongameserver;

        /// <summary>
        /// pending
        /// </summary>
        public const Native.EAccountType Eaccounttypepending = EAccountType.Eaccounttypepending;

        /// <summary>
        /// content server
        /// </summary>
        public const Native.EAccountType Eaccounttypecontentserver = EAccountType.Eaccounttypecontentserver;

        public const Native.EAccountType Eaccounttypeclan = EAccountType.Eaccounttypeclan;

        public const Native.EAccountType Eaccounttypechat = EAccountType.Eaccounttypechat;

        /// <summary>
        /// Fake SteamID for local PSN account on PS3 or Live account on 360, etc.
        /// </summary>
        public const Native.EAccountType Eaccounttypeconsoleuser = EAccountType.Eaccounttypeconsoleuser;

        public const Native.EAccountType Eaccounttypeanonuser = EAccountType.Eaccounttypeanonuser;

        /// <summary>
        /// Max of 16 items in this field
        /// </summary>
        public const Native.EAccountType Eaccounttypemax = EAccountType.Eaccounttypemax;

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Chat Entry Types (previously was only friend-to-friend message types)
        /// -----------------------------------------------------------------------------
        /// </summary>
        public enum EChatEntryType : int
        {
            Echatentrytypeinvalid = unchecked((int)0),

            /// <summary>
            /// Normal text message from another user
            /// </summary>
            Echatentrytypechatmsg = unchecked((int)1),

            /// <summary>
            /// Another user is typing (not used in multi-user chat)
            /// </summary>
            Echatentrytypetyping = unchecked((int)2),

            /// <summary>
            /// Invite from other user into that users current game
            /// </summary>
            Echatentrytypeinvitegame = unchecked((int)3),

            /// <summary>
            /// text emote message (deprecated, should be treated as ChatMsg)
            /// </summary>
            Echatentrytypeemote = unchecked((int)4),

            /// <summary>
            /// user has left the conversation ( closed chat window )
            /// </summary>
            Echatentrytypeleftconversation = unchecked((int)6),

            /// <summary>
            /// user has entered the conversation (used in multi-user chat and group chat)
            /// </summary>
            Echatentrytypeentered = unchecked((int)7),

            /// <summary>
            /// user was kicked (data: 64-bit steamid of actor performing the kick)
            /// </summary>
            Echatentrytypewaskicked = unchecked((int)8),

            /// <summary>
            /// user was banned (data: 64-bit steamid of actor performing the ban)
            /// </summary>
            Echatentrytypewasbanned = unchecked((int)9),

            /// <summary>
            /// user disconnected
            /// </summary>
            Echatentrytypedisconnected = unchecked((int)10),

            /// <summary>
            /// a chat message from user's chat history or offilne message
            /// </summary>
            Echatentrytypehistoricalchat = unchecked((int)11),

            /// <summary>
            /// a link was removed by the chat filter.
            /// </summary>
            Echatentrytypelinkblocked = unchecked((int)14),
        }

        public const Native.EChatEntryType Echatentrytypeinvalid = EChatEntryType.Echatentrytypeinvalid;

        /// <summary>
        /// Normal text message from another user
        /// </summary>
        public const Native.EChatEntryType Echatentrytypechatmsg = EChatEntryType.Echatentrytypechatmsg;

        /// <summary>
        /// Another user is typing (not used in multi-user chat)
        /// </summary>
        public const Native.EChatEntryType Echatentrytypetyping = EChatEntryType.Echatentrytypetyping;

        /// <summary>
        /// Invite from other user into that users current game
        /// </summary>
        public const Native.EChatEntryType Echatentrytypeinvitegame = EChatEntryType.Echatentrytypeinvitegame;

        /// <summary>
        /// text emote message (deprecated, should be treated as ChatMsg)
        /// </summary>
        public const Native.EChatEntryType Echatentrytypeemote = EChatEntryType.Echatentrytypeemote;

        /// <summary>
        /// user has left the conversation ( closed chat window )
        /// </summary>
        public const Native.EChatEntryType Echatentrytypeleftconversation = EChatEntryType.Echatentrytypeleftconversation;

        /// <summary>
        /// user has entered the conversation (used in multi-user chat and group chat)
        /// </summary>
        public const Native.EChatEntryType Echatentrytypeentered = EChatEntryType.Echatentrytypeentered;

        /// <summary>
        /// user was kicked (data: 64-bit steamid of actor performing the kick)
        /// </summary>
        public const Native.EChatEntryType Echatentrytypewaskicked = EChatEntryType.Echatentrytypewaskicked;

        /// <summary>
        /// user was banned (data: 64-bit steamid of actor performing the ban)
        /// </summary>
        public const Native.EChatEntryType Echatentrytypewasbanned = EChatEntryType.Echatentrytypewasbanned;

        /// <summary>
        /// user disconnected
        /// </summary>
        public const Native.EChatEntryType Echatentrytypedisconnected = EChatEntryType.Echatentrytypedisconnected;

        /// <summary>
        /// a chat message from user's chat history or offilne message
        /// </summary>
        public const Native.EChatEntryType Echatentrytypehistoricalchat = EChatEntryType.Echatentrytypehistoricalchat;

        /// <summary>
        /// a link was removed by the chat filter.
        /// </summary>
        public const Native.EChatEntryType Echatentrytypelinkblocked = EChatEntryType.Echatentrytypelinkblocked;

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Chat Room Enter Responses
        /// -----------------------------------------------------------------------------
        /// </summary>
        public enum EChatRoomEnterResponse : int
        {
            /// <summary>
            /// Success
            /// </summary>
            Echatroomenterresponsesuccess = unchecked((int)1),

            /// <summary>
            /// Chat doesn't exist (probably closed)
            /// </summary>
            Echatroomenterresponsedoesntexist = unchecked((int)2),

            /// <summary>
            /// General Denied - You don't have the permissions needed to join the chat
            /// </summary>
            Echatroomenterresponsenotallowed = unchecked((int)3),

            /// <summary>
            /// Chat room has reached its maximum size
            /// </summary>
            Echatroomenterresponsefull = unchecked((int)4),

            /// <summary>
            /// Unexpected Error
            /// </summary>
            Echatroomenterresponseerror = unchecked((int)5),

            /// <summary>
            /// You are banned from this chat room and may not join
            /// </summary>
            Echatroomenterresponsebanned = unchecked((int)6),

            /// <summary>
            /// Joining this chat is not allowed because you are a limited user (no value on account)
            /// </summary>
            Echatroomenterresponselimited = unchecked((int)7),

            /// <summary>
            /// Attempt to join a clan chat when the clan is locked or disabled
            /// </summary>
            Echatroomenterresponseclandisabled = unchecked((int)8),

            /// <summary>
            /// Attempt to join a chat when the user has a community lock on their account
            /// </summary>
            Echatroomenterresponsecommunityban = unchecked((int)9),

            /// <summary>
            /// Join failed - some member in the chat has blocked you from joining
            /// </summary>
            Echatroomenterresponsememberblockedyou = unchecked((int)10),

            /// <summary>
            /// Join failed - you have blocked some member already in the chat
            /// </summary>
            Echatroomenterresponseyoublockedmember = unchecked((int)11),

            /// <summary>
            /// Join failed - to many join attempts in a very short period of time
            /// </summary>
            Echatroomenterresponseratelimitexceeded = unchecked((int)15),
        }

        /// <summary>
        /// Success
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponsesuccess = EChatRoomEnterResponse.Echatroomenterresponsesuccess;

        /// <summary>
        /// Chat doesn't exist (probably closed)
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponsedoesntexist = EChatRoomEnterResponse.Echatroomenterresponsedoesntexist;

        /// <summary>
        /// General Denied - You don't have the permissions needed to join the chat
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponsenotallowed = EChatRoomEnterResponse.Echatroomenterresponsenotallowed;

        /// <summary>
        /// Chat room has reached its maximum size
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponsefull = EChatRoomEnterResponse.Echatroomenterresponsefull;

        /// <summary>
        /// Unexpected Error
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponseerror = EChatRoomEnterResponse.Echatroomenterresponseerror;

        /// <summary>
        /// You are banned from this chat room and may not join
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponsebanned = EChatRoomEnterResponse.Echatroomenterresponsebanned;

        /// <summary>
        /// Joining this chat is not allowed because you are a limited user (no value on account)
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponselimited = EChatRoomEnterResponse.Echatroomenterresponselimited;

        /// <summary>
        /// Attempt to join a clan chat when the clan is locked or disabled
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponseclandisabled = EChatRoomEnterResponse.Echatroomenterresponseclandisabled;

        /// <summary>
        /// Attempt to join a chat when the user has a community lock on their account
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponsecommunityban = EChatRoomEnterResponse.Echatroomenterresponsecommunityban;

        /// <summary>
        /// Join failed - some member in the chat has blocked you from joining
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponsememberblockedyou = EChatRoomEnterResponse.Echatroomenterresponsememberblockedyou;

        /// <summary>
        /// Join failed - you have blocked some member already in the chat
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponseyoublockedmember = EChatRoomEnterResponse.Echatroomenterresponseyoublockedmember;

        /// <summary>
        /// Join failed - to many join attempts in a very short period of time
        /// </summary>
        public const Native.EChatRoomEnterResponse Echatroomenterresponseratelimitexceeded = EChatRoomEnterResponse.Echatroomenterresponseratelimitexceeded;

        /// <summary>
        /// Special flags for Chat accounts - they go in the top 8 bits
        /// of the steam ID's "instance", leaving 12 for the actual instances
        /// </summary>
        public enum EChatSteamIDInstanceFlags : int
        {
            /// <summary>
            /// top 8 bits are flags
            /// </summary>
            Echataccountinstancemask = unchecked((int)0x00000FFF),

            /// <summary>
            /// top bit
            /// </summary>
            Echatinstanceflagclan = unchecked((int)(k_unSteamAccountInstanceMask + 1) >> 1),

            /// <summary>
            /// next one down, etc
            /// </summary>
            Echatinstanceflaglobby = unchecked((int)(k_unSteamAccountInstanceMask + 1) >> 2),

            /// <summary>
            /// next one down, etc
            /// </summary>
            Echatinstanceflagmmslobby = unchecked((int)(k_unSteamAccountInstanceMask + 1) >> 3),
        }

        /// <summary>
        /// top 8 bits are flags
        /// </summary>
        public const Native.EChatSteamIDInstanceFlags Echataccountinstancemask = EChatSteamIDInstanceFlags.Echataccountinstancemask;

        /// <summary>
        /// top bit
        /// </summary>
        public const Native.EChatSteamIDInstanceFlags Echatinstanceflagclan = EChatSteamIDInstanceFlags.Echatinstanceflagclan;

        /// <summary>
        /// next one down, etc
        /// </summary>
        public const Native.EChatSteamIDInstanceFlags Echatinstanceflaglobby = EChatSteamIDInstanceFlags.Echatinstanceflaglobby;

        /// <summary>
        /// next one down, etc
        /// </summary>
        public const Native.EChatSteamIDInstanceFlags Echatinstanceflagmmslobby = EChatSteamIDInstanceFlags.Echatinstanceflagmmslobby;

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Possible positions to tell the overlay to show notifications in
        /// -----------------------------------------------------------------------------
        /// </summary>
        public enum ENotificationPosition : int
        {
            Epositiontopleft = unchecked((int)0),

            Epositiontopright = unchecked((int)1),

            Epositionbottomleft = unchecked((int)2),

            Epositionbottomright = unchecked((int)3),
        }

        public const Native.ENotificationPosition Epositiontopleft = ENotificationPosition.Epositiontopleft;

        public const Native.ENotificationPosition Epositiontopright = ENotificationPosition.Epositiontopright;

        public const Native.ENotificationPosition Epositionbottomleft = ENotificationPosition.Epositionbottomleft;

        public const Native.ENotificationPosition Epositionbottomright = ENotificationPosition.Epositionbottomright;

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Broadcast upload result details
        /// -----------------------------------------------------------------------------
        /// </summary>
        public enum EBroadcastUploadResult : int
        {
            /// <summary>
            /// broadcast state unknown
            /// </summary>
            Ebroadcastuploadresultnone = unchecked((int)0),

            /// <summary>
            /// broadcast was good, no problems
            /// </summary>
            Ebroadcastuploadresultok = unchecked((int)1),

            /// <summary>
            /// broadcast init failed
            /// </summary>
            Ebroadcastuploadresultinitfailed = unchecked((int)2),

            /// <summary>
            /// broadcast frame upload failed
            /// </summary>
            Ebroadcastuploadresultframefailed = unchecked((int)3),

            /// <summary>
            /// broadcast upload timed out
            /// </summary>
            Ebroadcastuploadresulttimeout = unchecked((int)4),

            /// <summary>
            /// broadcast send too much data
            /// </summary>
            Ebroadcastuploadresultbandwidthexceeded = unchecked((int)5),

            /// <summary>
            /// broadcast FPS too low
            /// </summary>
            Ebroadcastuploadresultlowfps = unchecked((int)6),

            /// <summary>
            /// broadcast sending not enough key frames
            /// </summary>
            Ebroadcastuploadresultmissingkeyframes = unchecked((int)7),

            /// <summary>
            /// broadcast client failed to connect to relay
            /// </summary>
            Ebroadcastuploadresultnoconnection = unchecked((int)8),

            /// <summary>
            /// relay dropped the upload
            /// </summary>
            Ebroadcastuploadresultrelayfailed = unchecked((int)9),

            /// <summary>
            /// the client changed broadcast settings
            /// </summary>
            Ebroadcastuploadresultsettingschanged = unchecked((int)10),

            /// <summary>
            /// client failed to send audio data
            /// </summary>
            Ebroadcastuploadresultmissingaudio = unchecked((int)11),

            /// <summary>
            /// clients was too slow uploading
            /// </summary>
            Ebroadcastuploadresulttoofarbehind = unchecked((int)12),

            /// <summary>
            /// server failed to keep up with transcode
            /// </summary>
            Ebroadcastuploadresulttranscodebehind = unchecked((int)13),

            /// <summary>
            /// Broadcast does not have permissions to play game
            /// </summary>
            Ebroadcastuploadresultnotallowedtoplay = unchecked((int)14),

            /// <summary>
            /// RTMP host to busy to take new broadcast stream, choose another
            /// </summary>
            Ebroadcastuploadresultbusy = unchecked((int)15),

            /// <summary>
            /// Account banned from community broadcast
            /// </summary>
            Ebroadcastuploadresultbanned = unchecked((int)16),

            /// <summary>
            /// We already already have an stream running.
            /// </summary>
            Ebroadcastuploadresultalreadyactive = unchecked((int)17),

            /// <summary>
            /// We explicitly shutting down a broadcast
            /// </summary>
            Ebroadcastuploadresultforcedoff = unchecked((int)18),

            /// <summary>
            /// Audio stream was too far behind video
            /// </summary>
            Ebroadcastuploadresultaudiobehind = unchecked((int)19),

            /// <summary>
            /// Broadcast Server was shut down
            /// </summary>
            Ebroadcastuploadresultshutdown = unchecked((int)20),

            /// <summary>
            /// broadcast uploader TCP disconnected
            /// </summary>
            Ebroadcastuploadresultdisconnect = unchecked((int)21),

            /// <summary>
            /// invalid video settings
            /// </summary>
            Ebroadcastuploadresultvideoinitfailed = unchecked((int)22),

            /// <summary>
            /// invalid audio settings
            /// </summary>
            Ebroadcastuploadresultaudioinitfailed = unchecked((int)23),
        }

        /// <summary>
        /// broadcast state unknown
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultnone = EBroadcastUploadResult.Ebroadcastuploadresultnone;

        /// <summary>
        /// broadcast was good, no problems
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultok = EBroadcastUploadResult.Ebroadcastuploadresultok;

        /// <summary>
        /// broadcast init failed
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultinitfailed = EBroadcastUploadResult.Ebroadcastuploadresultinitfailed;

        /// <summary>
        /// broadcast frame upload failed
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultframefailed = EBroadcastUploadResult.Ebroadcastuploadresultframefailed;

        /// <summary>
        /// broadcast upload timed out
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresulttimeout = EBroadcastUploadResult.Ebroadcastuploadresulttimeout;

        /// <summary>
        /// broadcast send too much data
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultbandwidthexceeded = EBroadcastUploadResult.Ebroadcastuploadresultbandwidthexceeded;

        /// <summary>
        /// broadcast FPS too low
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultlowfps = EBroadcastUploadResult.Ebroadcastuploadresultlowfps;

        /// <summary>
        /// broadcast sending not enough key frames
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultmissingkeyframes = EBroadcastUploadResult.Ebroadcastuploadresultmissingkeyframes;

        /// <summary>
        /// broadcast client failed to connect to relay
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultnoconnection = EBroadcastUploadResult.Ebroadcastuploadresultnoconnection;

        /// <summary>
        /// relay dropped the upload
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultrelayfailed = EBroadcastUploadResult.Ebroadcastuploadresultrelayfailed;

        /// <summary>
        /// the client changed broadcast settings
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultsettingschanged = EBroadcastUploadResult.Ebroadcastuploadresultsettingschanged;

        /// <summary>
        /// client failed to send audio data
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultmissingaudio = EBroadcastUploadResult.Ebroadcastuploadresultmissingaudio;

        /// <summary>
        /// clients was too slow uploading
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresulttoofarbehind = EBroadcastUploadResult.Ebroadcastuploadresulttoofarbehind;

        /// <summary>
        /// server failed to keep up with transcode
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresulttranscodebehind = EBroadcastUploadResult.Ebroadcastuploadresulttranscodebehind;

        /// <summary>
        /// Broadcast does not have permissions to play game
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultnotallowedtoplay = EBroadcastUploadResult.Ebroadcastuploadresultnotallowedtoplay;

        /// <summary>
        /// RTMP host to busy to take new broadcast stream, choose another
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultbusy = EBroadcastUploadResult.Ebroadcastuploadresultbusy;

        /// <summary>
        /// Account banned from community broadcast
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultbanned = EBroadcastUploadResult.Ebroadcastuploadresultbanned;

        /// <summary>
        /// We already already have an stream running.
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultalreadyactive = EBroadcastUploadResult.Ebroadcastuploadresultalreadyactive;

        /// <summary>
        /// We explicitly shutting down a broadcast
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultforcedoff = EBroadcastUploadResult.Ebroadcastuploadresultforcedoff;

        /// <summary>
        /// Audio stream was too far behind video
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultaudiobehind = EBroadcastUploadResult.Ebroadcastuploadresultaudiobehind;

        /// <summary>
        /// Broadcast Server was shut down
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultshutdown = EBroadcastUploadResult.Ebroadcastuploadresultshutdown;

        /// <summary>
        /// broadcast uploader TCP disconnected
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultdisconnect = EBroadcastUploadResult.Ebroadcastuploadresultdisconnect;

        /// <summary>
        /// invalid video settings
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultvideoinitfailed = EBroadcastUploadResult.Ebroadcastuploadresultvideoinitfailed;

        /// <summary>
        /// invalid audio settings
        /// </summary>
        public const Native.EBroadcastUploadResult Ebroadcastuploadresultaudioinitfailed = EBroadcastUploadResult.Ebroadcastuploadresultaudioinitfailed;

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Reasons a user may not use the Community Market.
        /// Used in MarketEligibilityResponse_t.
        /// -----------------------------------------------------------------------------
        /// </summary>
        [Flags]
        public enum EMarketNotAllowedReasonFlags : int
        {
            EmarketnotallowedreasonNone = unchecked((int)0),

            /// <summary>
            /// A back-end call failed or something that might work again on retry
            /// </summary>
            EmarketnotallowedreasonTemporaryfailure = unchecked((int)(1 << (int)0)),

            /// <summary>
            /// Disabled account
            /// </summary>
            EmarketnotallowedreasonAccountdisabled = unchecked((int)(1 << (int)1)),

            /// <summary>
            /// Locked account
            /// </summary>
            EmarketnotallowedreasonAccountlockeddown = unchecked((int)(1 << (int)2)),

            /// <summary>
            /// Limited account (no purchases)
            /// </summary>
            EmarketnotallowedreasonAccountlimited = unchecked((int)(1 << (int)3)),

            /// <summary>
            /// The account is banned from trading items
            /// </summary>
            EmarketnotallowedreasonTradebanned = unchecked((int)(1 << (int)4)),

            /// <summary>
            /// Wallet funds aren't tradable because the user has had no purchase
            /// activity in the last year or has had no purchases prior to last month
            /// </summary>
            EmarketnotallowedreasonAccountnottrusted = unchecked((int)(1 << (int)5)),

            /// <summary>
            /// The user doesn't have Steam Guard enabled
            /// </summary>
            EmarketnotallowedreasonSteamguardnotenabled = unchecked((int)(1 << (int)6)),

            /// <summary>
            /// The user has Steam Guard, but it hasn't been enabled for the required
            /// number of days
            /// </summary>
            EmarketnotallowedreasonSteamguardonlyrecentlyenabled = unchecked((int)(1 << (int)7)),

            /// <summary>
            /// The user has recently forgotten their password and reset it
            /// </summary>
            EmarketnotallowedreasonRecentpasswordreset = unchecked((int)(1 << (int)8)),

            /// <summary>
            /// The user has recently funded his or her wallet with a new payment method
            /// </summary>
            EmarketnotallowedreasonNewpaymentmethod = unchecked((int)(1 << (int)9)),

            /// <summary>
            /// An invalid cookie was sent by the user
            /// </summary>
            EmarketnotallowedreasonInvalidcookie = unchecked((int)(1 << (int)10)),

            /// <summary>
            /// The user has Steam Guard, but is using a new computer or web browser
            /// </summary>
            EmarketnotallowedreasonUsingnewdevice = unchecked((int)(1 << (int)11)),

            /// <summary>
            /// The user has recently refunded a store purchase by his or herself
            /// </summary>
            EmarketnotallowedreasonRecentselfrefund = unchecked((int)(1 << (int)12)),

            /// <summary>
            /// The user has recently funded his or her wallet with a new payment method that cannot be verified
            /// </summary>
            EmarketnotallowedreasonNewpaymentmethodcannotbeverified = unchecked((int)(1 << (int)13)),

            /// <summary>
            /// Not only is the account not trusted, but they have no recent purchases at all
            /// </summary>
            EmarketnotallowedreasonNorecentpurchases = unchecked((int)(1 << (int)14)),

            /// <summary>
            /// User accepted a wallet gift that was recently purchased
            /// </summary>
            EmarketnotallowedreasonAcceptedwalletgift = unchecked((int)(1 << (int)15)),
        }

        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonNone = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonNone;

        /// <summary>
        /// A back-end call failed or something that might work again on retry
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonTemporaryfailure = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonTemporaryfailure;

        /// <summary>
        /// Disabled account
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonAccountdisabled = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonAccountdisabled;

        /// <summary>
        /// Locked account
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonAccountlockeddown = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonAccountlockeddown;

        /// <summary>
        /// Limited account (no purchases)
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonAccountlimited = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonAccountlimited;

        /// <summary>
        /// The account is banned from trading items
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonTradebanned = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonTradebanned;

        /// <summary>
        /// Wallet funds aren't tradable because the user has had no purchase
        /// activity in the last year or has had no purchases prior to last month
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonAccountnottrusted = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonAccountnottrusted;

        /// <summary>
        /// The user doesn't have Steam Guard enabled
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonSteamguardnotenabled = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonSteamguardnotenabled;

        /// <summary>
        /// The user has Steam Guard, but it hasn't been enabled for the required
        /// number of days
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonSteamguardonlyrecentlyenabled = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonSteamguardonlyrecentlyenabled;

        /// <summary>
        /// The user has recently forgotten their password and reset it
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonRecentpasswordreset = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonRecentpasswordreset;

        /// <summary>
        /// The user has recently funded his or her wallet with a new payment method
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonNewpaymentmethod = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonNewpaymentmethod;

        /// <summary>
        /// An invalid cookie was sent by the user
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonInvalidcookie = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonInvalidcookie;

        /// <summary>
        /// The user has Steam Guard, but is using a new computer or web browser
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonUsingnewdevice = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonUsingnewdevice;

        /// <summary>
        /// The user has recently refunded a store purchase by his or herself
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonRecentselfrefund = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonRecentselfrefund;

        /// <summary>
        /// The user has recently funded his or her wallet with a new payment method that cannot be verified
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonNewpaymentmethodcannotbeverified = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonNewpaymentmethodcannotbeverified;

        /// <summary>
        /// Not only is the account not trusted, but they have no recent purchases at all
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonNorecentpurchases = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonNorecentpurchases;

        /// <summary>
        /// User accepted a wallet gift that was recently purchased
        /// </summary>
        public const Native.EMarketNotAllowedReasonFlags EmarketnotallowedreasonAcceptedwalletgift = EMarketNotAllowedReasonFlags.EmarketnotallowedreasonAcceptedwalletgift;

        /// <summary>
        /// describes XP / progress restrictions to apply for games with duration control /
        /// anti-indulgence enabled for minor Steam China users.
        /// </summary>
        /// <remarks>
        /// WARNING: DO NOT RENUMBER
        /// </remarks>
        public enum EDurationControlProgress : int
        {
            /// <summary>
            /// Full progress
            /// </summary>
            EdurationcontrolprogressFull = unchecked((int)0),

            /// <summary>
            /// deprecated - XP or persistent rewards should be halved
            /// </summary>
            EdurationcontrolprogressHalf = unchecked((int)1),

            /// <summary>
            /// deprecated - XP or persistent rewards should be stopped
            /// </summary>
            EdurationcontrolprogressNone = unchecked((int)2),

            /// <summary>
            /// allowed 3h time since 5h gap/break has elapsed, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolExitsoon3h = unchecked((int)3),

            /// <summary>
            /// allowed 5h time in calendar day has elapsed, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolExitsoon5h = unchecked((int)4),

            /// <summary>
            /// game running after day period, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolExitsoonNight = unchecked((int)5),
        }

        /// <summary>
        /// Full progress
        /// </summary>
        public const Native.EDurationControlProgress EdurationcontrolprogressFull = EDurationControlProgress.EdurationcontrolprogressFull;

        /// <summary>
        /// deprecated - XP or persistent rewards should be halved
        /// </summary>
        public const Native.EDurationControlProgress EdurationcontrolprogressHalf = EDurationControlProgress.EdurationcontrolprogressHalf;

        /// <summary>
        /// deprecated - XP or persistent rewards should be stopped
        /// </summary>
        public const Native.EDurationControlProgress EdurationcontrolprogressNone = EDurationControlProgress.EdurationcontrolprogressNone;

        /// <summary>
        /// allowed 3h time since 5h gap/break has elapsed, game should exit - steam will terminate the game soon
        /// </summary>
        public const Native.EDurationControlProgress EdurationcontrolExitsoon3h = EDurationControlProgress.EdurationcontrolExitsoon3h;

        /// <summary>
        /// allowed 5h time in calendar day has elapsed, game should exit - steam will terminate the game soon
        /// </summary>
        public const Native.EDurationControlProgress EdurationcontrolExitsoon5h = EDurationControlProgress.EdurationcontrolExitsoon5h;

        /// <summary>
        /// game running after day period, game should exit - steam will terminate the game soon
        /// </summary>
        public const Native.EDurationControlProgress EdurationcontrolExitsoonNight = EDurationControlProgress.EdurationcontrolExitsoonNight;

        /// <summary>
        /// describes which notification timer has expired, for steam china duration control feature
        /// </summary>
        /// <remarks>
        /// WARNING: DO NOT RENUMBER
        /// </remarks>
        public enum EDurationControlNotification : int
        {
            /// <summary>
            /// just informing you about progress, no notification to show
            /// </summary>
            EdurationcontrolnotificationNone = unchecked((int)0),

            /// <summary>
            /// "you've been playing for N hours"
            /// </summary>
            Edurationcontrolnotification1hour = unchecked((int)1),

            /// <summary>
            /// deprecated - "you've been playing for 3 hours; take a break"
            /// </summary>
            Edurationcontrolnotification3hours = unchecked((int)2),

            /// <summary>
            /// deprecated - "your XP / progress is half normal"
            /// </summary>
            EdurationcontrolnotificationHalfprogress = unchecked((int)3),

            /// <summary>
            /// deprecated - "your XP / progress is zero"
            /// </summary>
            EdurationcontrolnotificationNoprogress = unchecked((int)4),

            /// <summary>
            /// allowed 3h time since 5h gap/break has elapsed, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolnotificationExitsoon3h = unchecked((int)5),

            /// <summary>
            /// allowed 5h time in calendar day has elapsed, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolnotificationExitsoon5h = unchecked((int)6),

            /// <summary>
            /// game running after day period, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolnotificationExitsoonNight = unchecked((int)7),
        }

        /// <summary>
        /// just informing you about progress, no notification to show
        /// </summary>
        public const Native.EDurationControlNotification EdurationcontrolnotificationNone = EDurationControlNotification.EdurationcontrolnotificationNone;

        /// <summary>
        /// "you've been playing for N hours"
        /// </summary>
        public const Native.EDurationControlNotification Edurationcontrolnotification1hour = EDurationControlNotification.Edurationcontrolnotification1hour;

        /// <summary>
        /// deprecated - "you've been playing for 3 hours; take a break"
        /// </summary>
        public const Native.EDurationControlNotification Edurationcontrolnotification3hours = EDurationControlNotification.Edurationcontrolnotification3hours;

        /// <summary>
        /// deprecated - "your XP / progress is half normal"
        /// </summary>
        public const Native.EDurationControlNotification EdurationcontrolnotificationHalfprogress = EDurationControlNotification.EdurationcontrolnotificationHalfprogress;

        /// <summary>
        /// deprecated - "your XP / progress is zero"
        /// </summary>
        public const Native.EDurationControlNotification EdurationcontrolnotificationNoprogress = EDurationControlNotification.EdurationcontrolnotificationNoprogress;

        /// <summary>
        /// allowed 3h time since 5h gap/break has elapsed, game should exit - steam will terminate the game soon
        /// </summary>
        public const Native.EDurationControlNotification EdurationcontrolnotificationExitsoon3h = EDurationControlNotification.EdurationcontrolnotificationExitsoon3h;

        /// <summary>
        /// allowed 5h time in calendar day has elapsed, game should exit - steam will terminate the game soon
        /// </summary>
        public const Native.EDurationControlNotification EdurationcontrolnotificationExitsoon5h = EDurationControlNotification.EdurationcontrolnotificationExitsoon5h;

        /// <summary>
        /// game running after day period, game should exit - steam will terminate the game soon
        /// </summary>
        public const Native.EDurationControlNotification EdurationcontrolnotificationExitsoonNight = EDurationControlNotification.EdurationcontrolnotificationExitsoonNight;

        /// <summary>
        /// Specifies a game's online state in relation to duration control
        /// </summary>
        public enum EDurationControlOnlineState : int
        {
            /// <summary>
            /// nil value
            /// </summary>
            EdurationcontrolonlinestateInvalid = unchecked((int)0),

            /// <summary>
            /// currently in offline play - single-player, offline co-op, etc.
            /// </summary>
            EdurationcontrolonlinestateOffline = unchecked((int)1),

            /// <summary>
            /// currently in online play
            /// </summary>
            EdurationcontrolonlinestateOnline = unchecked((int)2),

            /// <summary>
            /// currently in online play and requests not to be interrupted
            /// </summary>
            EdurationcontrolonlinestateOnlinehighpri = unchecked((int)3),
        }

        /// <summary>
        /// nil value
        /// </summary>
        public const Native.EDurationControlOnlineState EdurationcontrolonlinestateInvalid = EDurationControlOnlineState.EdurationcontrolonlinestateInvalid;

        /// <summary>
        /// currently in offline play - single-player, offline co-op, etc.
        /// </summary>
        public const Native.EDurationControlOnlineState EdurationcontrolonlinestateOffline = EDurationControlOnlineState.EdurationcontrolonlinestateOffline;

        /// <summary>
        /// currently in online play
        /// </summary>
        public const Native.EDurationControlOnlineState EdurationcontrolonlinestateOnline = EDurationControlOnlineState.EdurationcontrolonlinestateOnline;

        /// <summary>
        /// currently in online play and requests not to be interrupted
        /// </summary>
        public const Native.EDurationControlOnlineState EdurationcontrolonlinestateOnlinehighpri = EDurationControlOnlineState.EdurationcontrolonlinestateOnlinehighpri;

        public enum EGameSearchErrorCode_t : int
        {
            EgamesearcherrorcodeOk = unchecked((int)1),

            EgamesearcherrorcodeFailedSearchAlreadyInProgress = unchecked((int)2),

            EgamesearcherrorcodeFailedNoSearchInProgress = unchecked((int)3),

            /// <summary>
            /// if not the lobby leader can not call SearchForGameWithLobby
            /// </summary>
            EgamesearcherrorcodeFailedNotLobbyLeader = unchecked((int)4),

            /// <summary>
            /// no host is available that matches those search params
            /// </summary>
            EgamesearcherrorcodeFailedNoHostAvailable = unchecked((int)5),

            /// <summary>
            /// search params are invalid
            /// </summary>
            EgamesearcherrorcodeFailedSearchParamsInvalid = unchecked((int)6),

            /// <summary>
            /// offline, could not communicate with server
            /// </summary>
            EgamesearcherrorcodeFailedOffline = unchecked((int)7),

            /// <summary>
            /// either the user or the application does not have priveledges to do this
            /// </summary>
            EgamesearcherrorcodeFailedNotauthorized = unchecked((int)8),

            /// <summary>
            /// unknown error
            /// </summary>
            EgamesearcherrorcodeFailedUnknownError = unchecked((int)9),
        }

        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeOk = EGameSearchErrorCode_t.EgamesearcherrorcodeOk;

        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeFailedSearchAlreadyInProgress = EGameSearchErrorCode_t.EgamesearcherrorcodeFailedSearchAlreadyInProgress;

        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeFailedNoSearchInProgress = EGameSearchErrorCode_t.EgamesearcherrorcodeFailedNoSearchInProgress;

        /// <summary>
        /// if not the lobby leader can not call SearchForGameWithLobby
        /// </summary>
        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeFailedNotLobbyLeader = EGameSearchErrorCode_t.EgamesearcherrorcodeFailedNotLobbyLeader;

        /// <summary>
        /// no host is available that matches those search params
        /// </summary>
        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeFailedNoHostAvailable = EGameSearchErrorCode_t.EgamesearcherrorcodeFailedNoHostAvailable;

        /// <summary>
        /// search params are invalid
        /// </summary>
        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeFailedSearchParamsInvalid = EGameSearchErrorCode_t.EgamesearcherrorcodeFailedSearchParamsInvalid;

        /// <summary>
        /// offline, could not communicate with server
        /// </summary>
        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeFailedOffline = EGameSearchErrorCode_t.EgamesearcherrorcodeFailedOffline;

        /// <summary>
        /// either the user or the application does not have priveledges to do this
        /// </summary>
        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeFailedNotauthorized = EGameSearchErrorCode_t.EgamesearcherrorcodeFailedNotauthorized;

        /// <summary>
        /// unknown error
        /// </summary>
        public const Native.EGameSearchErrorCode_t EgamesearcherrorcodeFailedUnknownError = EGameSearchErrorCode_t.EgamesearcherrorcodeFailedUnknownError;

        public enum EPlayerResult_t : int
        {
            /// <summary>
            /// failed to connect after confirming
            /// </summary>
            Eplayerresultfailedtoconnect = unchecked((int)1),

            /// <summary>
            /// quit game without completing it
            /// </summary>
            Eplayerresultabandoned = unchecked((int)2),

            /// <summary>
            /// kicked by other players/moderator/server rules
            /// </summary>
            Eplayerresultkicked = unchecked((int)3),

            /// <summary>
            /// player stayed to end but game did not conclude successfully ( nofault to player )
            /// </summary>
            Eplayerresultincomplete = unchecked((int)4),

            /// <summary>
            /// player completed game
            /// </summary>
            Eplayerresultcompleted = unchecked((int)5),
        }

        /// <summary>
        /// failed to connect after confirming
        /// </summary>
        public const Native.EPlayerResult_t Eplayerresultfailedtoconnect = EPlayerResult_t.Eplayerresultfailedtoconnect;

        /// <summary>
        /// quit game without completing it
        /// </summary>
        public const Native.EPlayerResult_t Eplayerresultabandoned = EPlayerResult_t.Eplayerresultabandoned;

        /// <summary>
        /// kicked by other players/moderator/server rules
        /// </summary>
        public const Native.EPlayerResult_t Eplayerresultkicked = EPlayerResult_t.Eplayerresultkicked;

        /// <summary>
        /// player stayed to end but game did not conclude successfully ( nofault to player )
        /// </summary>
        public const Native.EPlayerResult_t Eplayerresultincomplete = EPlayerResult_t.Eplayerresultincomplete;

        /// <summary>
        /// player completed game
        /// </summary>
        public const Native.EPlayerResult_t Eplayerresultcompleted = EPlayerResult_t.Eplayerresultcompleted;

        public enum ESteamIPv6ConnectivityProtocol : int
        {
            Esteamipv6connectivityprotocolInvalid = unchecked((int)0),

            /// <summary>
            /// because a proxy may make this different than other protocols
            /// </summary>
            Esteamipv6connectivityprotocolHttp = unchecked((int)1),

            /// <summary>
            /// test UDP connectivity. Uses a port that is commonly needed for other Steam stuff. If UDP works, TCP probably works.
            /// </summary>
            Esteamipv6connectivityprotocolUdp = unchecked((int)2),
        }

        public const Native.ESteamIPv6ConnectivityProtocol Esteamipv6connectivityprotocolInvalid = ESteamIPv6ConnectivityProtocol.Esteamipv6connectivityprotocolInvalid;

        /// <summary>
        /// because a proxy may make this different than other protocols
        /// </summary>
        public const Native.ESteamIPv6ConnectivityProtocol Esteamipv6connectivityprotocolHttp = ESteamIPv6ConnectivityProtocol.Esteamipv6connectivityprotocolHttp;

        /// <summary>
        /// test UDP connectivity. Uses a port that is commonly needed for other Steam stuff. If UDP works, TCP probably works.
        /// </summary>
        public const Native.ESteamIPv6ConnectivityProtocol Esteamipv6connectivityprotocolUdp = ESteamIPv6ConnectivityProtocol.Esteamipv6connectivityprotocolUdp;

        /// <summary>
        /// For the above transport protocol, what do we think the local machine's connectivity to the internet over ipv6 is like
        /// </summary>
        public enum ESteamIPv6ConnectivityState : int
        {
            /// <summary>
            /// We haven't run a test yet
            /// </summary>
            Esteamipv6connectivitystateUnknown = unchecked((int)0),

            /// <summary>
            /// We have recently been able to make a request on ipv6 for the given protocol
            /// </summary>
            Esteamipv6connectivitystateGood = unchecked((int)1),

            /// <summary>
            /// We failed to make a request, either because this machine has no ipv6 address assigned, or it has no upstream connectivity
            /// </summary>
            Esteamipv6connectivitystateBad = unchecked((int)2),
        }

        /// <summary>
        /// We haven't run a test yet
        /// </summary>
        public const Native.ESteamIPv6ConnectivityState Esteamipv6connectivitystateUnknown = ESteamIPv6ConnectivityState.Esteamipv6connectivitystateUnknown;

        /// <summary>
        /// We have recently been able to make a request on ipv6 for the given protocol
        /// </summary>
        public const Native.ESteamIPv6ConnectivityState Esteamipv6connectivitystateGood = ESteamIPv6ConnectivityState.Esteamipv6connectivitystateGood;

        /// <summary>
        /// We failed to make a request, either because this machine has no ipv6 address assigned, or it has no upstream connectivity
        /// </summary>
        public const Native.ESteamIPv6ConnectivityState Esteamipv6connectivitystateBad = ESteamIPv6ConnectivityState.Esteamipv6connectivitystateBad;

        /// <summary>
        /// Different methods of describing the identity of a network host
        /// </summary>
        public enum ESteamNetworkingIdentityType : int
        {
            /// <summary>
            /// Dummy/empty/invalid.
            /// Please note that if we parse a string that we don't recognize
            /// but that appears reasonable, we will NOT use this type.  Instead
            /// we'll use k_ESteamNetworkingIdentityType_UnknownType.
            /// </summary>
            EsteamnetworkingidentitytypeInvalid = unchecked((int)0),

            /// <summary>
            /// 64-bit CSteamID
            /// </summary>
            EsteamnetworkingidentitytypeSteamid = unchecked((int)16),

            /// <summary>
            /// Use their IP address (and port) as their "identity".
            /// These types of identities are always unauthenticated.
            /// They are useful for porting plain sockets code, and other
            /// situations where you don't care about authentication.  In this
            /// case, the local identity will be "localhost",
            /// and the remote address will be their network address.
            /// </summary>
            /// <remarks>
            /// We use the same type for either IPv4 or IPv6, and
            /// the address is always store as IPv6.  We use IPv4
            /// mapped addresses to handle IPv4.
            /// </remarks>
            EsteamnetworkingidentitytypeIpaddress = unchecked((int)1),

            /// <summary>
            /// Generic string/binary blobs.  It's up to your app to interpret this.
            /// This library can tell you if the remote host presented a certificate
            /// signed by somebody you have chosen to trust, with this identity on it.
            /// It's up to you to ultimately decide what this identity means.
            /// </summary>
            EsteamnetworkingidentitytypeGenericstring = unchecked((int)2),

            /// <summary>
            /// Generic string/binary blobs.  It's up to your app to interpret this.
            /// This library can tell you if the remote host presented a certificate
            /// signed by somebody you have chosen to trust, with this identity on it.
            /// It's up to you to ultimately decide what this identity means.
            /// </summary>
            EsteamnetworkingidentitytypeGenericbytes = unchecked((int)3),

            /// <summary>
            /// This identity type is used when we parse a string that looks like is a
            /// valid identity, just of a kind that we don't recognize.  In this case, we
            /// can often still communicate with the peer!  Allowing such identities
            /// for types we do not recognize useful is very useful for forward
            /// compatibility.
            /// </summary>
            EsteamnetworkingidentitytypeUnknowntype = unchecked((int)4),

            /// <summary>
            /// Make sure this enum is stored in an int.
            /// </summary>
            EsteamnetworkingidentitytypeForce32bit = unchecked((int)0x7fffffff),
        }

        /// <summary>
        /// Dummy/empty/invalid.
        /// Please note that if we parse a string that we don't recognize
        /// but that appears reasonable, we will NOT use this type.  Instead
        /// we'll use k_ESteamNetworkingIdentityType_UnknownType.
        /// </summary>
        public const Native.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeInvalid = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeInvalid;

        /// <summary>
        /// 64-bit CSteamID
        /// </summary>
        public const Native.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeSteamid = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeSteamid;

        /// <summary>
        /// Use their IP address (and port) as their "identity".
        /// These types of identities are always unauthenticated.
        /// They are useful for porting plain sockets code, and other
        /// situations where you don't care about authentication.  In this
        /// case, the local identity will be "localhost",
        /// and the remote address will be their network address.
        /// </summary>
        /// <remarks>
        /// We use the same type for either IPv4 or IPv6, and
        /// the address is always store as IPv6.  We use IPv4
        /// mapped addresses to handle IPv4.
        /// </remarks>
        public const Native.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeIpaddress = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeIpaddress;

        /// <summary>
        /// Generic string/binary blobs.  It's up to your app to interpret this.
        /// This library can tell you if the remote host presented a certificate
        /// signed by somebody you have chosen to trust, with this identity on it.
        /// It's up to you to ultimately decide what this identity means.
        /// </summary>
        public const Native.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeGenericstring = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeGenericstring;

        /// <summary>
        /// Generic string/binary blobs.  It's up to your app to interpret this.
        /// This library can tell you if the remote host presented a certificate
        /// signed by somebody you have chosen to trust, with this identity on it.
        /// It's up to you to ultimately decide what this identity means.
        /// </summary>
        public const Native.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeGenericbytes = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeGenericbytes;

        /// <summary>
        /// This identity type is used when we parse a string that looks like is a
        /// valid identity, just of a kind that we don't recognize.  In this case, we
        /// can often still communicate with the peer!  Allowing such identities
        /// for types we do not recognize useful is very useful for forward
        /// compatibility.
        /// </summary>
        public const Native.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeUnknowntype = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeUnknowntype;

        /// <summary>
        /// Make sure this enum is stored in an int.
        /// </summary>
        public const Native.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeForce32bit = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeForce32bit;

        /// <summary>
        /// "Fake IPs" are assigned to hosts, to make it easier to interface with
        /// older code that assumed all hosts will have an IPv4 address
        /// </summary>
        public enum ESteamNetworkingFakeIPType : int
        {
            /// <summary>
            /// Error, argument was not even an IP address, etc.
            /// </summary>
            EsteamnetworkingfakeiptypeInvalid,

            /// <summary>
            /// Argument was a valid IP, but was not from the reserved "fake" range
            /// </summary>
            EsteamnetworkingfakeiptypeNotfake,

            /// <summary>
            /// Globally unique (for a given app) IPv4 address.  Address space managed by Steam
            /// </summary>
            EsteamnetworkingfakeiptypeGlobalipv4,

            /// <summary>
            /// Locally unique IPv4 address.  Address space managed by the local process.  For internal use only; should not be shared!
            /// </summary>
            EsteamnetworkingfakeiptypeLocalipv4,

            EsteamnetworkingfakeiptypeForce32bit = unchecked((int)0x7fffffff),
        }

        /// <summary>
        /// Error, argument was not even an IP address, etc.
        /// </summary>
        public const Native.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeInvalid = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeInvalid;

        /// <summary>
        /// Argument was a valid IP, but was not from the reserved "fake" range
        /// </summary>
        public const Native.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeNotfake = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeNotfake;

        /// <summary>
        /// Globally unique (for a given app) IPv4 address.  Address space managed by Steam
        /// </summary>
        public const Native.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeGlobalipv4 = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeGlobalipv4;

        /// <summary>
        /// Locally unique IPv4 address.  Address space managed by the local process.  For internal use only; should not be shared!
        /// </summary>
        public const Native.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeLocalipv4 = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeLocalipv4;

        public const Native.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeForce32bit = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeForce32bit;

        /// <summary>
        /// High level connection status
        /// </summary>
        public enum ESteamNetworkingConnectionState : int
        {
            /// <summary>
            /// Dummy value used to indicate an error condition in the API.
            /// Specified connection doesn't exist or has already been closed.
            /// </summary>
            EsteamnetworkingconnectionstateNone = unchecked((int)0),

            /// <summary>
            /// We are trying to establish whether peers can talk to each other,
            /// whether they WANT to talk to each other, perform basic auth,
            /// and exchange crypt keys.
            /// </summary>
            /// <remarks>
            /// - For connections on the "client" side (initiated locally):
            /// We're in the process of trying to establish a connection.
            /// Depending on the connection type, we might not know who they are.
            /// Note that it is not possible to tell if we are waiting on the
            /// network to complete handshake packets, or for the application layer
            /// to accept the connection.- For connections on the "server" side (accepted through listen socket):
            /// We have completed some basic handshake and the client has presented
            /// some proof of identity.  The connection is ready to be accepted
            /// using AcceptConnection().In either case, any unreliable packets sent now are almost certain
            /// to be dropped.  Attempts to receive packets are guaranteed to fail.
            /// You may send messages if the send mode allows for them to be queued.
            /// but if you close the connection before the connection is actually
            /// established, any queued messages will be discarded immediately.
            /// (We will not attempt to flush the queue and confirm delivery to the
            /// remote host, which ordinarily happens when a connection is closed.)
            /// </remarks>
            EsteamnetworkingconnectionstateConnecting = unchecked((int)1),

            /// <summary>
            /// Some connection types use a back channel or trusted 3rd party
            /// for earliest communication.  If the server accepts the connection,
            /// then these connections switch into the rendezvous state.  During this
            /// state, we still have not yet established an end-to-end route (through
            /// the relay network), and so if you send any messages unreliable, they
            /// are going to be discarded.
            /// </summary>
            EsteamnetworkingconnectionstateFindingroute = unchecked((int)2),

            /// <summary>
            /// We've received communications from our peer (and we know
            /// who they are) and are all good.  If you close the connection now,
            /// we will make our best effort to flush out any reliable sent data that
            /// has not been acknowledged by the peer.  (But note that this happens
            /// from within the application process, so unlike a TCP connection, you are
            /// not totally handing it off to the operating system to deal with it.)
            /// </summary>
            EsteamnetworkingconnectionstateConnected = unchecked((int)3),

            /// <summary>
            /// Connection has been closed by our peer, but not closed locally.
            /// The connection still exists from an API perspective.  You must close the
            /// handle to free up resources.  If there are any messages in the inbound queue,
            /// you may retrieve them.  Otherwise, nothing may be done with the connection
            /// except to close it.
            /// </summary>
            /// <remarks>
            /// This stats is similar to CLOSE_WAIT in the TCP state machine.
            /// </remarks>
            EsteamnetworkingconnectionstateClosedbypeer = unchecked((int)4),

            /// <summary>
            /// A disruption in the connection has been detected locally.  (E.g. timeout,
            /// local internet connection disrupted, etc.)
            /// </summary>
            /// <remarks>
            /// The connection still exists from an API perspective.  You must close the
            /// handle to free up resources.Attempts to send further messages will fail.  Any remaining received messages
            /// in the queue are available.
            /// </remarks>
            EsteamnetworkingconnectionstateProblemdetectedlocally = unchecked((int)5),

            /// <summary>
            /// We've disconnected on our side, and from an API perspective the connection is closed.
            /// No more data may be sent or received.  All reliable data has been flushed, or else
            /// we've given up and discarded it.  We do not yet know for sure that the peer knows
            /// the connection has been closed, however, so we're just hanging around so that if we do
            /// get a packet from them, we can send them the appropriate packets so that they can
            /// know why the connection was closed (and not have to rely on a timeout, which makes
            /// it appear as if something is wrong).
            /// </summary>
            EsteamnetworkingconnectionstateFinwait = unchecked((int)-1),

            /// <summary>
            /// We've disconnected on our side, and from an API perspective the connection is closed.
            /// No more data may be sent or received.  From a network perspective, however, on the wire,
            /// we have not yet given any indication to the peer that the connection is closed.
            /// We are in the process of flushing out the last bit of reliable data.  Once that is done,
            /// we will inform the peer that the connection has been closed, and transition to the
            /// FinWait state.
            /// </summary>
            /// <remarks>
            /// Note that no indication is given to the remote host that we have closed the connection,
            /// until the data has been flushed.  If the remote host attempts to send us data, we will
            /// do whatever is necessary to keep the connection alive until it can be closed properly.
            /// But in fact the data will be discarded, since there is no way for the application to
            /// read it back.  Typically this is not a problem, as application protocols that utilize
            /// the lingering functionality are designed for the remote host to wait for the response
            /// before sending any more data.
            /// </remarks>
            EsteamnetworkingconnectionstateLinger = unchecked((int)-2),

            /// <summary>
            /// Connection is completely inactive and ready to be destroyed
            /// </summary>
            EsteamnetworkingconnectionstateDead = unchecked((int)-3),

            /// <summary>
            /// Connection is completely inactive and ready to be destroyed
            /// </summary>
            EsteamnetworkingconnectionstateForce32bit = unchecked((int)0x7fffffff),
        }

        /// <summary>
        /// Dummy value used to indicate an error condition in the API.
        /// Specified connection doesn't exist or has already been closed.
        /// </summary>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateNone = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateNone;

        /// <summary>
        /// We are trying to establish whether peers can talk to each other,
        /// whether they WANT to talk to each other, perform basic auth,
        /// and exchange crypt keys.
        /// </summary>
        /// <remarks>
        /// - For connections on the "client" side (initiated locally):
        /// We're in the process of trying to establish a connection.
        /// Depending on the connection type, we might not know who they are.
        /// Note that it is not possible to tell if we are waiting on the
        /// network to complete handshake packets, or for the application layer
        /// to accept the connection.- For connections on the "server" side (accepted through listen socket):
        /// We have completed some basic handshake and the client has presented
        /// some proof of identity.  The connection is ready to be accepted
        /// using AcceptConnection().In either case, any unreliable packets sent now are almost certain
        /// to be dropped.  Attempts to receive packets are guaranteed to fail.
        /// You may send messages if the send mode allows for them to be queued.
        /// but if you close the connection before the connection is actually
        /// established, any queued messages will be discarded immediately.
        /// (We will not attempt to flush the queue and confirm delivery to the
        /// remote host, which ordinarily happens when a connection is closed.)
        /// </remarks>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateConnecting = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateConnecting;

        /// <summary>
        /// Some connection types use a back channel or trusted 3rd party
        /// for earliest communication.  If the server accepts the connection,
        /// then these connections switch into the rendezvous state.  During this
        /// state, we still have not yet established an end-to-end route (through
        /// the relay network), and so if you send any messages unreliable, they
        /// are going to be discarded.
        /// </summary>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateFindingroute = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateFindingroute;

        /// <summary>
        /// We've received communications from our peer (and we know
        /// who they are) and are all good.  If you close the connection now,
        /// we will make our best effort to flush out any reliable sent data that
        /// has not been acknowledged by the peer.  (But note that this happens
        /// from within the application process, so unlike a TCP connection, you are
        /// not totally handing it off to the operating system to deal with it.)
        /// </summary>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateConnected = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateConnected;

        /// <summary>
        /// Connection has been closed by our peer, but not closed locally.
        /// The connection still exists from an API perspective.  You must close the
        /// handle to free up resources.  If there are any messages in the inbound queue,
        /// you may retrieve them.  Otherwise, nothing may be done with the connection
        /// except to close it.
        /// </summary>
        /// <remarks>
        /// This stats is similar to CLOSE_WAIT in the TCP state machine.
        /// </remarks>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateClosedbypeer = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateClosedbypeer;

        /// <summary>
        /// A disruption in the connection has been detected locally.  (E.g. timeout,
        /// local internet connection disrupted, etc.)
        /// </summary>
        /// <remarks>
        /// The connection still exists from an API perspective.  You must close the
        /// handle to free up resources.Attempts to send further messages will fail.  Any remaining received messages
        /// in the queue are available.
        /// </remarks>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateProblemdetectedlocally = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateProblemdetectedlocally;

        /// <summary>
        /// We've disconnected on our side, and from an API perspective the connection is closed.
        /// No more data may be sent or received.  All reliable data has been flushed, or else
        /// we've given up and discarded it.  We do not yet know for sure that the peer knows
        /// the connection has been closed, however, so we're just hanging around so that if we do
        /// get a packet from them, we can send them the appropriate packets so that they can
        /// know why the connection was closed (and not have to rely on a timeout, which makes
        /// it appear as if something is wrong).
        /// </summary>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateFinwait = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateFinwait;

        /// <summary>
        /// We've disconnected on our side, and from an API perspective the connection is closed.
        /// No more data may be sent or received.  From a network perspective, however, on the wire,
        /// we have not yet given any indication to the peer that the connection is closed.
        /// We are in the process of flushing out the last bit of reliable data.  Once that is done,
        /// we will inform the peer that the connection has been closed, and transition to the
        /// FinWait state.
        /// </summary>
        /// <remarks>
        /// Note that no indication is given to the remote host that we have closed the connection,
        /// until the data has been flushed.  If the remote host attempts to send us data, we will
        /// do whatever is necessary to keep the connection alive until it can be closed properly.
        /// But in fact the data will be discarded, since there is no way for the application to
        /// read it back.  Typically this is not a problem, as application protocols that utilize
        /// the lingering functionality are designed for the remote host to wait for the response
        /// before sending any more data.
        /// </remarks>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateLinger = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateLinger;

        /// <summary>
        /// Connection is completely inactive and ready to be destroyed
        /// </summary>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateDead = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateDead;

        /// <summary>
        /// Connection is completely inactive and ready to be destroyed
        /// </summary>
        public const Native.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateForce32bit = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateForce32bit;

        /// <summary>
        /// Describe the status of a particular network resource
        /// </summary>
        public enum ESteamNetworkingAvailability : int
        {
            /// <summary>
            /// A dependent resource is missing, so this service is unavailable.  (E.g. we cannot talk to routers because Internet is down or we don't have the network config.)
            /// </summary>
            EsteamnetworkingavailabilityCannottry = unchecked((int)-102),

            /// <summary>
            /// We have tried for enough time that we would expect to have been successful by now.  We have never been successful
            /// </summary>
            EsteamnetworkingavailabilityFailed = unchecked((int)-101),

            /// <summary>
            /// We tried and were successful at one time, but now it looks like we have a problem
            /// </summary>
            EsteamnetworkingavailabilityPreviously = unchecked((int)-100),

            /// <summary>
            /// We previously failed and are currently retrying
            /// </summary>
            EsteamnetworkingavailabilityRetrying = unchecked((int)-10),

            /// <summary>
            /// We don't know because we haven't ever checked/tried
            /// </summary>
            EsteamnetworkingavailabilityNevertried = unchecked((int)1),

            /// <summary>
            /// We're waiting on a dependent resource to be acquired.  (E.g. we cannot obtain a cert until we are logged into Steam.  We cannot measure latency to relays until we have the network config.)
            /// </summary>
            EsteamnetworkingavailabilityWaiting = unchecked((int)2),

            /// <summary>
            /// We're actively trying now, but are not yet successful.
            /// </summary>
            EsteamnetworkingavailabilityAttempting = unchecked((int)3),

            /// <summary>
            /// Resource is online/available
            /// </summary>
            EsteamnetworkingavailabilityCurrent = unchecked((int)100),

            /// <summary>
            /// Internal dummy/sentinel, or value is not applicable in this context
            /// </summary>
            EsteamnetworkingavailabilityUnknown = unchecked((int)0),

            EsteamnetworkingavailabilityForce32bit = unchecked((int)0x7fffffff),
        }

        /// <summary>
        /// A dependent resource is missing, so this service is unavailable.  (E.g. we cannot talk to routers because Internet is down or we don't have the network config.)
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityCannottry = ESteamNetworkingAvailability.EsteamnetworkingavailabilityCannottry;

        /// <summary>
        /// We have tried for enough time that we would expect to have been successful by now.  We have never been successful
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityFailed = ESteamNetworkingAvailability.EsteamnetworkingavailabilityFailed;

        /// <summary>
        /// We tried and were successful at one time, but now it looks like we have a problem
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityPreviously = ESteamNetworkingAvailability.EsteamnetworkingavailabilityPreviously;

        /// <summary>
        /// We previously failed and are currently retrying
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityRetrying = ESteamNetworkingAvailability.EsteamnetworkingavailabilityRetrying;

        /// <summary>
        /// We don't know because we haven't ever checked/tried
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityNevertried = ESteamNetworkingAvailability.EsteamnetworkingavailabilityNevertried;

        /// <summary>
        /// We're waiting on a dependent resource to be acquired.  (E.g. we cannot obtain a cert until we are logged into Steam.  We cannot measure latency to relays until we have the network config.)
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityWaiting = ESteamNetworkingAvailability.EsteamnetworkingavailabilityWaiting;

        /// <summary>
        /// We're actively trying now, but are not yet successful.
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityAttempting = ESteamNetworkingAvailability.EsteamnetworkingavailabilityAttempting;

        /// <summary>
        /// Resource is online/available
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityCurrent = ESteamNetworkingAvailability.EsteamnetworkingavailabilityCurrent;

        /// <summary>
        /// Internal dummy/sentinel, or value is not applicable in this context
        /// </summary>
        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityUnknown = ESteamNetworkingAvailability.EsteamnetworkingavailabilityUnknown;

        public const Native.ESteamNetworkingAvailability EsteamnetworkingavailabilityForce32bit = ESteamNetworkingAvailability.EsteamnetworkingavailabilityForce32bit;

        /// <summary>
        /// Enumerate various causes of connection termination.  These are designed to work similar
        /// to HTTP error codes: the numeric range gives you a rough classification as to the source
        /// of the problem.
        /// </summary>
        public enum ESteamNetConnectionEnd : int
        {
            /// <summary>
            /// Invalid/sentinel value
            /// </summary>
            EsteamnetconnectionendInvalid = unchecked((int)0),

            /// <summary>
            /// 1xxx: Application ended the connection in a "usual" manner.
            /// E.g.: user intentionally disconnected from the server,
            /// gameplay ended normally, etc
            /// </summary>
            EsteamnetconnectionendAppMin = unchecked((int)1000),

            /// <summary>
            /// 1xxx: Application ended the connection in a "usual" manner.
            /// E.g.: user intentionally disconnected from the server,
            /// gameplay ended normally, etc
            /// </summary>
            EsteamnetconnectionendAppGeneric = unchecked((int)ESteamNetConnectionEnd.EsteamnetconnectionendAppMin),

            /// <summary>
            /// Use codes in this range for "normal" disconnection
            /// </summary>
            EsteamnetconnectionendAppMax = unchecked((int)1999),

            /// <summary>
            /// 2xxx: Application ended the connection in some sort of exceptional
            /// or unusual manner that might indicate a bug or configuration
            /// issue.
            /// </summary>
            EsteamnetconnectionendAppexceptionMin = unchecked((int)2000),

            /// <summary>
            /// 2xxx: Application ended the connection in some sort of exceptional
            /// or unusual manner that might indicate a bug or configuration
            /// issue.
            /// </summary>
            EsteamnetconnectionendAppexceptionGeneric = unchecked((int)ESteamNetConnectionEnd.EsteamnetconnectionendAppexceptionMin),

            /// <summary>
            /// Use codes in this range for "unusual" disconnection
            /// </summary>
            EsteamnetconnectionendAppexceptionMax = unchecked((int)2999),

            /// <summary>
            /// 3xxx: Connection failed or ended because of problem with the
            /// local host or their connection to the Internet.
            /// </summary>
            EsteamnetconnectionendLocalMin = unchecked((int)3000),

            /// <summary>
            /// You cannot do what you want to do because you're running in offline mode.
            /// </summary>
            EsteamnetconnectionendLocalOfflinemode = unchecked((int)3001),

            /// <summary>
            /// We're having trouble contacting many (perhaps all) relays.
            /// Since it's unlikely that they all went offline at once, the best
            /// explanation is that we have a problem on our end.  Note that we don't
            /// bother distinguishing between "many" and "all", because in practice,
            /// it takes time to detect a connection problem, and by the time
            /// the connection has timed out, we might not have been able to
            /// actively probe all of the relay clusters, even if we were able to
            /// contact them at one time.  So this code just means that:
            /// </summary>
            /// <remarks>
            /// * We don't have any recent successful communication with any relay.
            /// * We have evidence of recent failures to communicate with multiple relays.
            /// </remarks>
            EsteamnetconnectionendLocalManyrelayconnectivity = unchecked((int)3002),

            /// <summary>
            /// A hosted server is having trouble talking to the relay
            /// that the client was using, so the problem is most likely
            /// on our end
            /// </summary>
            EsteamnetconnectionendLocalHostedserverprimaryrelay = unchecked((int)3003),

            /// <summary>
            /// We're not able to get the SDR network config.  This is
            /// *almost* always a local issue, since the network config
            /// comes from the CDN, which is pretty darn reliable.
            /// </summary>
            EsteamnetconnectionendLocalNetworkconfig = unchecked((int)3004),

            /// <summary>
            /// Steam rejected our request because we don't have rights
            /// to do this.
            /// </summary>
            EsteamnetconnectionendLocalRights = unchecked((int)3005),

            /// <summary>
            /// ICE P2P rendezvous failed because we were not able to
            /// determine our "public" address (e.g. reflexive address via STUN)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendLocalP2pIceNopublicaddresses = unchecked((int)3006),

            /// <summary>
            /// ICE P2P rendezvous failed because we were not able to
            /// determine our "public" address (e.g. reflexive address via STUN)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendLocalMax = unchecked((int)3999),

            /// <summary>
            /// 4xxx: Connection failed or ended, and it appears that the
            /// cause does NOT have to do with the local host or their
            /// connection to the Internet.  It could be caused by the
            /// remote host, or it could be somewhere in between.
            /// </summary>
            EsteamnetconnectionendRemoteMin = unchecked((int)4000),

            /// <summary>
            /// The connection was lost, and as far as we can tell our connection
            /// to relevant services (relays) has not been disrupted.  This doesn't
            /// mean that the problem is "their fault", it just means that it doesn't
            /// appear that we are having network issues on our end.
            /// </summary>
            EsteamnetconnectionendRemoteTimeout = unchecked((int)4001),

            /// <summary>
            /// Something was invalid with the cert or crypt handshake
            /// info you gave me, I don't understand or like your key types,
            /// etc.
            /// </summary>
            EsteamnetconnectionendRemoteBadcrypt = unchecked((int)4002),

            /// <summary>
            /// You presented me with a cert that was I was able to parse
            /// and *technically* we could use encrypted communication.
            /// But there was a problem that prevents me from checking your identity
            /// or ensuring that somebody int he middle can't observe our communication.
            /// E.g.: - the CA key was missing (and I don't accept unsigned certs)
            /// - The CA key isn't one that I trust,
            /// - The cert doesn't was appropriately restricted by app, user, time, data center, etc.
            /// - The cert wasn't issued to you.
            /// - etc
            /// </summary>
            EsteamnetconnectionendRemoteBadcert = unchecked((int)4003),

            /// <summary>
            /// Something wrong with the protocol version you are using.
            /// (Probably the code you are running is too old.)
            /// </summary>
            EsteamnetconnectionendRemoteBadprotocolversion = unchecked((int)4006),

            /// <summary>
            /// NAT punch failed failed because we never received any public
            /// addresses from the remote host.  (But we did receive some
            /// signals form them.)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendRemoteP2pIceNopublicaddresses = unchecked((int)4007),

            /// <summary>
            /// NAT punch failed failed because we never received any public
            /// addresses from the remote host.  (But we did receive some
            /// signals form them.)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendRemoteMax = unchecked((int)4999),

            /// <summary>
            /// 5xxx: Connection failed for some other reason.
            /// </summary>
            EsteamnetconnectionendMiscMin = unchecked((int)5000),

            /// <summary>
            /// A failure that isn't necessarily the result of a software bug,
            /// but that should happen rarely enough that it isn't worth specifically
            /// writing UI or making a localized message for.
            /// The debug string should contain further details.
            /// </summary>
            EsteamnetconnectionendMiscGeneric = unchecked((int)5001),

            /// <summary>
            /// Generic failure that is most likely a software bug.
            /// </summary>
            EsteamnetconnectionendMiscInternalerror = unchecked((int)5002),

            /// <summary>
            /// The connection to the remote host timed out, but we
            /// don't know if the problem is on our end, in the middle,
            /// or on their end.
            /// </summary>
            EsteamnetconnectionendMiscTimeout = unchecked((int)5003),

            /// <summary>
            /// There's some trouble talking to Steam.
            /// </summary>
            EsteamnetconnectionendMiscSteamconnectivity = unchecked((int)5005),

            /// <summary>
            /// A server in a dedicated hosting situation has no relay sessions
            /// active with which to talk back to a client.  (It's the client's
            /// job to open and maintain those sessions.)
            /// </summary>
            EsteamnetconnectionendMiscNorelaysessionstoclient = unchecked((int)5006),

            /// <summary>
            /// P2P rendezvous failed in a way that we don't have more specific
            /// information
            /// </summary>
            EsteamnetconnectionendMiscP2pRendezvous = unchecked((int)5008),

            /// <summary>
            /// NAT punch failed, probably due to NAT/firewall configuration.
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendMiscP2pNatFirewall = unchecked((int)5009),

            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendMiscPeersentnoconnection = unchecked((int)5010),

            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendMiscMax = unchecked((int)5999),

            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendForce32bit = unchecked((int)0x7fffffff),
        }

        /// <summary>
        /// Invalid/sentinel value
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendInvalid = ESteamNetConnectionEnd.EsteamnetconnectionendInvalid;

        /// <summary>
        /// 1xxx: Application ended the connection in a "usual" manner.
        /// E.g.: user intentionally disconnected from the server,
        /// gameplay ended normally, etc
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendAppMin = ESteamNetConnectionEnd.EsteamnetconnectionendAppMin;

        /// <summary>
        /// 1xxx: Application ended the connection in a "usual" manner.
        /// E.g.: user intentionally disconnected from the server,
        /// gameplay ended normally, etc
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendAppGeneric = ESteamNetConnectionEnd.EsteamnetconnectionendAppGeneric;

        /// <summary>
        /// Use codes in this range for "normal" disconnection
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendAppMax = ESteamNetConnectionEnd.EsteamnetconnectionendAppMax;

        /// <summary>
        /// 2xxx: Application ended the connection in some sort of exceptional
        /// or unusual manner that might indicate a bug or configuration
        /// issue.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendAppexceptionMin = ESteamNetConnectionEnd.EsteamnetconnectionendAppexceptionMin;

        /// <summary>
        /// 2xxx: Application ended the connection in some sort of exceptional
        /// or unusual manner that might indicate a bug or configuration
        /// issue.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendAppexceptionGeneric = ESteamNetConnectionEnd.EsteamnetconnectionendAppexceptionGeneric;

        /// <summary>
        /// Use codes in this range for "unusual" disconnection
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendAppexceptionMax = ESteamNetConnectionEnd.EsteamnetconnectionendAppexceptionMax;

        /// <summary>
        /// 3xxx: Connection failed or ended because of problem with the
        /// local host or their connection to the Internet.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendLocalMin = ESteamNetConnectionEnd.EsteamnetconnectionendLocalMin;

        /// <summary>
        /// You cannot do what you want to do because you're running in offline mode.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendLocalOfflinemode = ESteamNetConnectionEnd.EsteamnetconnectionendLocalOfflinemode;

        /// <summary>
        /// We're having trouble contacting many (perhaps all) relays.
        /// Since it's unlikely that they all went offline at once, the best
        /// explanation is that we have a problem on our end.  Note that we don't
        /// bother distinguishing between "many" and "all", because in practice,
        /// it takes time to detect a connection problem, and by the time
        /// the connection has timed out, we might not have been able to
        /// actively probe all of the relay clusters, even if we were able to
        /// contact them at one time.  So this code just means that:
        /// </summary>
        /// <remarks>
        /// * We don't have any recent successful communication with any relay.
        /// * We have evidence of recent failures to communicate with multiple relays.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendLocalManyrelayconnectivity = ESteamNetConnectionEnd.EsteamnetconnectionendLocalManyrelayconnectivity;

        /// <summary>
        /// A hosted server is having trouble talking to the relay
        /// that the client was using, so the problem is most likely
        /// on our end
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendLocalHostedserverprimaryrelay = ESteamNetConnectionEnd.EsteamnetconnectionendLocalHostedserverprimaryrelay;

        /// <summary>
        /// We're not able to get the SDR network config.  This is
        /// *almost* always a local issue, since the network config
        /// comes from the CDN, which is pretty darn reliable.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendLocalNetworkconfig = ESteamNetConnectionEnd.EsteamnetconnectionendLocalNetworkconfig;

        /// <summary>
        /// Steam rejected our request because we don't have rights
        /// to do this.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendLocalRights = ESteamNetConnectionEnd.EsteamnetconnectionendLocalRights;

        /// <summary>
        /// ICE P2P rendezvous failed because we were not able to
        /// determine our "public" address (e.g. reflexive address via STUN)
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendLocalP2pIceNopublicaddresses = ESteamNetConnectionEnd.EsteamnetconnectionendLocalP2pIceNopublicaddresses;

        /// <summary>
        /// ICE P2P rendezvous failed because we were not able to
        /// determine our "public" address (e.g. reflexive address via STUN)
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendLocalMax = ESteamNetConnectionEnd.EsteamnetconnectionendLocalMax;

        /// <summary>
        /// 4xxx: Connection failed or ended, and it appears that the
        /// cause does NOT have to do with the local host or their
        /// connection to the Internet.  It could be caused by the
        /// remote host, or it could be somewhere in between.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendRemoteMin = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteMin;

        /// <summary>
        /// The connection was lost, and as far as we can tell our connection
        /// to relevant services (relays) has not been disrupted.  This doesn't
        /// mean that the problem is "their fault", it just means that it doesn't
        /// appear that we are having network issues on our end.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendRemoteTimeout = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteTimeout;

        /// <summary>
        /// Something was invalid with the cert or crypt handshake
        /// info you gave me, I don't understand or like your key types,
        /// etc.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendRemoteBadcrypt = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteBadcrypt;

        /// <summary>
        /// You presented me with a cert that was I was able to parse
        /// and *technically* we could use encrypted communication.
        /// But there was a problem that prevents me from checking your identity
        /// or ensuring that somebody int he middle can't observe our communication.
        /// E.g.: - the CA key was missing (and I don't accept unsigned certs)
        /// - The CA key isn't one that I trust,
        /// - The cert doesn't was appropriately restricted by app, user, time, data center, etc.
        /// - The cert wasn't issued to you.
        /// - etc
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendRemoteBadcert = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteBadcert;

        /// <summary>
        /// Something wrong with the protocol version you are using.
        /// (Probably the code you are running is too old.)
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendRemoteBadprotocolversion = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteBadprotocolversion;

        /// <summary>
        /// NAT punch failed failed because we never received any public
        /// addresses from the remote host.  (But we did receive some
        /// signals form them.)
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendRemoteP2pIceNopublicaddresses = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteP2pIceNopublicaddresses;

        /// <summary>
        /// NAT punch failed failed because we never received any public
        /// addresses from the remote host.  (But we did receive some
        /// signals form them.)
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendRemoteMax = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteMax;

        /// <summary>
        /// 5xxx: Connection failed for some other reason.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscMin = ESteamNetConnectionEnd.EsteamnetconnectionendMiscMin;

        /// <summary>
        /// A failure that isn't necessarily the result of a software bug,
        /// but that should happen rarely enough that it isn't worth specifically
        /// writing UI or making a localized message for.
        /// The debug string should contain further details.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscGeneric = ESteamNetConnectionEnd.EsteamnetconnectionendMiscGeneric;

        /// <summary>
        /// Generic failure that is most likely a software bug.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscInternalerror = ESteamNetConnectionEnd.EsteamnetconnectionendMiscInternalerror;

        /// <summary>
        /// The connection to the remote host timed out, but we
        /// don't know if the problem is on our end, in the middle,
        /// or on their end.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscTimeout = ESteamNetConnectionEnd.EsteamnetconnectionendMiscTimeout;

        /// <summary>
        /// There's some trouble talking to Steam.
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscSteamconnectivity = ESteamNetConnectionEnd.EsteamnetconnectionendMiscSteamconnectivity;

        /// <summary>
        /// A server in a dedicated hosting situation has no relay sessions
        /// active with which to talk back to a client.  (It's the client's
        /// job to open and maintain those sessions.)
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscNorelaysessionstoclient = ESteamNetConnectionEnd.EsteamnetconnectionendMiscNorelaysessionstoclient;

        /// <summary>
        /// P2P rendezvous failed in a way that we don't have more specific
        /// information
        /// </summary>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscP2pRendezvous = ESteamNetConnectionEnd.EsteamnetconnectionendMiscP2pRendezvous;

        /// <summary>
        /// NAT punch failed, probably due to NAT/firewall configuration.
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscP2pNatFirewall = ESteamNetConnectionEnd.EsteamnetconnectionendMiscP2pNatFirewall;

        /// <summary>
        /// Our peer replied that it has no record of the connection.
        /// This should not happen ordinarily, but can happen in a few
        /// exception cases:
        /// </summary>
        /// <remarks>
        /// - This is an old connection, and the peer has already cleaned
        /// up and forgotten about it.  (Perhaps it timed out and they
        /// closed it and were not able to communicate this to us.)
        /// - A bug or internal protocol error has caused us to try to
        /// talk to the peer about the connection before we received
        /// confirmation that the peer has accepted the connection.
        /// - The peer thinks that we have closed the connection for some
        /// reason (perhaps a bug), and believes that is it is
        /// acknowledging our closure.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscPeersentnoconnection = ESteamNetConnectionEnd.EsteamnetconnectionendMiscPeersentnoconnection;

        /// <summary>
        /// Our peer replied that it has no record of the connection.
        /// This should not happen ordinarily, but can happen in a few
        /// exception cases:
        /// </summary>
        /// <remarks>
        /// - This is an old connection, and the peer has already cleaned
        /// up and forgotten about it.  (Perhaps it timed out and they
        /// closed it and were not able to communicate this to us.)
        /// - A bug or internal protocol error has caused us to try to
        /// talk to the peer about the connection before we received
        /// confirmation that the peer has accepted the connection.
        /// - The peer thinks that we have closed the connection for some
        /// reason (perhaps a bug), and believes that is it is
        /// acknowledging our closure.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendMiscMax = ESteamNetConnectionEnd.EsteamnetconnectionendMiscMax;

        /// <summary>
        /// Our peer replied that it has no record of the connection.
        /// This should not happen ordinarily, but can happen in a few
        /// exception cases:
        /// </summary>
        /// <remarks>
        /// - This is an old connection, and the peer has already cleaned
        /// up and forgotten about it.  (Perhaps it timed out and they
        /// closed it and were not able to communicate this to us.)
        /// - A bug or internal protocol error has caused us to try to
        /// talk to the peer about the connection before we received
        /// confirmation that the peer has accepted the connection.
        /// - The peer thinks that we have closed the connection for some
        /// reason (perhaps a bug), and believes that is it is
        /// acknowledging our closure.
        /// </remarks>
        public const Native.ESteamNetConnectionEnd EsteamnetconnectionendForce32bit = ESteamNetConnectionEnd.EsteamnetconnectionendForce32bit;

        /// <summary>
        /// Configuration values can be applied to different types of objects.
        /// </summary>
        public enum ESteamNetworkingConfigScope : int
        {
            /// <summary>
            /// Get/set global option, or defaults.  Even options that apply to more specific scopes
            /// have global scope, and you may be able to just change the global defaults.  If you
            /// need different settings per connection (for example), then you will need to set those
            /// options at the more specific scope.
            /// </summary>
            EsteamnetworkingconfigGlobal = unchecked((int)1),

            /// <summary>
            /// Some options are specific to a particular interface.  Note that all connection
            /// and listen socket settings can also be set at the interface level, and they will
            /// apply to objects created through those interfaces.
            /// </summary>
            EsteamnetworkingconfigSocketsinterface = unchecked((int)2),

            /// <summary>
            /// Options for a listen socket.  Listen socket options can be set at the interface layer,
            /// if  you have multiple listen sockets and they all use the same options.
            /// You can also set connection options on a listen socket, and they set the defaults
            /// for all connections accepted through this listen socket.  (They will be used if you don't
            /// set a connection option.)
            /// </summary>
            EsteamnetworkingconfigListensocket = unchecked((int)3),

            /// <summary>
            /// Options for a specific connection.
            /// </summary>
            EsteamnetworkingconfigConnection = unchecked((int)4),

            /// <summary>
            /// Options for a specific connection.
            /// </summary>
            EsteamnetworkingconfigscopeForce32bit = unchecked((int)0x7fffffff),
        }

        /// <summary>
        /// Get/set global option, or defaults.  Even options that apply to more specific scopes
        /// have global scope, and you may be able to just change the global defaults.  If you
        /// need different settings per connection (for example), then you will need to set those
        /// options at the more specific scope.
        /// </summary>
        public const Native.ESteamNetworkingConfigScope EsteamnetworkingconfigGlobal = ESteamNetworkingConfigScope.EsteamnetworkingconfigGlobal;

        /// <summary>
        /// Some options are specific to a particular interface.  Note that all connection
        /// and listen socket settings can also be set at the interface level, and they will
        /// apply to objects created through those interfaces.
        /// </summary>
        public const Native.ESteamNetworkingConfigScope EsteamnetworkingconfigSocketsinterface = ESteamNetworkingConfigScope.EsteamnetworkingconfigSocketsinterface;

        /// <summary>
        /// Options for a listen socket.  Listen socket options can be set at the interface layer,
        /// if  you have multiple listen sockets and they all use the same options.
        /// You can also set connection options on a listen socket, and they set the defaults
        /// for all connections accepted through this listen socket.  (They will be used if you don't
        /// set a connection option.)
        /// </summary>
        public const Native.ESteamNetworkingConfigScope EsteamnetworkingconfigListensocket = ESteamNetworkingConfigScope.EsteamnetworkingconfigListensocket;

        /// <summary>
        /// Options for a specific connection.
        /// </summary>
        public const Native.ESteamNetworkingConfigScope EsteamnetworkingconfigConnection = ESteamNetworkingConfigScope.EsteamnetworkingconfigConnection;

        /// <summary>
        /// Options for a specific connection.
        /// </summary>
        public const Native.ESteamNetworkingConfigScope EsteamnetworkingconfigscopeForce32bit = ESteamNetworkingConfigScope.EsteamnetworkingconfigscopeForce32bit;

        /// <summary>
        /// Different configuration values have different data types
        /// </summary>
        public enum ESteamNetworkingConfigDataType : int
        {
            EsteamnetworkingconfigInt32 = unchecked((int)1),

            EsteamnetworkingconfigInt64 = unchecked((int)2),

            EsteamnetworkingconfigFloat = unchecked((int)3),

            EsteamnetworkingconfigString = unchecked((int)4),

            EsteamnetworkingconfigPtr = unchecked((int)5),

            EsteamnetworkingconfigdatatypeForce32bit = unchecked((int)0x7fffffff),
        }

        public const Native.ESteamNetworkingConfigDataType EsteamnetworkingconfigInt32 = ESteamNetworkingConfigDataType.EsteamnetworkingconfigInt32;

        public const Native.ESteamNetworkingConfigDataType EsteamnetworkingconfigInt64 = ESteamNetworkingConfigDataType.EsteamnetworkingconfigInt64;

        public const Native.ESteamNetworkingConfigDataType EsteamnetworkingconfigFloat = ESteamNetworkingConfigDataType.EsteamnetworkingconfigFloat;

        public const Native.ESteamNetworkingConfigDataType EsteamnetworkingconfigString = ESteamNetworkingConfigDataType.EsteamnetworkingconfigString;

        public const Native.ESteamNetworkingConfigDataType EsteamnetworkingconfigPtr = ESteamNetworkingConfigDataType.EsteamnetworkingconfigPtr;

        public const Native.ESteamNetworkingConfigDataType EsteamnetworkingconfigdatatypeForce32bit = ESteamNetworkingConfigDataType.EsteamnetworkingconfigdatatypeForce32bit;

        /// <summary>
        /// Configuration options
        /// </summary>
        public enum ESteamNetworkingConfigValue : int
        {
            EsteamnetworkingconfigInvalid = unchecked((int)0),

            /// <summary>
            /// [connection int32] Timeout value (in ms) to use when first connecting
            /// </summary>
            EsteamnetworkingconfigTimeoutinitial = unchecked((int)24),

            /// <summary>
            /// [connection int32] Timeout value (in ms) to use after connection is established
            /// </summary>
            EsteamnetworkingconfigTimeoutconnected = unchecked((int)25),

            /// <summary>
            /// [connection int32] Upper limit of buffered pending bytes to be sent,
            /// if this is reached SendMessage will return k_EResultLimitExceeded
            /// Default is 512k (524288 bytes)
            /// </summary>
            EsteamnetworkingconfigSendbuffersize = unchecked((int)9),

            /// <summary>
            /// [connection int64] Get/set userdata as a configuration option.
            /// The default value is -1.   You may want to set the user data as
            /// a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData
            /// in two specific instances:
            /// </summary>
            /// <remarks>
            /// - You wish to set the userdata atomically when creating
            /// an outbound connection, so that the userdata is filled in properly
            /// for any callbacks that happen.  However, note that this trick
            /// only works for connections initiated locally!  For incoming
            /// connections, multiple state transitions may happen and
            /// callbacks be queued, before you are able to service the first
            /// callback!  Be careful!- You can set the default userdata for all newly created connections
            /// by setting this value at a higher level (e.g. on the listen
            /// socket or at the global level.)  Then this default
            /// value will be inherited when the connection is created.
            /// This is useful in case -1 is a valid userdata value, and you
            /// wish to use something else as the default value so you can
            /// tell if it has been set or not.HOWEVER: once a connection is created, the effective value is
            /// then bound to the connection.  Unlike other connection options,
            /// if you change it again at a higher level, the new value will not
            /// be inherited by connections.Using the userdata field in callback structs is not advised because
            /// of tricky race conditions.  Instead, you might try one of these methods:- Use a separate map with the HSteamNetConnection as the key.
            /// - Fetch the userdata from the connection in your callback
            /// using ISteamNetworkingSockets::GetConnectionUserData, to
            /// ensure you have the current value.
            /// </remarks>
            EsteamnetworkingconfigConnectionuserdata = unchecked((int)40),

            /// <summary>
            /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
            /// This value will control the min/max allowed sending rate that 
            /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
            /// </summary>
            EsteamnetworkingconfigSendratemin = unchecked((int)10),

            /// <summary>
            /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
            /// This value will control the min/max allowed sending rate that 
            /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
            /// </summary>
            EsteamnetworkingconfigSendratemax = unchecked((int)11),

            /// <summary>
            /// [connection int32] Nagle time, in microseconds.  When SendMessage is called, if
            /// the outgoing message is less than the size of the MTU, it will be
            /// queued for a delay equal to the Nagle timer value.  This is to ensure
            /// that if the application sends several small messages rapidly, they are
            /// coalesced into a single packet.
            /// See historical RFC 896.  Value is in microseconds. 
            /// Default is 5000us (5ms).
            /// </summary>
            EsteamnetworkingconfigNagletime = unchecked((int)12),

            /// <summary>
            /// [connection int32] Don't automatically fail IP connections that don't have
            /// strong auth.  On clients, this means we will attempt the connection even if
            /// we don't know our identity or can't get a cert.  On the server, it means that
            /// we won't automatically reject a connection due to a failure to authenticate.
            /// (You can examine the incoming connection and decide whether to accept it.)
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, and you should not let users modify it in
            /// production.
            /// </remarks>
            EsteamnetworkingconfigIpAllowwithoutauth = unchecked((int)23),

            /// <summary>
            /// [connection int32] Do not send UDP packets with a payload of
            /// larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize
            /// is automatically adjusted
            /// </summary>
            EsteamnetworkingconfigMtuPacketsize = unchecked((int)32),

            /// <summary>
            /// [connection int32] (read only) Maximum message size you can send that
            /// will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize
            /// </summary>
            EsteamnetworkingconfigMtuDatasize = unchecked((int)33),

            /// <summary>
            /// [connection int32] Allow unencrypted (and unauthenticated) communication.
            /// 0: Not allowed (the default)
            /// 1: Allowed, but prefer encrypted
            /// 2: Allowed, and preferred
            /// 3: Required.  (Fail the connection if the peer requires encryption.)
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, since its purpose is to disable encryption.
            /// You should not let users modify it in production.  (But note that it requires
            /// the peer to also modify their value in order for encryption to be disabled.)
            /// </remarks>
            EsteamnetworkingconfigUnencrypted = unchecked((int)34),

            /// <summary>
            /// [connection int32] Set this to 1 on outbound connections and listen sockets,
            /// to enable "symmetric connect mode", which is useful in the following
            /// common peer-to-peer use case:
            /// </summary>
            /// <remarks>
            /// - The two peers are "equal" to each other.  (Neither is clearly the "client"
            /// or "server".)
            /// - Either peer may initiate the connection, and indeed they may do this
            /// at the same time
            /// - The peers only desire a single connection to each other, and if both
            /// peers initiate connections simultaneously, a protocol is needed for them
            /// to resolve the conflict, so that we end up with a single connection.This use case is both common, and involves subtle race conditions and tricky
            /// pitfalls, which is why the API has support for dealing with it.If an incoming connection arrives on a listen socket or via custom signaling,
            /// and the application has not attempted to make a matching outbound connection
            /// in symmetric mode, then the incoming connection can be accepted as usual.
            /// A "matching" connection means that the relevant endpoint information matches.
            /// (At the time this comment is being written, this is only supported for P2P
            /// connections, which means that the peer identities must match, and the virtual
            /// port must match.  At a later time, symmetric mode may be supported for other
            /// connection types.)If connections are initiated by both peers simultaneously, race conditions
            /// can arise, but fortunately, most of them are handled internally and do not
            /// require any special awareness from the application.  However, there
            /// is one important case that application code must be aware of:
            /// If application code attempts an outbound connection using a ConnectXxx
            /// function in symmetric mode, and a matching incoming connection is already
            /// waiting on a listen socket, then instead of forming a new connection,
            /// the ConnectXxx call will accept the existing incoming connection, and return
            /// a connection handle to this accepted connection.
            /// IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t
            /// has probably *already* been posted to the queue for the incoming connection!
            /// (Once callbacks are posted to the queue, they are not modified.)  It doesn't
            /// matter if the callback has not been consumed by the app.  Thus, application
            /// code that makes use of symmetric connections must be aware that, when processing a
            /// SteamNetConnectionStatusChangedCallback_t for an incoming connection, the
            /// m_hConn may refer to a new connection that the app has has not
            /// seen before (the usual case), but it may also refer to a connection that
            /// has already been accepted implicitly through a call to Connect()!  In this
            /// case, AcceptConnection() will return k_EResultDuplicateRequest.Only one symmetric connection to a given peer (on a given virtual port)
            /// may exist at any given time.  If client code attempts to create a connection,
            /// and a (live) connection already exists on the local host, then either the
            /// existing connection will be accepted as described above, or the attempt
            /// to create a new connection will fail.  Furthermore, linger mode functionality
            /// is not supported on symmetric connections.A more complicated race condition can arise if both peers initiate a connection
            /// at roughly the same time.  In this situation, each peer will receive an incoming
            /// connection from the other peer, when the application code has already initiated
            /// an outgoing connection to that peer.  The peers must resolve this conflict and
            /// decide who is going to act as the "server" and who will act as the "client".
            /// Typically the application does not need to be aware of this case as it is handled
            /// internally.  On both sides, the will observe their outbound connection being
            /// "accepted", although one of them one have been converted internally to act
            /// as the "server".In general, symmetric mode should be all-or-nothing: do not mix symmetric
            /// connections with a non-symmetric connection that it might possible "match"
            /// with.  If you use symmetric mode on any connections, then both peers should
            /// use it on all connections, and the corresponding listen socket, if any.  The
            /// behaviour when symmetric and ordinary connections are mixed is not defined by
            /// this API, and you should not rely on it.  (This advice only applies when connections
            /// might possibly "match".  For example, it's OK to use all symmetric mode
            /// connections on one virtual port, and all ordinary, non-symmetric connections
            /// on a different virtual port, as there is no potential for ambiguity.)When using the feature, you should set it in the following situations on
            /// applicable objects:- When creating an outbound connection using ConnectXxx function
            /// - When creating a listen socket.  (Note that this will automatically cause
            /// any accepted connections to inherit the flag.)
            /// - When using custom signaling, before accepting an incoming connection.Setting the flag on listen socket and accepted connections will enable the
            /// API to automatically deal with duplicate incoming connections, even if the
            /// local host has not made any outbound requests.  (In general, such duplicate
            /// requests from a peer are ignored internally and will not be visible to the
            /// application code.  The previous connection must be closed or resolved first.)
            /// </remarks>
            EsteamnetworkingconfigSymmetricconnect = unchecked((int)37),

            /// <summary>
            /// [connection int32] For connection types that use "virtual ports", this can be used
            /// to assign a local virtual port.  For incoming connections, this will always be the
            /// virtual port of the listen socket (or the port requested by the remote host if custom
            /// signaling is used and the connection is accepted), and cannot be changed.  For
            /// connections initiated locally, the local virtual port will default to the same as the
            /// requested remote virtual port, if you do not specify a different option when creating
            /// the connection.  The local port is only relevant for symmetric connections, when
            /// determining if two connections "match."  In this case, if you need the local and remote
            /// port to differ, you can set this value.
            /// </summary>
            /// <remarks>
            /// You can also read back this value on listen sockets.This value should not be read or written in any other context.
            /// </remarks>
            EsteamnetworkingconfigLocalvirtualport = unchecked((int)38),

            /// <summary>
            /// [connection int32] True to enable diagnostics reporting through
            /// generic platform UI.  (Only available on Steam.)
            /// </summary>
            EsteamnetworkingconfigEnablediagnosticsui = unchecked((int)46),

            /// <summary>
            /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
            /// This is a global option only, since it is applied at a low level
            /// where we don't have much context
            /// </summary>
            EsteamnetworkingconfigFakepacketlossSend = unchecked((int)2),

            /// <summary>
            /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
            /// This is a global option only, since it is applied at a low level
            /// where we don't have much context
            /// </summary>
            EsteamnetworkingconfigFakepacketlossRecv = unchecked((int)3),

            /// <summary>
            /// [global int32].  Delay all outbound/inbound packets by N ms
            /// </summary>
            EsteamnetworkingconfigFakepacketlagSend = unchecked((int)4),

            /// <summary>
            /// [global int32].  Delay all outbound/inbound packets by N ms
            /// </summary>
            EsteamnetworkingconfigFakepacketlagRecv = unchecked((int)5),

            /// <summary>
            /// [global float] 0-100 Percentage of packets we will add additional delay
            /// to (causing them to be reordered)
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderSend = unchecked((int)6),

            /// <summary>
            /// [global float] 0-100 Percentage of packets we will add additional delay
            /// to (causing them to be reordered)
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderRecv = unchecked((int)7),

            /// <summary>
            /// [global int32] Extra delay, in ms, to apply to reordered packets.
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderTime = unchecked((int)8),

            /// <summary>
            /// [global float 0--100] Globally duplicate some percentage of packets we send
            /// </summary>
            EsteamnetworkingconfigFakepacketdupSend = unchecked((int)26),

            /// <summary>
            /// [global float 0--100] Globally duplicate some percentage of packets we send
            /// </summary>
            EsteamnetworkingconfigFakepacketdupRecv = unchecked((int)27),

            /// <summary>
            /// [global int32] Amount of delay, in ms, to delay duplicated packets.
            /// (We chose a random delay between 0 and this value)
            /// </summary>
            EsteamnetworkingconfigFakepacketdupTimemax = unchecked((int)28),

            /// <summary>
            /// [global int32] Trace every UDP packet, similar to Wireshark or tcpdump.
            /// Value is max number of bytes to dump.  -1 disables tracing.
            /// 0 only traces the info but no actual data bytes
            /// </summary>
            EsteamnetworkingconfigPackettracemaxbytes = unchecked((int)41),

            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitSendRate = unchecked((int)42),

            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitSendBurst = unchecked((int)43),

            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitRecvRate = unchecked((int)44),

            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitRecvBurst = unchecked((int)45),

            /// <summary>
            /// [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked
            /// when the state of a connection changes.
            /// </summary>
            /// <remarks>
            /// IMPORTANT: callbacks are dispatched to the handler that is in effect at the time
            /// the event occurs, which might be in another thread.  For example, immediately after
            /// creating a listen socket, you may receive an incoming connection.  And then immediately
            /// after this, the remote host may close the connection.  All of this could happen
            /// before the function to create the listen socket has returned.  For this reason,
            /// callbacks usually must be in effect at the time of object creation.  This means
            /// you should set them when you are creating the listen socket or connection, or have
            /// them in effect so they will be inherited at the time of object creation.For example:exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );
            /// SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );
            /// SteamNetworkingIPAddr localAddress; localAddress.Clear();
            /// HSteamListenSocket hListenSock = SteamNetworkingSockets()-&gt;CreateListenSocketIP( localAddress, 1, 
            /// &amp;opt
            /// );When accepting an incoming connection, there is no atomic way to switch the
            /// callback.  However, if the connection is DOA, AcceptConnection() will fail, and
            /// you can fetch the state of the connection at that time.If all connections and listen sockets can use the same callback, the simplest
            /// method is to set it globally before you create any listen sockets or connections.
            /// </remarks>
            EsteamnetworkingconfigCallbackConnectionstatuschanged = unchecked((int)201),

            /// <summary>
            /// [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked
            /// when our auth state changes.  If you use this, install the callback before creating
            /// any connections or listen sockets, and don't change it.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged
            /// </summary>
            EsteamnetworkingconfigCallbackAuthstatuschanged = unchecked((int)202),

            /// <summary>
            /// [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked
            /// when our auth state changes.  If you use this, install the callback before creating
            /// any connections or listen sockets, and don't change it.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged
            /// </summary>
            EsteamnetworkingconfigCallbackRelaynetworkstatuschanged = unchecked((int)203),

            /// <summary>
            /// [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked
            /// when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest
            /// </summary>
            EsteamnetworkingconfigCallbackMessagessessionrequest = unchecked((int)204),

            /// <summary>
            /// [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked
            /// when a session you have initiated, or accepted either fails to connect, or loses
            /// connection in some unexpected way.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed
            /// </summary>
            EsteamnetworkingconfigCallbackMessagessessionfailed = unchecked((int)205),

            /// <summary>
            /// [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will
            /// be invoked when we need to create a signaling object for a connection
            /// initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,
            /// ISteamNetworkingMessages.
            /// </summary>
            EsteamnetworkingconfigCallbackCreateconnectionsignaling = unchecked((int)206),

            /// <summary>
            /// [global FnSteamNetworkingFakeIPResult] Callback that's invoked when
            /// a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,
            /// ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult
            /// </summary>
            EsteamnetworkingconfigCallbackFakeipresult = unchecked((int)207),

            /// <summary>
            /// [connection string] Comma-separated list of STUN servers that can be used
            /// for NAT piercing.  If you set this to an empty string, NAT piercing will
            /// not be attempted.  Also if "public" candidates are not allowed for
            /// P2P_Transport_ICE_Enable, then this is ignored.
            /// </summary>
            EsteamnetworkingconfigP2pStunServerlist = unchecked((int)103),

            /// <summary>
            /// [connection int32] What types of ICE candidates to share with the peer.
            /// See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values
            /// </summary>
            EsteamnetworkingconfigP2pTransportIceEnable = unchecked((int)104),

            /// <summary>
            /// [connection int32] When selecting P2P transport, add various
            /// penalties to the scores for selected transports.  (Route selection
            /// scores are on a scale of milliseconds.  The score begins with the
            /// route ping time and is then adjusted.)
            /// </summary>
            EsteamnetworkingconfigP2pTransportIcePenalty = unchecked((int)105),

            /// <summary>
            /// [connection int32] When selecting P2P transport, add various
            /// penalties to the scores for selected transports.  (Route selection
            /// scores are on a scale of milliseconds.  The score begins with the
            /// route ping time and is then adjusted.)
            /// </summary>
            EsteamnetworkingconfigP2pTransportSdrPenalty = unchecked((int)106),

            /// <summary>
            /// [int32 global] If the first N pings to a port all fail, mark that port as unavailable for
            /// a while, and try a different one.  Some ISPs and routers may drop the first
            /// packet, so setting this to 1 may greatly disrupt communications.
            /// </summary>
            EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfailinitial = unchecked((int)19),

            /// <summary>
            /// [int32 global] If N consecutive pings to a port fail, after having received successful 
            /// communication, mark that port as unavailable for a while, and try a 
            /// different one.
            /// </summary>
            EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfail = unchecked((int)20),

            /// <summary>
            /// [int32 global] Minimum number of lifetime pings we need to send, before we think our estimate
            /// is solid.  The first ping to each cluster is very often delayed because of NAT,
            /// routers not having the best route, etc.  Until we've sent a sufficient number
            /// of pings, our estimate is often inaccurate.  Keep pinging until we get this
            /// many pings.
            /// </summary>
            EsteamnetworkingconfigSdrclientMinpingsbeforepingaccurate = unchecked((int)21),

            /// <summary>
            /// [int32 global] Set all steam datagram traffic to originate from the same
            /// local port. By default, we open up a new UDP socket (on a different local
            /// port) for each relay.  This is slightly less optimal, but it works around
            /// some routers that don't implement NAT properly.  If you have intermittent
            /// problems talking to relays that might be NAT related, try toggling
            /// this flag
            /// </summary>
            EsteamnetworkingconfigSdrclientSinglesocket = unchecked((int)22),

            /// <summary>
            /// [global string] Code of relay cluster to force use.  If not empty, we will
            /// only use relays in that cluster.  E.g. 'iad'
            /// </summary>
            EsteamnetworkingconfigSdrclientForcerelaycluster = unchecked((int)29),

            /// <summary>
            /// [connection string] For debugging, generate our own (unsigned) ticket, using
            /// the specified  gameserver address.  Router must be configured to accept unsigned
            /// tickets.
            /// </summary>
            EsteamnetworkingconfigSdrclientDebugticketaddress = unchecked((int)30),

            /// <summary>
            /// [global string] For debugging.  Override list of relays from the config with
            /// this set (maybe just one).  Comma-separated list.
            /// </summary>
            EsteamnetworkingconfigSdrclientForceproxyaddr = unchecked((int)31),

            /// <summary>
            /// [global string] For debugging.  Force ping times to clusters to be the specified
            /// values.  A comma separated list of 
            /// &lt;cluster
            /// &gt;=
            /// &lt;ms
            /// &gt; values.  E.g. "sto=32,iad=100"
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, you probably should not let users modify it
            /// in production.
            /// </remarks>
            EsteamnetworkingconfigSdrclientFakeclusterping = unchecked((int)36),

            /// <summary>
            /// [connection int32] RTT calculations for inline pings and replies
            /// </summary>
            EsteamnetworkingconfigLoglevelAckrtt = unchecked((int)13),

            /// <summary>
            /// [connection int32] log SNP packets send/recv
            /// </summary>
            EsteamnetworkingconfigLoglevelPacketdecode = unchecked((int)14),

            /// <summary>
            /// [connection int32] log each message send/recv
            /// </summary>
            EsteamnetworkingconfigLoglevelMessage = unchecked((int)15),

            /// <summary>
            /// [connection int32] dropped packets
            /// </summary>
            EsteamnetworkingconfigLoglevelPacketgaps = unchecked((int)16),

            /// <summary>
            /// [connection int32] P2P rendezvous messages
            /// </summary>
            EsteamnetworkingconfigLoglevelP2prendezvous = unchecked((int)17),

            /// <summary>
            /// [global int32] Ping relays
            /// </summary>
            EsteamnetworkingconfigLoglevelSdrrelaypings = unchecked((int)18),

            /// <summary>
            /// Deleted, do not use
            /// </summary>
            EsteamnetworkingconfigDeletedEnumeratedevvars = unchecked((int)35),

            /// <summary>
            /// Deleted, do not use
            /// </summary>
            EsteamnetworkingconfigvalueForce32bit = unchecked((int)0x7fffffff),
        }

        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigInvalid = ESteamNetworkingConfigValue.EsteamnetworkingconfigInvalid;

        /// <summary>
        /// [connection int32] Timeout value (in ms) to use when first connecting
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigTimeoutinitial = ESteamNetworkingConfigValue.EsteamnetworkingconfigTimeoutinitial;

        /// <summary>
        /// [connection int32] Timeout value (in ms) to use after connection is established
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigTimeoutconnected = ESteamNetworkingConfigValue.EsteamnetworkingconfigTimeoutconnected;

        /// <summary>
        /// [connection int32] Upper limit of buffered pending bytes to be sent,
        /// if this is reached SendMessage will return k_EResultLimitExceeded
        /// Default is 512k (524288 bytes)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSendbuffersize = ESteamNetworkingConfigValue.EsteamnetworkingconfigSendbuffersize;

        /// <summary>
        /// [connection int64] Get/set userdata as a configuration option.
        /// The default value is -1.   You may want to set the user data as
        /// a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData
        /// in two specific instances:
        /// </summary>
        /// <remarks>
        /// - You wish to set the userdata atomically when creating
        /// an outbound connection, so that the userdata is filled in properly
        /// for any callbacks that happen.  However, note that this trick
        /// only works for connections initiated locally!  For incoming
        /// connections, multiple state transitions may happen and
        /// callbacks be queued, before you are able to service the first
        /// callback!  Be careful!- You can set the default userdata for all newly created connections
        /// by setting this value at a higher level (e.g. on the listen
        /// socket or at the global level.)  Then this default
        /// value will be inherited when the connection is created.
        /// This is useful in case -1 is a valid userdata value, and you
        /// wish to use something else as the default value so you can
        /// tell if it has been set or not.HOWEVER: once a connection is created, the effective value is
        /// then bound to the connection.  Unlike other connection options,
        /// if you change it again at a higher level, the new value will not
        /// be inherited by connections.Using the userdata field in callback structs is not advised because
        /// of tricky race conditions.  Instead, you might try one of these methods:- Use a separate map with the HSteamNetConnection as the key.
        /// - Fetch the userdata from the connection in your callback
        /// using ISteamNetworkingSockets::GetConnectionUserData, to
        /// ensure you have the current value.
        /// </remarks>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigConnectionuserdata = ESteamNetworkingConfigValue.EsteamnetworkingconfigConnectionuserdata;

        /// <summary>
        /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
        /// This value will control the min/max allowed sending rate that 
        /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSendratemin = ESteamNetworkingConfigValue.EsteamnetworkingconfigSendratemin;

        /// <summary>
        /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
        /// This value will control the min/max allowed sending rate that 
        /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSendratemax = ESteamNetworkingConfigValue.EsteamnetworkingconfigSendratemax;

        /// <summary>
        /// [connection int32] Nagle time, in microseconds.  When SendMessage is called, if
        /// the outgoing message is less than the size of the MTU, it will be
        /// queued for a delay equal to the Nagle timer value.  This is to ensure
        /// that if the application sends several small messages rapidly, they are
        /// coalesced into a single packet.
        /// See historical RFC 896.  Value is in microseconds. 
        /// Default is 5000us (5ms).
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigNagletime = ESteamNetworkingConfigValue.EsteamnetworkingconfigNagletime;

        /// <summary>
        /// [connection int32] Don't automatically fail IP connections that don't have
        /// strong auth.  On clients, this means we will attempt the connection even if
        /// we don't know our identity or can't get a cert.  On the server, it means that
        /// we won't automatically reject a connection due to a failure to authenticate.
        /// (You can examine the incoming connection and decide whether to accept it.)
        /// </summary>
        /// <remarks>
        /// This is a dev configuration value, and you should not let users modify it in
        /// production.
        /// </remarks>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigIpAllowwithoutauth = ESteamNetworkingConfigValue.EsteamnetworkingconfigIpAllowwithoutauth;

        /// <summary>
        /// [connection int32] Do not send UDP packets with a payload of
        /// larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize
        /// is automatically adjusted
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigMtuPacketsize = ESteamNetworkingConfigValue.EsteamnetworkingconfigMtuPacketsize;

        /// <summary>
        /// [connection int32] (read only) Maximum message size you can send that
        /// will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigMtuDatasize = ESteamNetworkingConfigValue.EsteamnetworkingconfigMtuDatasize;

        /// <summary>
        /// [connection int32] Allow unencrypted (and unauthenticated) communication.
        /// 0: Not allowed (the default)
        /// 1: Allowed, but prefer encrypted
        /// 2: Allowed, and preferred
        /// 3: Required.  (Fail the connection if the peer requires encryption.)
        /// </summary>
        /// <remarks>
        /// This is a dev configuration value, since its purpose is to disable encryption.
        /// You should not let users modify it in production.  (But note that it requires
        /// the peer to also modify their value in order for encryption to be disabled.)
        /// </remarks>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigUnencrypted = ESteamNetworkingConfigValue.EsteamnetworkingconfigUnencrypted;

        /// <summary>
        /// [connection int32] Set this to 1 on outbound connections and listen sockets,
        /// to enable "symmetric connect mode", which is useful in the following
        /// common peer-to-peer use case:
        /// </summary>
        /// <remarks>
        /// - The two peers are "equal" to each other.  (Neither is clearly the "client"
        /// or "server".)
        /// - Either peer may initiate the connection, and indeed they may do this
        /// at the same time
        /// - The peers only desire a single connection to each other, and if both
        /// peers initiate connections simultaneously, a protocol is needed for them
        /// to resolve the conflict, so that we end up with a single connection.This use case is both common, and involves subtle race conditions and tricky
        /// pitfalls, which is why the API has support for dealing with it.If an incoming connection arrives on a listen socket or via custom signaling,
        /// and the application has not attempted to make a matching outbound connection
        /// in symmetric mode, then the incoming connection can be accepted as usual.
        /// A "matching" connection means that the relevant endpoint information matches.
        /// (At the time this comment is being written, this is only supported for P2P
        /// connections, which means that the peer identities must match, and the virtual
        /// port must match.  At a later time, symmetric mode may be supported for other
        /// connection types.)If connections are initiated by both peers simultaneously, race conditions
        /// can arise, but fortunately, most of them are handled internally and do not
        /// require any special awareness from the application.  However, there
        /// is one important case that application code must be aware of:
        /// If application code attempts an outbound connection using a ConnectXxx
        /// function in symmetric mode, and a matching incoming connection is already
        /// waiting on a listen socket, then instead of forming a new connection,
        /// the ConnectXxx call will accept the existing incoming connection, and return
        /// a connection handle to this accepted connection.
        /// IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t
        /// has probably *already* been posted to the queue for the incoming connection!
        /// (Once callbacks are posted to the queue, they are not modified.)  It doesn't
        /// matter if the callback has not been consumed by the app.  Thus, application
        /// code that makes use of symmetric connections must be aware that, when processing a
        /// SteamNetConnectionStatusChangedCallback_t for an incoming connection, the
        /// m_hConn may refer to a new connection that the app has has not
        /// seen before (the usual case), but it may also refer to a connection that
        /// has already been accepted implicitly through a call to Connect()!  In this
        /// case, AcceptConnection() will return k_EResultDuplicateRequest.Only one symmetric connection to a given peer (on a given virtual port)
        /// may exist at any given time.  If client code attempts to create a connection,
        /// and a (live) connection already exists on the local host, then either the
        /// existing connection will be accepted as described above, or the attempt
        /// to create a new connection will fail.  Furthermore, linger mode functionality
        /// is not supported on symmetric connections.A more complicated race condition can arise if both peers initiate a connection
        /// at roughly the same time.  In this situation, each peer will receive an incoming
        /// connection from the other peer, when the application code has already initiated
        /// an outgoing connection to that peer.  The peers must resolve this conflict and
        /// decide who is going to act as the "server" and who will act as the "client".
        /// Typically the application does not need to be aware of this case as it is handled
        /// internally.  On both sides, the will observe their outbound connection being
        /// "accepted", although one of them one have been converted internally to act
        /// as the "server".In general, symmetric mode should be all-or-nothing: do not mix symmetric
        /// connections with a non-symmetric connection that it might possible "match"
        /// with.  If you use symmetric mode on any connections, then both peers should
        /// use it on all connections, and the corresponding listen socket, if any.  The
        /// behaviour when symmetric and ordinary connections are mixed is not defined by
        /// this API, and you should not rely on it.  (This advice only applies when connections
        /// might possibly "match".  For example, it's OK to use all symmetric mode
        /// connections on one virtual port, and all ordinary, non-symmetric connections
        /// on a different virtual port, as there is no potential for ambiguity.)When using the feature, you should set it in the following situations on
        /// applicable objects:- When creating an outbound connection using ConnectXxx function
        /// - When creating a listen socket.  (Note that this will automatically cause
        /// any accepted connections to inherit the flag.)
        /// - When using custom signaling, before accepting an incoming connection.Setting the flag on listen socket and accepted connections will enable the
        /// API to automatically deal with duplicate incoming connections, even if the
        /// local host has not made any outbound requests.  (In general, such duplicate
        /// requests from a peer are ignored internally and will not be visible to the
        /// application code.  The previous connection must be closed or resolved first.)
        /// </remarks>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSymmetricconnect = ESteamNetworkingConfigValue.EsteamnetworkingconfigSymmetricconnect;

        /// <summary>
        /// [connection int32] For connection types that use "virtual ports", this can be used
        /// to assign a local virtual port.  For incoming connections, this will always be the
        /// virtual port of the listen socket (or the port requested by the remote host if custom
        /// signaling is used and the connection is accepted), and cannot be changed.  For
        /// connections initiated locally, the local virtual port will default to the same as the
        /// requested remote virtual port, if you do not specify a different option when creating
        /// the connection.  The local port is only relevant for symmetric connections, when
        /// determining if two connections "match."  In this case, if you need the local and remote
        /// port to differ, you can set this value.
        /// </summary>
        /// <remarks>
        /// You can also read back this value on listen sockets.This value should not be read or written in any other context.
        /// </remarks>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigLocalvirtualport = ESteamNetworkingConfigValue.EsteamnetworkingconfigLocalvirtualport;

        /// <summary>
        /// [connection int32] True to enable diagnostics reporting through
        /// generic platform UI.  (Only available on Steam.)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigEnablediagnosticsui = ESteamNetworkingConfigValue.EsteamnetworkingconfigEnablediagnosticsui;

        /// <summary>
        /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
        /// This is a global option only, since it is applied at a low level
        /// where we don't have much context
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketlossSend = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketlossSend;

        /// <summary>
        /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
        /// This is a global option only, since it is applied at a low level
        /// where we don't have much context
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketlossRecv = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketlossRecv;

        /// <summary>
        /// [global int32].  Delay all outbound/inbound packets by N ms
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketlagSend = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketlagSend;

        /// <summary>
        /// [global int32].  Delay all outbound/inbound packets by N ms
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketlagRecv = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketlagRecv;

        /// <summary>
        /// [global float] 0-100 Percentage of packets we will add additional delay
        /// to (causing them to be reordered)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketreorderSend = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketreorderSend;

        /// <summary>
        /// [global float] 0-100 Percentage of packets we will add additional delay
        /// to (causing them to be reordered)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketreorderRecv = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketreorderRecv;

        /// <summary>
        /// [global int32] Extra delay, in ms, to apply to reordered packets.
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketreorderTime = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketreorderTime;

        /// <summary>
        /// [global float 0--100] Globally duplicate some percentage of packets we send
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketdupSend = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketdupSend;

        /// <summary>
        /// [global float 0--100] Globally duplicate some percentage of packets we send
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketdupRecv = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketdupRecv;

        /// <summary>
        /// [global int32] Amount of delay, in ms, to delay duplicated packets.
        /// (We chose a random delay between 0 and this value)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketdupTimemax = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketdupTimemax;

        /// <summary>
        /// [global int32] Trace every UDP packet, similar to Wireshark or tcpdump.
        /// Value is max number of bytes to dump.  -1 disables tracing.
        /// 0 only traces the info but no actual data bytes
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigPackettracemaxbytes = ESteamNetworkingConfigValue.EsteamnetworkingconfigPackettracemaxbytes;

        /// <summary>
        /// [global int32] Global UDP token bucket rate limits.
        /// "Rate" refers to the steady state rate. (Bytes/sec, the
        /// rate that tokens are put into the bucket.)  "Burst"
        /// refers to the max amount that could be sent in a single
        /// burst.  (In bytes, the max capacity of the bucket.)
        /// Rate=0 disables the limiter entirely, which is the default.
        /// Burst=0 disables burst.  (This is not realistic.  A
        /// burst of at least 4K is recommended; the default is higher.)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakeratelimitSendRate = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakeratelimitSendRate;

        /// <summary>
        /// [global int32] Global UDP token bucket rate limits.
        /// "Rate" refers to the steady state rate. (Bytes/sec, the
        /// rate that tokens are put into the bucket.)  "Burst"
        /// refers to the max amount that could be sent in a single
        /// burst.  (In bytes, the max capacity of the bucket.)
        /// Rate=0 disables the limiter entirely, which is the default.
        /// Burst=0 disables burst.  (This is not realistic.  A
        /// burst of at least 4K is recommended; the default is higher.)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakeratelimitSendBurst = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakeratelimitSendBurst;

        /// <summary>
        /// [global int32] Global UDP token bucket rate limits.
        /// "Rate" refers to the steady state rate. (Bytes/sec, the
        /// rate that tokens are put into the bucket.)  "Burst"
        /// refers to the max amount that could be sent in a single
        /// burst.  (In bytes, the max capacity of the bucket.)
        /// Rate=0 disables the limiter entirely, which is the default.
        /// Burst=0 disables burst.  (This is not realistic.  A
        /// burst of at least 4K is recommended; the default is higher.)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakeratelimitRecvRate = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakeratelimitRecvRate;

        /// <summary>
        /// [global int32] Global UDP token bucket rate limits.
        /// "Rate" refers to the steady state rate. (Bytes/sec, the
        /// rate that tokens are put into the bucket.)  "Burst"
        /// refers to the max amount that could be sent in a single
        /// burst.  (In bytes, the max capacity of the bucket.)
        /// Rate=0 disables the limiter entirely, which is the default.
        /// Burst=0 disables burst.  (This is not realistic.  A
        /// burst of at least 4K is recommended; the default is higher.)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigFakeratelimitRecvBurst = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakeratelimitRecvBurst;

        /// <summary>
        /// [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked
        /// when the state of a connection changes.
        /// </summary>
        /// <remarks>
        /// IMPORTANT: callbacks are dispatched to the handler that is in effect at the time
        /// the event occurs, which might be in another thread.  For example, immediately after
        /// creating a listen socket, you may receive an incoming connection.  And then immediately
        /// after this, the remote host may close the connection.  All of this could happen
        /// before the function to create the listen socket has returned.  For this reason,
        /// callbacks usually must be in effect at the time of object creation.  This means
        /// you should set them when you are creating the listen socket or connection, or have
        /// them in effect so they will be inherited at the time of object creation.For example:exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );
        /// SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );
        /// SteamNetworkingIPAddr localAddress; localAddress.Clear();
        /// HSteamListenSocket hListenSock = SteamNetworkingSockets()-&gt;CreateListenSocketIP( localAddress, 1, 
        /// &amp;opt
        /// );When accepting an incoming connection, there is no atomic way to switch the
        /// callback.  However, if the connection is DOA, AcceptConnection() will fail, and
        /// you can fetch the state of the connection at that time.If all connections and listen sockets can use the same callback, the simplest
        /// method is to set it globally before you create any listen sockets or connections.
        /// </remarks>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackConnectionstatuschanged = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackConnectionstatuschanged;

        /// <summary>
        /// [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked
        /// when our auth state changes.  If you use this, install the callback before creating
        /// any connections or listen sockets, and don't change it.
        /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackAuthstatuschanged = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackAuthstatuschanged;

        /// <summary>
        /// [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked
        /// when our auth state changes.  If you use this, install the callback before creating
        /// any connections or listen sockets, and don't change it.
        /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackRelaynetworkstatuschanged = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackRelaynetworkstatuschanged;

        /// <summary>
        /// [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked
        /// when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.
        /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackMessagessessionrequest = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackMessagessessionrequest;

        /// <summary>
        /// [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked
        /// when a session you have initiated, or accepted either fails to connect, or loses
        /// connection in some unexpected way.
        /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackMessagessessionfailed = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackMessagessessionfailed;

        /// <summary>
        /// [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will
        /// be invoked when we need to create a signaling object for a connection
        /// initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,
        /// ISteamNetworkingMessages.
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackCreateconnectionsignaling = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackCreateconnectionsignaling;

        /// <summary>
        /// [global FnSteamNetworkingFakeIPResult] Callback that's invoked when
        /// a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,
        /// ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackFakeipresult = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackFakeipresult;

        /// <summary>
        /// [connection string] Comma-separated list of STUN servers that can be used
        /// for NAT piercing.  If you set this to an empty string, NAT piercing will
        /// not be attempted.  Also if "public" candidates are not allowed for
        /// P2P_Transport_ICE_Enable, then this is ignored.
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigP2pStunServerlist = ESteamNetworkingConfigValue.EsteamnetworkingconfigP2pStunServerlist;

        /// <summary>
        /// [connection int32] What types of ICE candidates to share with the peer.
        /// See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigP2pTransportIceEnable = ESteamNetworkingConfigValue.EsteamnetworkingconfigP2pTransportIceEnable;

        /// <summary>
        /// [connection int32] When selecting P2P transport, add various
        /// penalties to the scores for selected transports.  (Route selection
        /// scores are on a scale of milliseconds.  The score begins with the
        /// route ping time and is then adjusted.)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigP2pTransportIcePenalty = ESteamNetworkingConfigValue.EsteamnetworkingconfigP2pTransportIcePenalty;

        /// <summary>
        /// [connection int32] When selecting P2P transport, add various
        /// penalties to the scores for selected transports.  (Route selection
        /// scores are on a scale of milliseconds.  The score begins with the
        /// route ping time and is then adjusted.)
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigP2pTransportSdrPenalty = ESteamNetworkingConfigValue.EsteamnetworkingconfigP2pTransportSdrPenalty;

        /// <summary>
        /// [int32 global] If the first N pings to a port all fail, mark that port as unavailable for
        /// a while, and try a different one.  Some ISPs and routers may drop the first
        /// packet, so setting this to 1 may greatly disrupt communications.
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfailinitial = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfailinitial;

        /// <summary>
        /// [int32 global] If N consecutive pings to a port fail, after having received successful 
        /// communication, mark that port as unavailable for a while, and try a 
        /// different one.
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfail = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfail;

        /// <summary>
        /// [int32 global] Minimum number of lifetime pings we need to send, before we think our estimate
        /// is solid.  The first ping to each cluster is very often delayed because of NAT,
        /// routers not having the best route, etc.  Until we've sent a sufficient number
        /// of pings, our estimate is often inaccurate.  Keep pinging until we get this
        /// many pings.
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientMinpingsbeforepingaccurate = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientMinpingsbeforepingaccurate;

        /// <summary>
        /// [int32 global] Set all steam datagram traffic to originate from the same
        /// local port. By default, we open up a new UDP socket (on a different local
        /// port) for each relay.  This is slightly less optimal, but it works around
        /// some routers that don't implement NAT properly.  If you have intermittent
        /// problems talking to relays that might be NAT related, try toggling
        /// this flag
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientSinglesocket = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientSinglesocket;

        /// <summary>
        /// [global string] Code of relay cluster to force use.  If not empty, we will
        /// only use relays in that cluster.  E.g. 'iad'
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientForcerelaycluster = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientForcerelaycluster;

        /// <summary>
        /// [connection string] For debugging, generate our own (unsigned) ticket, using
        /// the specified  gameserver address.  Router must be configured to accept unsigned
        /// tickets.
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientDebugticketaddress = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientDebugticketaddress;

        /// <summary>
        /// [global string] For debugging.  Override list of relays from the config with
        /// this set (maybe just one).  Comma-separated list.
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientForceproxyaddr = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientForceproxyaddr;

        /// <summary>
        /// [global string] For debugging.  Force ping times to clusters to be the specified
        /// values.  A comma separated list of 
        /// &lt;cluster
        /// &gt;=
        /// &lt;ms
        /// &gt; values.  E.g. "sto=32,iad=100"
        /// </summary>
        /// <remarks>
        /// This is a dev configuration value, you probably should not let users modify it
        /// in production.
        /// </remarks>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientFakeclusterping = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientFakeclusterping;

        /// <summary>
        /// [connection int32] RTT calculations for inline pings and replies
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelAckrtt = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelAckrtt;

        /// <summary>
        /// [connection int32] log SNP packets send/recv
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelPacketdecode = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelPacketdecode;

        /// <summary>
        /// [connection int32] log each message send/recv
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelMessage = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelMessage;

        /// <summary>
        /// [connection int32] dropped packets
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelPacketgaps = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelPacketgaps;

        /// <summary>
        /// [connection int32] P2P rendezvous messages
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelP2prendezvous = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelP2prendezvous;

        /// <summary>
        /// [global int32] Ping relays
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelSdrrelaypings = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelSdrrelaypings;

        /// <summary>
        /// Deleted, do not use
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigDeletedEnumeratedevvars = ESteamNetworkingConfigValue.EsteamnetworkingconfigDeletedEnumeratedevvars;

        /// <summary>
        /// Deleted, do not use
        /// </summary>
        public const Native.ESteamNetworkingConfigValue EsteamnetworkingconfigvalueForce32bit = ESteamNetworkingConfigValue.EsteamnetworkingconfigvalueForce32bit;

        /// <summary>
        /// Return value of ISteamNetworkintgUtils::GetConfigValue
        /// </summary>
        public enum ESteamNetworkingGetConfigValueResult : int
        {
            /// <summary>
            /// No such configuration value
            /// </summary>
            EsteamnetworkinggetconfigvalueBadvalue = unchecked((int)-1),

            /// <summary>
            /// Bad connection handle, etc
            /// </summary>
            EsteamnetworkinggetconfigvalueBadscopeobj = unchecked((int)-2),

            /// <summary>
            /// Couldn't fit the result in your buffer
            /// </summary>
            EsteamnetworkinggetconfigvalueBuffertoosmall = unchecked((int)-3),

            EsteamnetworkinggetconfigvalueOk = unchecked((int)1),

            /// <summary>
            /// A value was not set at this level, but the effective (inherited) value was returned.
            /// </summary>
            EsteamnetworkinggetconfigvalueOkinherited = unchecked((int)2),

            EsteamnetworkinggetconfigvalueresultForce32bit = unchecked((int)0x7fffffff),
        }

        /// <summary>
        /// No such configuration value
        /// </summary>
        public const Native.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueBadvalue = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueBadvalue;

        /// <summary>
        /// Bad connection handle, etc
        /// </summary>
        public const Native.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueBadscopeobj = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueBadscopeobj;

        /// <summary>
        /// Couldn't fit the result in your buffer
        /// </summary>
        public const Native.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueBuffertoosmall = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueBuffertoosmall;

        public const Native.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueOk = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueOk;

        /// <summary>
        /// A value was not set at this level, but the effective (inherited) value was returned.
        /// </summary>
        public const Native.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueOkinherited = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueOkinherited;

        public const Native.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueresultForce32bit = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueresultForce32bit;

        /// <summary>
        /// Detail level for diagnostic output callback.
        /// See ISteamNetworkingUtils::SetDebugOutputFunction
        /// </summary>
        public enum ESteamNetworkingSocketsDebugOutputType : int
        {
            EsteamnetworkingsocketsdebugoutputtypeNone = unchecked((int)0),

            /// <summary>
            /// You used the API incorrectly, or an internal error happened
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeBug = unchecked((int)1),

            /// <summary>
            /// Run-time error condition that isn't the result of a bug.  (E.g. we are offline, cannot bind a port, etc)
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeError = unchecked((int)2),

            /// <summary>
            /// Nothing is wrong, but this is an important notification
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeImportant = unchecked((int)3),

            EsteamnetworkingsocketsdebugoutputtypeWarning = unchecked((int)4),

            /// <summary>
            /// Recommended amount
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeMsg = unchecked((int)5),

            /// <summary>
            /// Quite a bit
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeVerbose = unchecked((int)6),

            /// <summary>
            /// Practically everything
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeDebug = unchecked((int)7),

            /// <summary>
            /// Wall of text, detailed packet contents breakdown, etc
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeEverything = unchecked((int)8),

            EsteamnetworkingsocketsdebugoutputtypeForce32bit = unchecked((int)0x7fffffff),
        }

        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeNone = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeNone;

        /// <summary>
        /// You used the API incorrectly, or an internal error happened
        /// </summary>
        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeBug = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeBug;

        /// <summary>
        /// Run-time error condition that isn't the result of a bug.  (E.g. we are offline, cannot bind a port, etc)
        /// </summary>
        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeError = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeError;

        /// <summary>
        /// Nothing is wrong, but this is an important notification
        /// </summary>
        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeImportant = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeImportant;

        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeWarning = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeWarning;

        /// <summary>
        /// Recommended amount
        /// </summary>
        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeMsg = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeMsg;

        /// <summary>
        /// Quite a bit
        /// </summary>
        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeVerbose = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeVerbose;

        /// <summary>
        /// Practically everything
        /// </summary>
        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeDebug = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeDebug;

        /// <summary>
        /// Wall of text, detailed packet contents breakdown, etc
        /// </summary>
        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeEverything = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeEverything;

        public const Native.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeForce32bit = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeForce32bit;

        public enum __AnonymousCppEnum_steam_api_common_290AnonymousEnum : int
        {
            Isteamnetworkingsocketscallbacks = unchecked((int)1220),
        }

        public const Native.__AnonymousCppEnum_steam_api_common_290AnonymousEnum Isteamnetworkingsocketscallbacks = __AnonymousCppEnum_steam_api_common_290AnonymousEnum.Isteamnetworkingsocketscallbacks;

        public enum __AnonymousCppEnum_steam_api_common_343AnonymousEnum : int
        {
            Isteamnetworkingmessagescallbacks = unchecked((int)1250),
        }

        public const Native.__AnonymousCppEnum_steam_api_common_343AnonymousEnum Isteamnetworkingmessagescallbacks = __AnonymousCppEnum_steam_api_common_343AnonymousEnum.Isteamnetworkingmessagescallbacks;

        public enum __AnonymousCppEnum_steam_api_common_397AnonymousEnum : int
        {
            Isteamnetworkingutilscallbacks = unchecked((int)1280),
        }

        public const Native.__AnonymousCppEnum_steam_api_common_397AnonymousEnum Isteamnetworkingutilscallbacks = __AnonymousCppEnum_steam_api_common_397AnonymousEnum.Isteamnetworkingutilscallbacks;

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamIPAddress_t
        {
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamIPAddress_tunion
            {
                /// <summary>
                /// Host order
                /// </summary>
                [FieldOffset(0)]
                public uint m_unIPv4;

                /// <summary>
                /// Network order! Same as inaddr_in6.  (0011:2233:4455:6677:8899:aabb:ccdd:eeff)
                /// </summary>
                [FieldOffset(0)]
                public fixed byte m_rgubIPv6[16];

                /// <summary>
                /// big endian
                /// </summary>
                [FieldOffset(0)]
                public fixed ulong m_ipv6Qword[2];
            }

            public Native.ESteamIPType m_eType;
        }

        /// <summary>
        /// Steam ID structure (64 bits total)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct CSteamID
        {
            /// <summary>
            /// 64 bits total
            /// </summary>
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct SteamID_t
            {
                [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
                public partial struct SteamIDComponent_t
                {
                    private uint __bitfield__0;

                    /// <summary>
                    /// unique account identifier
                    /// </summary>
                    public uint m_unAccountID
                    {
                        get
                        {
                            return unchecked((uint)((__bitfield__0 >> 0) & 0b11111111111111111111111111111111));
                        }
                        set
                        {
                            __bitfield__0 = (__bitfield__0 & unchecked((uint)0b00000000000000000000000000000000)) | ((((uint)value) & (unchecked((uint)0b11111111111111111111111111111111)) << 0));
                        }
                    }

                    private uint __bitfield__2;

                    /// <summary>
                    /// dynamic instance ID
                    /// </summary>
                    public uint m_unAccountInstance
                    {
                        get
                        {
                            return unchecked((uint)((__bitfield__2 >> 0) & 0b11111111111111111111));
                        }
                        set
                        {
                            __bitfield__2 = (__bitfield__2 & unchecked((uint)0b11111111111100000000000000000000)) | ((((uint)value) & (unchecked((uint)0b11111111111111111111)) << 0));
                        }
                    }

                    /// <summary>
                    /// type of account - can't show as EAccountType, due to signed / unsigned difference
                    /// </summary>
                    public uint m_EAccountType
                    {
                        get
                        {
                            return unchecked((uint)((__bitfield__2 >> 20) & 0b1111));
                        }
                        set
                        {
                            __bitfield__2 = (__bitfield__2 & unchecked((uint)0b11111111000011111111111111111111)) | ((((uint)value) & (unchecked((uint)0b1111)) << 20));
                        }
                    }

                    /// <summary>
                    /// universe this account belongs to
                    /// </summary>
                    public Native.EUniverse m_EUniverse
                    {
                        get
                        {
                            return unchecked((Native.EUniverse)((__bitfield__2 >> 24) & 0b11111111));
                        }
                        set
                        {
                            __bitfield__2 = (__bitfield__2 & unchecked((uint)0b00000000111111111111111111111111)) | ((((uint)value) & (unchecked((uint)0b11111111)) << 24));
                        }
                    }
                }

                [FieldOffset(0)]
                public Native.CSteamID.SteamID_t.SteamIDComponent_t m_comp;

                [FieldOffset(0)]
                public ulong m_unAll64Bits;
            }

            public Native.CSteamID.SteamID_t m_steamid;
        }

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: encapsulates an appID/modID pair
        /// -----------------------------------------------------------------------------
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct CGameID
        {
            /// <summary>
            /// Internal stuff.  Use the accessors above if possible
            /// </summary>
            public enum EGameIDType : int
            {
                Egameidtypeapp = unchecked((int)0),

                Egameidtypegamemod = unchecked((int)1),

                Egameidtypeshortcut = unchecked((int)2),

                Egameidtypep2p = unchecked((int)3),
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public partial struct GameID_t
            {
                private uint __bitfield__0;

                public uint m_nAppID
                {
                    get
                    {
                        return unchecked((uint)((__bitfield__0 >> 0) & 0b111111111111111111111111));
                    }
                    set
                    {
                        __bitfield__0 = (__bitfield__0 & unchecked((uint)0b11111111000000000000000000000000)) | ((((uint)value) & (unchecked((uint)0b111111111111111111111111)) << 0));
                    }
                }

                public uint m_nType
                {
                    get
                    {
                        return unchecked((uint)((__bitfield__0 >> 24) & 0b11111111));
                    }
                    set
                    {
                        __bitfield__0 = (__bitfield__0 & unchecked((uint)0b00000000111111111111111111111111)) | ((((uint)value) & (unchecked((uint)0b11111111)) << 24));
                    }
                }

                private uint __bitfield__3;

                public uint m_nModID
                {
                    get
                    {
                        return unchecked((uint)((__bitfield__3 >> 0) & 0b11111111111111111111111111111111));
                    }
                    set
                    {
                        __bitfield__3 = (__bitfield__3 & unchecked((uint)0b00000000000000000000000000000000)) | ((((uint)value) & (unchecked((uint)0b11111111111111111111111111111111)) << 0));
                    }
                }
            }

            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct CGameIDunion
            {
                [FieldOffset(0)]
                public ulong m_ulGameID;

                [FieldOffset(0)]
                public Native.CGameID.GameID_t m_gameID;
            }
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ValvePackingSentinel_t
        {
            public uint m_u32;

            public ulong m_u64;

            public ushort m_u16;

            public double m_d;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramRelayAuthTicket : IEquatable<SteamDatagramRelayAuthTicket>
        {
            private readonly IntPtr _handle;

            public SteamDatagramRelayAuthTicket(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(SteamDatagramRelayAuthTicket other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is SteamDatagramRelayAuthTicket other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(SteamDatagramRelayAuthTicket left, SteamDatagramRelayAuthTicket right) => left.Equals(right);

            public static bool operator !=(SteamDatagramRelayAuthTicket left, SteamDatagramRelayAuthTicket right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramHostedAddress : IEquatable<SteamDatagramHostedAddress>
        {
            private readonly IntPtr _handle;

            public SteamDatagramHostedAddress(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(SteamDatagramHostedAddress other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is SteamDatagramHostedAddress other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(SteamDatagramHostedAddress left, SteamDatagramHostedAddress right) => left.Equals(right);

            public static bool operator !=(SteamDatagramHostedAddress left, SteamDatagramHostedAddress right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramGameCoordinatorServerLogin : IEquatable<SteamDatagramGameCoordinatorServerLogin>
        {
            private readonly IntPtr _handle;

            public SteamDatagramGameCoordinatorServerLogin(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(SteamDatagramGameCoordinatorServerLogin other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is SteamDatagramGameCoordinatorServerLogin other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(SteamDatagramGameCoordinatorServerLogin left, SteamDatagramGameCoordinatorServerLogin right) => left.Equals(right);

            public static bool operator !=(SteamDatagramGameCoordinatorServerLogin left, SteamDatagramGameCoordinatorServerLogin right) => !left.Equals(right);
        }

        /// <summary>
        /// This callback is posted whenever a connection is created, destroyed, or changes state.
        /// The m_info field will contain a complete description of the connection at the time the
        /// change occurred and the callback was posted.  In particular, m_eState will have the
        /// new connection state.
        /// </summary>
        /// <remarks>
        /// You will usually need to listen for this callback to know when:
        /// - A new connection arrives on a listen socket.
        /// m_info.m_hListenSocket will be set, m_eOldState = k_ESteamNetworkingConnectionState_None,
        /// and m_info.m_eState = k_ESteamNetworkingConnectionState_Connecting.
        /// See ISteamNetworkigSockets::AcceptConnection.
        /// - A connection you initiated has been accepted by the remote host.
        /// m_eOldState = k_ESteamNetworkingConnectionState_Connecting, and
        /// m_info.m_eState = k_ESteamNetworkingConnectionState_Connected.
        /// Some connections might transition to k_ESteamNetworkingConnectionState_FindingRoute first.
        /// - A connection has been actively rejected or closed by the remote host.
        /// m_eOldState = k_ESteamNetworkingConnectionState_Connecting or k_ESteamNetworkingConnectionState_Connected,
        /// and m_info.m_eState = k_ESteamNetworkingConnectionState_ClosedByPeer.  m_info.m_eEndReason
        /// and m_info.m_szEndDebug will have for more details.
        /// NOTE: upon receiving this callback, you must still destroy the connection using
        /// ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details
        /// passed to the function are not used in this case, since the connection is already closed.)
        /// - A problem was detected with the connection, and it has been closed by the local host.
        /// The most common failure is timeout, but other configuration or authentication failures
        /// can cause this.  m_eOldState = k_ESteamNetworkingConnectionState_Connecting or
        /// k_ESteamNetworkingConnectionState_Connected, and m_info.m_eState = k_ESteamNetworkingConnectionState_ProblemDetectedLocally.
        /// m_info.m_eEndReason and m_info.m_szEndDebug will have for more details.
        /// NOTE: upon receiving this callback, you must still destroy the connection using
        /// ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details
        /// passed to the function are not used in this case, since the connection is already closed.)Remember that callbacks are posted to a queue, and networking connections can
        /// change at any time.  It is possible that the connection has already changed
        /// state by the time you process this callback.Also note that callbacks will be posted when connections are created and destroyed by your own API calls.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetConnectionStatusChangedCallback_t
        {
            public enum SteamNetConnectionStatusChangedCallback_tAnonymousEnum : int
            {
                Icallback = unchecked((int)Isteamnetworkingsocketscallbacks + 1),
            }

            /// <summary>
            /// Connection handle
            /// </summary>
            public uint m_hConn;

            /// <summary>
            /// Full connection info
            /// </summary>
            public Native.SteamNetConnectionInfo_t m_info;

            /// <summary>
            /// Previous state.  (Current state is in m_info.m_eState)
            /// </summary>
            public Native.ESteamNetworkingConnectionState m_eOldState;
        }

        /// <summary>
        /// Describe the state of a connection.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetConnectionInfo_t
        {
            /// <summary>
            /// Who is on the other end?  Depending on the connection type and phase of the connection, we might not know
            /// </summary>
            public Native.SteamNetworkingIdentity m_identityRemote;

            /// <summary>
            /// Arbitrary user data set by the local application code
            /// </summary>
            public long m_nUserData;

            /// <summary>
            /// Handle to listen socket this was connected on, or k_HSteamListenSocket_Invalid if we initiated the connection
            /// </summary>
            public uint m_hListenSocket;

            /// <summary>
            /// Remote address.  Might be all 0's if we don't know it, or if this is N/A.
            /// (E.g. Basically everything except direct UDP connection.)
            /// </summary>
            public Native.SteamNetworkingIPAddr m_addrRemote;

            public ushort m__pad1;

            /// <summary>
            /// What data center is the remote host in?  (0 if we don't know.)
            /// </summary>
            public uint m_idPOPRemote;

            /// <summary>
            /// What relay are we using to communicate with the remote host?
            /// (0 if not applicable.)
            /// </summary>
            public uint m_idPOPRelay;

            /// <summary>
            /// High level state of the connection
            /// </summary>
            public Native.ESteamNetworkingConnectionState m_eState;

            /// <summary>
            /// Basic cause of the connection termination or problem.
            /// See ESteamNetConnectionEnd for the values used
            /// </summary>
            public int m_eEndReason;

            /// <summary>
            /// Human-readable, but non-localized explanation for connection
            /// termination or problem.  This is intended for debugging /
            /// diagnostic purposes only, not to display to users.  It might
            /// have some details specific to the issue.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string m_szEndDebug;

            /// <summary>
            /// Debug description.  This includes the internal connection ID,
            /// connection type (and peer information), and any name
            /// given to the connection by the app.  This string is used in various
            /// internal logging messages.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string m_szConnectionDescription;

            /// <summary>
            /// Misc flags.  Bitmask of k_nSteamNetworkConnectionInfoFlags_Xxxx
            /// </summary>
            public int m_nFlags;

            /// <summary>
            /// Internal stuff, room to change API easily
            /// </summary>
            public fixed uint reserved[63];
        }

        /// <summary>
        /// An abstract way to represent the identity of a network host.  All identities can
        /// be represented as simple string.  Furthermore, this string representation is actually
        /// used on the wire in several places, even though it is less efficient, in order to
        /// facilitate forward compatibility.  (Old client code can handle an identity type that
        /// it doesn't understand.)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIdentity
        {
            /// <summary>
            /// Max sizes
            /// </summary>
            public enum SteamNetworkingIdentityAnonymousEnum : int
            {
                /// <summary>
                /// Max length of the buffer needed to hold any identity, formatted in string format by ToString
                /// </summary>
                Cchmaxstring = unchecked((int)128),

                /// <summary>
                /// Max length of the string for generic string identities.  Including terminating '
                /// \
                /// 0'
                /// </summary>
                Cchmaxgenericstring = unchecked((int)32),

                Cbmaxgenericbytes = unchecked((int)32),
            }

            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamNetworkingIdentityUnion
            {
                [FieldOffset(0)]
                public ulong m_steamID64;

                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
                public string m_szGenericString;

                [FieldOffset(0)]
                public fixed byte m_genericBytes[32];

                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
                public string m_szUnknownRawString;

                [FieldOffset(0)]
                public Native.SteamNetworkingIPAddr m_ip;

                /// <summary>
                /// Pad structure to leave easy room for future expansion
                /// </summary>
                [FieldOffset(0)]
                public fixed uint m_reserved[32];
            }

            /// <summary>
            /// Type of identity.
            /// </summary>
            public Native.ESteamNetworkingIdentityType m_eType;

            /// <summary>
            /// Internal representation.  Don't access this directly, use the accessors!
            /// </summary>
            /// <remarks>
            /// Number of bytes that are relevant below.  This MUST ALWAYS be
            /// set.  (Use the accessors!)  This is important to enable old code to work
            /// with new identity types.
            /// </remarks>
            public int m_cbSize;
        }

        /// <summary>
        /// Store an IP and port.  IPv6 is always used; IPv4 is represented using
        /// "IPv4-mapped" addresses: IPv4 aa.bb.cc.dd =&gt; IPv6 ::ffff:aabb:ccdd
        /// (RFC 4291 section 2.5.5.2.)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIPAddr
        {
            /// <summary>
            /// Max length of the buffer needed to hold IP formatted using ToString, including '
            /// \
            /// 0'
            /// ([0123:4567:89ab:cdef:0123:4567:89ab:cdef]:12345)
            /// </summary>
            public enum SteamNetworkingIPAddrAnonymousEnum : int
            {
                Cchmaxstring = unchecked((int)48),
            }

            /// <summary>
            /// RFC4038, section 4.2
            /// </summary>
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public unsafe partial struct IPv4MappedAddress
            {
                public ulong m_8zeros;

                public ushort m_0000;

                public ushort m_ffff;

                /// <summary>
                /// NOTE: As bytes, i.e. network byte order
                /// </summary>
                public fixed byte m_ip[4];
            }

            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamNetworkingIPAddrunion
            {
                [FieldOffset(0)]
                public fixed byte m_ipv6[16];

                [FieldOffset(0)]
                public Native.SteamNetworkingIPAddr.IPv4MappedAddress m_ipv4;
            }

            /// <summary>
            /// Host byte order
            /// </summary>
            public ushort m_port;
        }

        /// <summary>
        /// A struct used to describe our readiness to participate in authenticated,
        /// encrypted communication.  In order to do this we need:
        /// </summary>
        /// <remarks>
        /// - The list of trusted CA certificates that might be relevant for this
        /// app.
        /// - A valid certificate issued by a CA.This callback is posted whenever the state of our readiness changes.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetAuthenticationStatus_t
        {
            public enum SteamNetAuthenticationStatus_tAnonymousEnum : int
            {
                Icallback = unchecked((int)Isteamnetworkingsocketscallbacks + 2),
            }

            /// <summary>
            /// Status
            /// </summary>
            public Native.ESteamNetworkingAvailability m_eAvail;

            /// <summary>
            /// Non-localized English language status.  For diagnostic/debugging
            /// purposes only.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string m_debugMsg;
        }

        /// <summary>
        /// A struct used to describe our readiness to use the relay network.
        /// To do this we first need to fetch the network configuration,
        /// which describes what POPs are available.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamRelayNetworkStatus_t
        {
            public enum SteamRelayNetworkStatus_tAnonymousEnum : int
            {
                Icallback = unchecked((int)Isteamnetworkingsocketscallbacks + 1),
            }

            /// <summary>
            /// Summary status.  When this is "current", initialization has
            /// completed.  Anything else means you are not ready yet, or
            /// there is a significant problem.
            /// </summary>
            public Native.ESteamNetworkingAvailability m_eAvail;

            /// <summary>
            /// Nonzero if latency measurement is in progress (or pending,
            /// awaiting a prerequisite).
            /// </summary>
            public int m_bPingMeasurementInProgress;

            /// <summary>
            /// Status obtaining the network config.  This is a prerequisite
            /// for relay network access.
            /// </summary>
            /// <remarks>
            /// Failure to obtain the network config almost always indicates
            /// a problem with the local internet connection.
            /// </remarks>
            public Native.ESteamNetworkingAvailability m_eAvailNetworkConfig;

            /// <summary>
            /// Current ability to communicate with ANY relay.  Note that
            /// the complete failure to communicate with any relays almost
            /// always indicates a problem with the local Internet connection.
            /// (However, just because you can reach a single relay doesn't
            /// mean that the local connection is in perfect health.)
            /// </summary>
            public Native.ESteamNetworkingAvailability m_eAvailAnyRelay;

            /// <summary>
            /// Non-localized English language status.  For diagnostic/debugging
            /// purposes only.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string m_debugMsg;
        }

        /// <summary>
        /// Posted when a remote host is sending us a message, and we do not already have a session with them
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingMessagesSessionRequest_t
        {
            public enum SteamNetworkingMessagesSessionRequest_tAnonymousEnum : int
            {
                Icallback = unchecked((int)Isteamnetworkingsocketscallbacks + 1),
            }

            /// <summary>
            /// user who wants to talk to us
            /// </summary>
            public Native.SteamNetworkingIdentity m_identityRemote;
        }

        /// <summary>
        /// Posted when we fail to establish a connection, or we detect that communications
        /// have been disrupted it an unusual way.  There is no notification when a peer proactively
        /// closes the session.  ("Closed by peer" is not a concept of UDP-style communications, and
        /// SteamNetworkingMessages is primarily intended to make porting UDP code easy.)
        /// </summary>
        /// <remarks>
        /// Remember: callbacks are asynchronous.   See notes on SendMessageToUser,
        /// and k_nSteamNetworkingSend_AutoRestartBrokenSession in particular.Also, if a session times out due to inactivity, no callbacks will be posted.  The only
        /// way to detect that this is happening is that querying the session state may return
        /// none, connecting, and findingroute again.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingMessagesSessionFailed_t
        {
            public enum SteamNetworkingMessagesSessionFailed_tAnonymousEnum : int
            {
                Icallback = unchecked((int)Isteamnetworkingsocketscallbacks + 2),
            }

            /// <summary>
            /// Detailed info about the session that failed.
            /// SteamNetConnectionInfo_t::m_identityRemote indicates who this session
            /// was with.
            /// </summary>
            public Native.SteamNetConnectionInfo_t m_info;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamNetworkingFakeIPResult_t : IEquatable<SteamNetworkingFakeIPResult_t>
        {
            private readonly IntPtr _handle;

            public SteamNetworkingFakeIPResult_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(SteamNetworkingFakeIPResult_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is SteamNetworkingFakeIPResult_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(SteamNetworkingFakeIPResult_t left, SteamNetworkingFakeIPResult_t right) => left.Equals(right);

            public static bool operator !=(SteamNetworkingFakeIPResult_t left, SteamNetworkingFakeIPResult_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Quick connection state, pared down to something you could call
        /// more frequently without it being too big of a perf hit.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetworkingQuickConnectionStatus
        {
            /// <summary>
            /// High level state of the connection
            /// </summary>
            public Native.ESteamNetworkingConnectionState m_eState;

            /// <summary>
            /// Current ping (ms)
            /// </summary>
            public int m_nPing;

            /// <summary>
            /// Connection quality measured locally, 0...1.  (Percentage of packets delivered
            /// end-to-end in order).
            /// </summary>
            public float m_flConnectionQualityLocal;

            /// <summary>
            /// Packet delivery success rate as observed from remote host
            /// </summary>
            public float m_flConnectionQualityRemote;

            /// <summary>
            /// Current data rates from recent history.
            /// </summary>
            public float m_flOutPacketsPerSec;

            public float m_flOutBytesPerSec;

            public float m_flInPacketsPerSec;

            public float m_flInBytesPerSec;

            /// <summary>
            /// Estimate rate that we believe that we can send data to our peer.
            /// Note that this could be significantly higher than m_flOutBytesPerSec,
            /// meaning the capacity of the channel is higher than you are sending data.
            /// (That's OK!)
            /// </summary>
            public int m_nSendRateBytesPerSecond;

            /// <summary>
            /// Number of bytes pending to be sent.  This is data that you have recently
            /// requested to be sent but has not yet actually been put on the wire.  The
            /// reliable number ALSO includes data that was previously placed on the wire,
            /// but has now been scheduled for re-transmission.  Thus, it's possible to
            /// observe m_cbPendingReliable increasing between two checks, even if no
            /// calls were made to send reliable data between the checks.  Data that is
            /// awaiting the Nagle delay will appear in these numbers.
            /// </summary>
            public int m_cbPendingUnreliable;

            public int m_cbPendingReliable;

            /// <summary>
            /// Number of bytes of reliable data that has been placed the wire, but
            /// for which we have not yet received an acknowledgment, and thus we may
            /// have to re-transmit.
            /// </summary>
            public int m_cbSentUnackedReliable;

            /// <summary>
            /// If you asked us to send a message right now, how long would that message
            /// sit in the queue before we actually started putting packets on the wire?
            /// (And assuming Nagle does not cause any packets to be delayed.)
            /// </summary>
            /// <remarks>
            /// In general, data that is sent by the application is limited by the
            /// bandwidth of the channel.  If you send data faster than this, it must
            /// be queued and put on the wire at a metered rate.  Even sending a small amount
            /// of data (e.g. a few MTU, say ~3k) will require some of the data to be delayed
            /// a bit.In general, the estimated delay will be approximately equal to( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecondplus or minus one MTU.  It depends on how much time has elapsed since the last
            /// packet was put on the wire.  For example, the queue might have *just* been emptied,
            /// and the last packet placed on the wire, and we are exactly up against the send
            /// rate limit.  In that case we might need to wait for one packet's worth of time to
            /// elapse before we can send again.  On the other extreme, the queue might have data
            /// in it waiting for Nagle.  (This will always be less than one packet, because as soon
            /// as we have a complete packet we would send it.)  In that case, we might be ready
            /// to send data now, and this value will be 0.
            /// </remarks>
            public long m_usecQueueTime;

            /// <summary>
            /// Internal stuff, room to change API easily
            /// </summary>
            public fixed uint reserved[16];
        }

        /// <summary>
        /// A message that has been received.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingMessage_t
        {
            /// <summary>
            /// Message payload
            /// </summary>
            public IntPtr m_pData;

            /// <summary>
            /// Size of the payload.
            /// </summary>
            public int m_cbSize;

            /// <summary>
            /// For messages received on connections: what connection did this come from?
            /// For outgoing messages: what connection to send it to?
            /// Not used when using the ISteamNetworkingMessages interface
            /// </summary>
            public uint m_conn;

            /// <summary>
            /// For inbound messages: Who sent this to us?
            /// For outbound messages on connections: not used.
            /// For outbound messages on the ad-hoc ISteamNetworkingMessages interface: who should we send this to?
            /// </summary>
            public Native.SteamNetworkingIdentity m_identityPeer;

            /// <summary>
            /// For messages received on connections, this is the user data
            /// associated with the connection.
            /// </summary>
            /// <remarks>
            /// This is *usually* the same as calling GetConnection() and then
            /// fetching the user data associated with that connection, but for
            /// the following subtle differences:- This user data will match the connection's user data at the time
            /// is captured at the time the message is returned by the API.
            /// If you subsequently change the userdata on the connection,
            /// this won't be updated.
            /// - This is an inline call, so it's *much* faster.
            /// - You might have closed the connection, so fetching the user data
            /// would not be possible.Not used when sending messages,
            /// </remarks>
            public long m_nConnUserData;

            /// <summary>
            /// Local timestamp when the message was received
            /// Not used for outbound messages.
            /// </summary>
            public long m_usecTimeReceived;

            /// <summary>
            /// Message number assigned by the sender.
            /// This is not used for outbound messages
            /// </summary>
            public long m_nMessageNumber;

            /// <summary>
            /// Function used to free up m_pData.  This mechanism exists so that
            /// apps can create messages with buffers allocated from their own
            /// heap, and pass them into the library.  This function will
            /// usually be something like:
            /// </summary>
            /// <remarks>
            /// free( pMsg-&gt;m_pData );
            /// </remarks>
            public Native.SteamNetworkingMessage_t.m_pfnFreeDatadelegate m_pfnFreeData;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void m_pfnFreeDatadelegate(ref Native.SteamNetworkingMessage_t pMsg);

            /// <summary>
            /// Function to used to decrement the internal reference count and, if
            /// it's zero, release the message.  You should not set this function pointer,
            /// or need to access this directly!  Use the Release() function instead!
            /// </summary>
            public Native.SteamNetworkingMessage_t.m_pfnReleasedelegate m_pfnRelease;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void m_pfnReleasedelegate(ref Native.SteamNetworkingMessage_t pMsg);

            /// <summary>
            /// When using ISteamNetworkingMessages, the channel number the message was received on
            /// (Not used for messages sent or received on "connections")
            /// </summary>
            public int m_nChannel;

            /// <summary>
            /// Bitmask of k_nSteamNetworkingSend_xxx flags.
            /// For received messages, only the k_nSteamNetworkingSend_Reliable bit is valid.
            /// For outbound messages, all bits are relevant
            /// </summary>
            public int m_nFlags;

            /// <summary>
            /// Arbitrary user data that you can use when sending messages using
            /// ISteamNetworkingUtils::AllocateMessage and ISteamNetworkingSockets::SendMessage.
            /// (The callback you set in m_pfnFreeData might use this field.)
            /// </summary>
            /// <remarks>
            /// Not used for received messages.
            /// </remarks>
            public long m_nUserData;
        }

        /// <summary>
        /// Object that describes a "location" on the Internet with sufficient
        /// detail that we can reasonably estimate an upper bound on the ping between
        /// the two hosts, even if a direct route between the hosts is not possible,
        /// and the connection must be routed through the Steam Datagram Relay network.
        /// This does not contain any information that identifies the host.  Indeed,
        /// if two hosts are in the same building or otherwise have nearly identical
        /// networking characteristics, then it's valid to use the same location
        /// object for both of them.
        /// </summary>
        /// <remarks>
        /// NOTE: This object should only be used in the same process!  Do not serialize it,
        /// send it over the wire, or persist it in a file or database!  If you need
        /// to do that, convert it to a string representation using the methods in
        /// ISteamNetworkingUtils().
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetworkPingLocation_t
        {
            public fixed byte m_data[512];
        }

        /// <summary>
        /// In a few places we need to set configuration options on listen sockets and connections, and
        /// have them take effect *before* the listen socket or connection really starts doing anything.
        /// Creating the object and then setting the options "immediately" after creation doesn't work
        /// completely, because network packets could be received between the time the object is created and
        /// when the options are applied.  To set options at creation time in a reliable way, they must be
        /// passed to the creation function.  This structure is used to pass those options.
        /// </summary>
        /// <remarks>
        /// For the meaning of these fields, see ISteamNetworkingUtils::SetConfigValue.  Basically
        /// when the object is created, we just iterate over the list of options and call
        /// ISteamNetworkingUtils::SetConfigValueStruct, where the scope arguments are supplied by the
        /// object being created.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingConfigValue_t
        {
            /// <summary>
            /// Option value
            /// </summary>
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct SteamNetworkingConfigValue_t_union_m_val
            {
                [FieldOffset(0)]
                public int m_int32;

                [FieldOffset(0)]
                public long m_int64;

                [FieldOffset(0)]
                public float m_float;

                /// <summary>
                /// Points to your '
                /// \
                /// 0'-terminated buffer
                /// </summary>
                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.LPStr)]
                public string m_string;

                [FieldOffset(0)]
                public IntPtr m_ptr;
            }

            /// <summary>
            /// Which option is being set
            /// </summary>
            public Native.ESteamNetworkingConfigValue m_eValue;

            /// <summary>
            /// Which field below did you fill in?
            /// </summary>
            public Native.ESteamNetworkingConfigDataType m_eDataType;

            public Native.SteamNetworkingConfigValue_t.SteamNetworkingConfigValue_t_union_m_val m_val;
        }

        /// <summary>
        /// Utility class for printing a SteamNetworkingPOPID.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingPOPIDRender
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)]
            public string buf;
        }

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// The non-connection-oriented interface to send and receive messages
        /// (whether they be "clients" or "servers").
        /// </summary>
        /// <remarks>
        /// ISteamNetworkingSockets is connection-oriented (like TCP), meaning you
        /// need to listen and connect, and then you send messages using a connection
        /// handle.  ISteamNetworkingMessages is more like UDP, in that you can just send
        /// messages to arbitrary peers at any time.  The underlying connections are
        /// established implicitly.Under the hood ISteamNetworkingMessages works on top of the ISteamNetworkingSockets
        /// code, so you get the same routing and messaging efficiency.  The difference is
        /// mainly in your responsibility to explicitly establish a connection and
        /// the type of feedback you get about the state of the connection.  Both
        /// interfaces can do "P2P" communications, and both support both unreliable
        /// and reliable messages, fragmentation and reassembly.The primary purpose of this interface is to be "like UDP", so that UDP-based code
        /// can be ported easily to take advantage of relayed connections.  If you find
        /// yourself needing more low level information or control, or to be able to better
        /// handle failure, then you probably need to use ISteamNetworkingSockets directly.
        /// Also, note that if your main goal is to obtain a connection between two peers
        /// without concerning yourself with assigning roles of "client" and "server",
        /// you may find the symmetric connection mode of ISteamNetworkingSockets useful.
        /// (See k_ESteamNetworkingConfig_SymmetricConnect.)
        /// </remarks>
        public interface ISteamNetworkingMessages
        {
            /// <summary>
            /// Sends a message to the specified host.  If we don't already have a session with that user,
            /// a session is implicitly created.  There might be some handshaking that needs to happen
            /// before we can actually begin sending message data.  If this handshaking fails and we can't
            /// get through, an error will be posted via the callback SteamNetworkingMessagesSessionFailed_t.
            /// There is no notification when the operation succeeds.  (You should have the peer send a reply
            /// for this purpose.)
            /// </summary>
            /// <remarks>
            /// Sending a message to a host will also implicitly accept any incoming connection from that host.nSendFlags is a bitmask of k_nSteamNetworkingSend_xxx optionsnRemoteChannel is a routing number you can use to help route message to different systems.
            /// You'll have to call ReceiveMessagesOnChannel() with the same channel number in order to retrieve
            /// the data on the other end.Using different channels to talk to the same user will still use the same underlying
            /// connection, saving on resources.  If you don't need this feature, use 0.
            /// Otherwise, small integers are the most efficient.It is guaranteed that reliable messages to the same host on the same channel
            /// will be be received by the remote host (if they are received at all) exactly once,
            /// and in the same order that they were sent.NO other order guarantees exist!  In particular, unreliable messages may be dropped,
            /// received out of order with respect to each other and with respect to reliable data,
            /// or may be received multiple times.  Messages on different channels are *not* guaranteed
            /// to be received in the order they were sent.A note for those familiar with TCP/IP ports, or converting an existing codebase that
            /// opened multiple sockets:  You might notice that there is only one channel, and with
            /// TCP/IP each endpoint has a port number.  You can think of the channel number as the
            /// *destination* port.  If you need each message to also include a "source port" (so the
            /// recipient can route the reply), then just put that in your message.  That is essentially
            /// how UDP works!Returns:
            /// - k_EREsultOK on success.
            /// - k_EResultNoConnection, if the session has failed or was closed by the peer and
            /// k_nSteamNetworkingSend_AutoRestartBrokenSession was not specified.  (You can
            /// use GetSessionConnectionInfo to get the details.)  In order to acknowledge the
            /// broken session and start a new one, you must call CloseSessionWithUser, or you may
            /// repeat the call with k_nSteamNetworkingSend_AutoRestartBrokenSession.  See
            /// k_nSteamNetworkingSend_AutoRestartBrokenSession for more details.
            /// - See ISteamNetworkingSockets::SendMessageToConnection for more possible return values
            /// </remarks>
            Native.EResult SendMessageToUser(ref Native.SteamNetworkingIdentity identityRemote, IntPtr pubData, uint cubData, int nSendFlags, int nRemoteChannel);

            /// <summary>
            /// Reads the next message that has been sent from another user via SendMessageToUser() on the given channel.
            /// Returns number of messages returned into your list.  (0 if no message are available on that channel.)
            /// </summary>
            /// <remarks>
            /// When you're done with the message object(s), make sure and call SteamNetworkingMessage_t::Release()!
            /// </remarks>
            int ReceiveMessagesOnChannel(int nLocalChannel, out IntPtr ppOutMessages, int nMaxMessages);

            /// <summary>
            /// Call this in response to a SteamNetworkingMessagesSessionRequest_t callback.
            /// SteamNetworkingMessagesSessionRequest_t are posted when a user tries to send you a message,
            /// and you haven't tried to talk to them first.  If you don't want to talk to them, just ignore
            /// the request.  If the user continues to send you messages, SteamNetworkingMessagesSessionRequest_t
            /// callbacks will continue to be posted periodically.
            /// </summary>
            /// <remarks>
            /// Returns false if there is no session with the user pending or otherwise.  If there is an
            /// existing active session, this function will return true, even if it is not pending.Calling SendMessageToUser() will implicitly accepts any pending session request to that user.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool AcceptSessionWithUser(ref Native.SteamNetworkingIdentity identityRemote);

            /// <summary>
            /// Call this when you're done talking to a user to immediately free up resources under-the-hood.
            /// If the remote user tries to send data to you again, another SteamNetworkingMessagesSessionRequest_t
            /// callback will be posted.
            /// </summary>
            /// <remarks>
            /// Note that sessions that go unused for a few minutes are automatically timed out.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool CloseSessionWithUser(ref Native.SteamNetworkingIdentity identityRemote);

            /// <summary>
            /// Call this  when you're done talking to a user on a specific channel.  Once all
            /// open channels to a user have been closed, the open session to the user will be
            /// closed, and any new data from this user will trigger a
            /// SteamSteamNetworkingMessagesSessionRequest_t callback
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool CloseChannelWithUser(ref Native.SteamNetworkingIdentity identityRemote, int nLocalChannel);

            /// <summary>
            /// Returns information about the latest state of a connection, if any, with the given peer.
            /// Primarily intended for debugging purposes, but can also be used to get more detailed
            /// failure information.  (See SendMessageToUser and k_nSteamNetworkingSend_AutoRestartBrokenSession.)
            /// </summary>
            /// <remarks>
            /// Returns the value of SteamNetConnectionInfo_t::m_eState, or k_ESteamNetworkingConnectionState_None
            /// if no connection exists with specified peer.  You may pass nullptr for either parameter if
            /// you do not need the corresponding details.  Note that sessions time out after a while,
            /// so if a connection fails, or SendMessageToUser returns k_EResultNoConnection, you cannot wait
            /// indefinitely to obtain the reason for failure.
            /// </remarks>
            Native.ESteamNetworkingConnectionState GetSessionConnectionInfo(ref Native.SteamNetworkingIdentity identityRemote, ref Native.SteamNetConnectionInfo_t pConnectionInfo, ref Native.SteamNetworkingQuickConnectionStatus pQuickStatus);
        }

        /// <summary>
        /// Interface used to send signaling messages for a particular connection.
        /// </summary>
        /// <remarks>
        /// - For connections initiated locally, you will construct it and pass
        /// it to ISteamNetworkingSockets::ConnectP2PCustomSignaling.
        /// - For connections initiated remotely and "accepted" locally, you
        /// will return it from ISteamNetworkingSignalingRecvContext::OnConnectRequest
        /// </remarks>
        public interface ISteamNetworkingConnectionSignaling
        {
            /// <summary>
            /// Called to send a rendezvous message to the remote peer.  This may be called
            /// from any thread, at any time, so you need to be thread-safe!  Don't take
            /// any locks that might hold while calling into SteamNetworkingSockets functions,
            /// because this could lead to deadlocks.
            /// </summary>
            /// <remarks>
            /// Note that when initiating a connection, we may not know the identity
            /// of the peer, if you did not specify it in ConnectP2PCustomSignaling.Return true if a best-effort attempt was made to deliver the message.
            /// If you return false, it is assumed that the situation is fatal;
            /// the connection will be closed, and Release() will be called
            /// eventually.Signaling objects will not be shared between connections.
            /// You can assume that the same value of hConn will be used
            /// every time.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool SendSignal(uint hConn, ref Native.SteamNetConnectionInfo_t info, IntPtr pMsg, int cbMsg);

            /// <summary>
            /// Called when the connection no longer needs to send signals.
            /// Note that this happens eventually (but not immediately) after
            /// the connection is closed.  Signals may need to be sent for a brief
            /// time after the connection is closed, to clean up the connection.
            /// </summary>
            /// <remarks>
            /// If you do not need to save any additional per-connection information
            /// and can handle SendSignal() using only the arguments supplied, you do
            /// not need to actually create different objects per connection.  In that
            /// case, it is valid for all connections to use the same global object, and
            /// for this function to do nothing.
            /// </remarks>
            void Release();
        }

        /// <summary>
        /// Interface used when a custom signal is received.
        /// See ISteamNetworkingSockets::ReceivedP2PCustomSignal
        /// </summary>
        public interface ISteamNetworkingSignalingRecvContext
        {
            /// <summary>
            /// Called when the signal represents a request for a new connection.
            /// </summary>
            /// <remarks>
            /// If you want to ignore the request, just return NULL.  In this case,
            /// the peer will NOT receive any reply.  You should consider ignoring
            /// requests rather than actively rejecting them, as a security measure.
            /// If you actively reject requests, then this makes it possible to detect
            /// if a user is online or not, just by sending them a request.If you wish to send back a rejection, then use
            /// ISteamNetworkingSockets::CloseConnection() and then return NULL.
            /// We will marshal a properly formatted rejection signal and
            /// call SendRejectionSignal() so you can send it to them.If you return a signaling object, the connection is NOT immediately
            /// accepted by default.  Instead, it stays in the "connecting" state,
            /// and the usual callback is posted, and your app can accept the
            /// connection using ISteamNetworkingSockets::AcceptConnection.  This
            /// may be useful so that these sorts of connections can be more similar
            /// to your application code as other types of connections accepted on
            /// a listen socket.  If this is not useful and you want to skip this
            /// callback process and immediately accept the connection, call
            /// ISteamNetworkingSockets::AcceptConnection before returning the
            /// signaling object.After accepting a connection (through either means), the connection
            /// will transition into the "finding route" state.
            /// </remarks>
            ref Native.ISteamNetworkingConnectionSignaling OnConnectRequest(uint hConn, ref Native.SteamNetworkingIdentity identityPeer, int nLocalVirtualPort);

            /// <summary>
            /// This is called to actively communicate rejection or failure
            /// to the incoming message.  If you intend to ignore all incoming requests
            /// that you do not wish to accept, then it's not strictly necessary to
            /// implement this.
            /// </summary>
            void SendRejectionSignal(ref Native.SteamNetworkingIdentity identityPeer, IntPtr pMsg, int cbMsg);
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ISteamNetworkingFakeUDPPort : IEquatable<ISteamNetworkingFakeUDPPort>
        {
            private readonly IntPtr _handle;

            public ISteamNetworkingFakeUDPPort(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(ISteamNetworkingFakeUDPPort other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is ISteamNetworkingFakeUDPPort other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(ISteamNetworkingFakeUDPPort left, ISteamNetworkingFakeUDPPort right) => left.Equals(right);

            public static bool operator !=(ISteamNetworkingFakeUDPPort left, ISteamNetworkingFakeUDPPort right) => !left.Equals(right);
        }

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Lower level networking API.
        /// </summary>
        /// <remarks>
        /// - Connection-oriented API (like TCP, not UDP).  When sending and receiving
        /// messages, a connection handle is used.  (For a UDP-style interface, where
        /// the peer is identified by their address with each send/recv call, see
        /// ISteamNetworkingMessages.)  The typical pattern is for a "server" to "listen"
        /// on a "listen socket."  A "client" will "connect" to the server, and the
        /// server will "accept" the connection.  If you have a symmetric situation
        /// where either peer may initiate the connection and server/client roles are
        /// not clearly defined, check out k_ESteamNetworkingConfig_SymmetricConnect.
        /// - But unlike TCP, it's message-oriented, not stream-oriented.
        /// - Mix of reliable and unreliable messages
        /// - Fragmentation and reassembly
        /// - Supports connectivity over plain UDP
        /// - Also supports SDR ("Steam Datagram Relay") connections, which are
        /// addressed by the identity of the peer.  There is a "P2P" use case and
        /// a "hosted dedicated server" use case.Note that neither of the terms "connection" nor "socket" necessarily correspond
        /// one-to-one with an underlying UDP socket.  An attempt has been made to
        /// keep the semantics as similar to the standard socket model when appropriate,
        /// but some deviations do exist.See also: ISteamNetworkingMessages, the UDP-style interface.  This API might be
        /// easier to use, especially when porting existing UDP code.
        /// </remarks>
        public interface ISteamNetworkingSockets
        {
            /// <summary>
            /// Creates a "server" socket that listens for clients to connect to by 
            /// calling ConnectByIPAddress, over ordinary UDP (IPv4 or IPv6)
            /// </summary>
            /// <remarks>
            /// You must select a specific local port to listen on and set it
            /// the port field of the local address.Usually you will set the IP portion of the address to zero (SteamNetworkingIPAddr::Clear()).
            /// This means that you will not bind to any particular local interface (i.e. the same
            /// as INADDR_ANY in plain socket code).  Furthermore, if possible the socket will be bound
            /// in "dual stack" mode, which means that it can accept both IPv4 and IPv6 client connections.
            /// If you really do wish to bind a particular interface, then set the local address to the
            /// appropriate IPv4 or IPv6 IP.If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.When a client attempts to connect, a SteamNetConnectionStatusChangedCallback_t
            /// will be posted.  The connection will be in the connecting state.
            /// </remarks>
            uint CreateListenSocketIP(ref Native.SteamNetworkingIPAddr localAddress, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

            /// <summary>
            /// Creates a connection and begins talking to a "server" over UDP at the
            /// given IPv4 or IPv6 address.  The remote host must be listening with a
            /// matching call to CreateListenSocketIP on the specified port.
            /// </summary>
            /// <remarks>
            /// A SteamNetConnectionStatusChangedCallback_t callback will be triggered when we start
            /// connecting, and then another one on either timeout or successful connection.If the server does not have any identity configured, then their network address
            /// will be the only identity in use.  Or, the network host may provide a platform-specific
            /// identity with or without a valid certificate to authenticate that identity.  (These
            /// details will be contained in the SteamNetConnectionStatusChangedCallback_t.)  It's
            /// up to your application to decide whether to allow the connection.By default, all connections will get basic encryption sufficient to prevent
            /// casual eavesdropping.  But note that without certificates (or a shared secret
            /// distributed through some other out-of-band mechanism), you don't have any
            /// way of knowing who is actually on the other end, and thus are vulnerable to
            /// man-in-the-middle attacks.If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint ConnectByIPAddress(ref Native.SteamNetworkingIPAddr address, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

            /// <summary>
            /// Like CreateListenSocketIP, but clients will connect using ConnectP2P.
            /// </summary>
            /// <remarks>
            /// nLocalVirtualPort specifies how clients can connect to this socket using
            /// ConnectP2P.  It's very common for applications to only have one listening socket;
            /// in that case, use zero.  If you need to open multiple listen sockets and have clients
            /// be able to connect to one or the other, then nLocalVirtualPort should be a small
            /// integer (
            /// &lt;
            /// 1000) unique to each listen socket you create.If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()
            /// when your app initializes.If you are listening on a dedicated servers in known data center,
            /// then you can listen using this function instead of CreateHostedDedicatedServerListenSocket,
            /// to allow clients to connect without a ticket.  Any user that owns
            /// the app and is signed into Steam will be able to attempt to connect to
            /// your server.  Also, a connection attempt may require the client to
            /// be connected to Steam, which is one more moving part that may fail.  When
            /// tickets are used, then once a ticket is obtained, a client can connect to
            /// your server even if they got disconnected from Steam or Steam is offline.If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint CreateListenSocketP2P(int nLocalVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

            /// <summary>
            /// Begin connecting to a peer that is identified using a platform-specific identifier.
            /// This uses the default rendezvous service, which depends on the platform and library
            /// configuration.  (E.g. on Steam, it goes through the steam backend.)
            /// </summary>
            /// <remarks>
            /// If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.To use your own signaling service, see:
            /// - ConnectP2PCustomSignaling
            /// - k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling
            /// </remarks>
            uint ConnectP2P(ref Native.SteamNetworkingIdentity identityRemote, int nRemoteVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

            /// <summary>
            /// Accept an incoming connection that has been received on a listen socket.
            /// </summary>
            /// <remarks>
            /// When a connection attempt is received (perhaps after a few basic handshake
            /// packets have been exchanged to prevent trivial spoofing), a connection interface
            /// object is created in the k_ESteamNetworkingConnectionState_Connecting state
            /// and a SteamNetConnectionStatusChangedCallback_t is posted.  At this point, your
            /// application MUST either accept or close the connection.  (It may not ignore it.)
            /// Accepting the connection will transition it either into the connected state,
            /// or the finding route state, depending on the connection type.You should take action within a second or two, because accepting the connection is
            /// what actually sends the reply notifying the client that they are connected.  If you
            /// delay taking action, from the client's perspective it is the same as the network
            /// being unresponsive, and the client may timeout the connection attempt.  In other
            /// words, the client cannot distinguish between a delay caused by network problems
            /// and a delay caused by the application.This means that if your application goes for more than a few seconds without
            /// processing callbacks (for example, while loading a map), then there is a chance
            /// that a client may attempt to connect in that interval and fail due to timeout.If the application does not respond to the connection attempt in a timely manner,
            /// and we stop receiving communication from the client, the connection attempt will
            /// be timed out locally, transitioning the connection to the
            /// k_ESteamNetworkingConnectionState_ProblemDetectedLocally state.  The client may also
            /// close the connection before it is accepted, and a transition to the
            /// k_ESteamNetworkingConnectionState_ClosedByPeer is also possible depending the exact
            /// sequence of events.Returns k_EResultInvalidParam if the handle is invalid.
            /// Returns k_EResultInvalidState if the connection is not in the appropriate state.
            /// (Remember that the connection state could change in between the time that the
            /// notification being posted to the queue and when it is received by the application.)A note about connection configuration options.  If you need to set any configuration
            /// options that are common to all connections accepted through a particular listen
            /// socket, consider setting the options on the listen socket, since such options are
            /// inherited automatically.  If you really do need to set options that are connection
            /// specific, it is safe to set them on the connection before accepting the connection.
            /// </remarks>
            Native.EResult AcceptConnection(uint hConn);

            /// <summary>
            /// Disconnects from the remote host and invalidates the connection handle.
            /// Any unread data on the connection is discarded.
            /// </summary>
            /// <remarks>
            /// nReason is an application defined code that will be received on the other
            /// end and recorded (when possible) in backend analytics.  The value should
            /// come from a restricted range.  (See ESteamNetConnectionEnd.)  If you don't need
            /// to communicate any information to the remote host, and do not want analytics to
            /// be able to distinguish "normal" connection terminations from "exceptional" ones,
            /// You may pass zero, in which case the generic value of
            /// k_ESteamNetConnectionEnd_App_Generic will be used.pszDebug is an optional human-readable diagnostic string that will be received
            /// by the remote host and recorded (when possible) in backend analytics.If you wish to put the socket into a "linger" state, where an attempt is made to
            /// flush any remaining sent data, use bEnableLinger=true.  Otherwise reliable data
            /// is not flushed.If the connection has already ended and you are just freeing up the
            /// connection interface, the reason code, debug string, and linger flag are
            /// ignored.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool CloseConnection(uint hPeer, int nReason, [MarshalAs(UnmanagedType.LPStr)] string pszDebug, [MarshalAs(UnmanagedType.U1)] bool bEnableLinger);

            /// <summary>
            /// Destroy a listen socket.  All the connections that were accepting on the listen
            /// socket are closed ungracefully.
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool CloseListenSocket(uint hSocket);

            /// <summary>
            /// Set connection user data.  the data is returned in the following places
            /// - You can query it using GetConnectionUserData.
            /// - The SteamNetworkingmessage_t structure.
            /// - The SteamNetConnectionInfo_t structure.
            /// (Which is a member of SteamNetConnectionStatusChangedCallback_t -- but see WARNINGS below!!!!)
            /// </summary>
            /// <remarks>
            /// Do you need to set this atomically when the connection is created?
            /// See k_ESteamNetworkingConfig_ConnectionUserData.WARNING: Be *very careful* when using the value provided in callbacks structs.
            /// Callbacks are queued, and the value that you will receive in your
            /// callback is the userdata that was effective at the time the callback
            /// was queued.  There are subtle race conditions that can hapen if you
            /// don't understand this!If any incoming messages for this connection are queued, the userdata
            /// field is updated, so that when when you receive messages (e.g. with
            /// ReceiveMessagesOnConnection), they will always have the very latest
            /// userdata.  So the tricky race conditions that can happen with callbacks
            /// do not apply to retrieving messages.Returns false if the handle is invalid.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool SetConnectionUserData(uint hPeer, long nUserData);

            /// <summary>
            /// Fetch connection user data.  Returns -1 if handle is invalid
            /// or if you haven't set any userdata on the connection.
            /// </summary>
            long GetConnectionUserData(uint hPeer);

            /// <summary>
            /// Set a name for the connection, used mostly for debugging
            /// </summary>
            void SetConnectionName(uint hPeer, [MarshalAs(UnmanagedType.LPStr)] string pszName);

            /// <summary>
            /// Fetch connection name.  Returns false if handle is invalid
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool GetConnectionName(uint hPeer, IntPtr pszName, int nMaxLen);

            /// <summary>
            /// Send a message to the remote host on the specified connection.
            /// </summary>
            /// <remarks>
            /// nSendFlags determines the delivery guarantees that will be provided,
            /// when data should be buffered, etc.  E.g. k_nSteamNetworkingSend_UnreliableNote that the semantics we use for messages are not precisely
            /// the same as the semantics of a standard "stream" socket.
            /// (SOCK_STREAM)  For an ordinary stream socket, the boundaries
            /// between chunks are not considered relevant, and the sizes of
            /// the chunks of data written will not necessarily match up to
            /// the sizes of the chunks that are returned by the reads on
            /// the other end.  The remote host might read a partial chunk,
            /// or chunks might be coalesced.  For the message semantics 
            /// used here, however, the sizes WILL match.  Each send call 
            /// will match a successful read call on the remote host 
            /// one-for-one.  If you are porting existing stream-oriented 
            /// code to the semantics of reliable messages, your code should 
            /// work the same, since reliable message semantics are more 
            /// strict than stream semantics.  The only caveat is related to 
            /// performance: there is per-message overhead to retain the 
            /// message sizes, and so if your code sends many small chunks 
            /// of data, performance will suffer. Any code based on stream 
            /// sockets that does not write excessively small chunks will 
            /// work without any changes.The pOutMessageNumber is an optional pointer to receive the
            /// message number assigned to the message, if sending was successful.Returns:
            /// - k_EResultInvalidParam: invalid connection handle, or the individual message is too big.
            /// (See k_cbMaxSteamNetworkingSocketsMessageSizeSend)
            /// - k_EResultInvalidState: connection is in an invalid state
            /// - k_EResultNoConnection: connection has ended
            /// - k_EResultIgnored: You used k_nSteamNetworkingSend_NoDelay, and the message was dropped because
            /// we were not ready to send it.
            /// - k_EResultLimitExceeded: there was already too much data queued to be sent.
            /// (See k_ESteamNetworkingConfig_SendBufferSize)
            /// </remarks>
            Native.EResult SendMessageToConnection(uint hConn, IntPtr pData, uint cbData, int nSendFlags, ref long pOutMessageNumber);

            /// <summary>
            /// Send a message to the remote host on the specified connection.
            /// </summary>
            /// <remarks>
            /// nSendFlags determines the delivery guarantees that will be provided,
            /// when data should be buffered, etc.  E.g. k_nSteamNetworkingSend_UnreliableNote that the semantics we use for messages are not precisely
            /// the same as the semantics of a standard "stream" socket.
            /// (SOCK_STREAM)  For an ordinary stream socket, the boundaries
            /// between chunks are not considered relevant, and the sizes of
            /// the chunks of data written will not necessarily match up to
            /// the sizes of the chunks that are returned by the reads on
            /// the other end.  The remote host might read a partial chunk,
            /// or chunks might be coalesced.  For the message semantics 
            /// used here, however, the sizes WILL match.  Each send call 
            /// will match a successful read call on the remote host 
            /// one-for-one.  If you are porting existing stream-oriented 
            /// code to the semantics of reliable messages, your code should 
            /// work the same, since reliable message semantics are more 
            /// strict than stream semantics.  The only caveat is related to 
            /// performance: there is per-message overhead to retain the 
            /// message sizes, and so if your code sends many small chunks 
            /// of data, performance will suffer. Any code based on stream 
            /// sockets that does not write excessively small chunks will 
            /// work without any changes.The pOutMessageNumber is an optional pointer to receive the
            /// message number assigned to the message, if sending was successful.Returns:
            /// - k_EResultInvalidParam: invalid connection handle, or the individual message is too big.
            /// (See k_cbMaxSteamNetworkingSocketsMessageSizeSend)
            /// - k_EResultInvalidState: connection is in an invalid state
            /// - k_EResultNoConnection: connection has ended
            /// - k_EResultIgnored: You used k_nSteamNetworkingSend_NoDelay, and the message was dropped because
            /// we were not ready to send it.
            /// - k_EResultLimitExceeded: there was already too much data queued to be sent.
            /// (See k_ESteamNetworkingConfig_SendBufferSize)
            /// </remarks>
            Native.EResult SendMessageToConnection(uint hConn, IntPtr pData, uint cbData, int nSendFlags, IntPtr pOutMessageNumber);


            /// <summary>
            /// Send one or more messages without copying the message payload.
            /// This is the most efficient way to send messages. To use this
            /// function, you must first allocate a message object using
            /// ISteamNetworkingUtils::AllocateMessage.  (Do not declare one
            /// on the stack or allocate your own.)
            /// </summary>
            /// <remarks>
            /// You should fill in the message payload.  You can either let
            /// it allocate the buffer for you and then fill in the payload,
            /// or if you already have a buffer allocated, you can just point
            /// m_pData at your buffer and set the callback to the appropriate function
            /// to free it.  Note that if you use your own buffer, it MUST remain valid
            /// until the callback is executed.  And also note that your callback can be
            /// invoked at any time from any thread (perhaps even before SendMessages
            /// returns!), so it MUST be fast and threadsafe.You MUST also fill in:
            /// - m_conn - the handle of the connection to send the message to
            /// - m_nFlags - bitmask of k_nSteamNetworkingSend_xxx flags.All other fields are currently reserved and should not be modified.The library will take ownership of the message structures.  They may
            /// be modified or become invalid at any time, so you must not read them
            /// after passing them to this function.pOutMessageNumberOrResult is an optional array that will receive,
            /// for each message, the message number that was assigned to the message
            /// if sending was successful.  If sending failed, then a negative EResult
            /// value is placed into the array.  For example, the array will hold
            /// -k_EResultInvalidState if the connection was in an invalid state.
            /// See ISteamNetworkingSockets::SendMessageToConnection for possible
            /// failure codes.
            /// </remarks>
            void SendMessages(int nMessages, out IntPtr pMessages, ref long pOutMessageNumberOrResult);

            /// <summary>
            /// Flush any messages waiting on the Nagle timer and send them
            /// at the next transmission opportunity (often that means right now).
            /// </summary>
            /// <remarks>
            /// If Nagle is enabled (it's on by default) then when calling 
            /// SendMessageToConnection the message will be buffered, up to the Nagle time
            /// before being sent, to merge small messages into the same packet.
            /// (See k_ESteamNetworkingConfig_NagleTime)Returns:
            /// k_EResultInvalidParam: invalid connection handle
            /// k_EResultInvalidState: connection is in an invalid state
            /// k_EResultNoConnection: connection has ended
            /// k_EResultIgnored: We weren't (yet) connected, so this operation has no effect.
            /// </remarks>
            Native.EResult FlushMessagesOnConnection(uint hConn);

            /// <summary>
            /// Fetch the next available message(s) from the connection, if any.
            /// Returns the number of messages returned into your array, up to nMaxMessages.
            /// If the connection handle is invalid, -1 is returned.
            /// </summary>
            /// <remarks>
            /// The order of the messages returned in the array is relevant.
            /// Reliable messages will be received in the order they were sent (and with the
            /// same sizes --- see SendMessageToConnection for on this subtle difference from a stream socket).Unreliable messages may be dropped, or delivered out of order with respect to
            /// each other or with respect to reliable messages.  The same unreliable message
            /// may be received multiple times.If any messages are returned, you MUST call SteamNetworkingMessage_t::Release() on each
            /// of them free up resources after you are done.  It is safe to keep the object alive for
            /// a little while (put it into some queue, etc), and you may call Release() from any thread.
            /// </remarks>
            int ReceiveMessagesOnConnection(uint hConn, out IntPtr ppOutMessages, int nMaxMessages);

            /// <summary>
            /// Returns basic information about the high-level state of the connection.
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool GetConnectionInfo(uint hConn, ref Native.SteamNetConnectionInfo_t pInfo);

            /// <summary>
            /// Returns a small set of information about the real-time state of the connection
            /// Returns false if the connection handle is invalid, or the connection has ended.
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool GetQuickConnectionStatus(uint hConn, ref Native.SteamNetworkingQuickConnectionStatus pStats);

            /// <summary>
            /// Returns detailed connection stats in text format.  Useful
            /// for dumping to a log, etc.
            /// </summary>
            /// <remarks>
            /// Returns:
            /// -1 failure (bad connection handle)
            /// 0 OK, your buffer was filled in and '
            /// \
            /// 0'-terminated
            /// &gt;0 Your buffer was either nullptr, or it was too small and the text got truncated.
            /// Try again with a buffer of at least N bytes.
            /// </remarks>
            int GetDetailedConnectionStatus(uint hConn, IntPtr pszBuf, int cbBuf);

            /// <summary>
            /// Returns local IP and port that a listen socket created using CreateListenSocketIP is bound to.
            /// </summary>
            /// <remarks>
            /// An IPv6 address of ::0 means "any IPv4 or IPv6"
            /// An IPv6 address of ::ffff:0000:0000 means "any IPv4"
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool GetListenSocketAddress(uint hSocket, ref Native.SteamNetworkingIPAddr address);

            /// <summary>
            /// Create a pair of connections that are talking to each other, e.g. a loopback connection.
            /// This is very useful for testing, or so that your client/server code can work the same
            /// even when you are running a local "server".
            /// </summary>
            /// <remarks>
            /// The two connections will immediately be placed into the connected state, and no callbacks
            /// will be posted immediately.  After this, if you close either connection, the other connection
            /// will receive a callback, exactly as if they were communicating over the network.  You must
            /// close *both* sides in order to fully clean up the resources!By default, internal buffers are used, completely bypassing the network, the chopping up of
            /// messages into packets, encryption, copying the payload, etc.  This means that loopback
            /// packets, by default, will not simulate lag or loss.  Passing true for bUseNetworkLoopback will
            /// cause the socket pair to send packets through the local network loopback device (127.0.0.1)
            /// on ephemeral ports.  Fake lag and loss are supported in this case, and CPU time is expended
            /// to encrypt and decrypt.If you wish to assign a specific identity to either connection, you may pass a particular
            /// identity.  Otherwise, if you pass nullptr, the respective connection will assume a generic
            /// "localhost" identity.  If you use real network loopback, this might be translated to the
            /// actual bound loopback port.  Otherwise, the port will be zero.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool CreateSocketPair(ref uint pOutConnection1, ref uint pOutConnection2, [MarshalAs(UnmanagedType.U1)] bool bUseNetworkLoopback, in Native.SteamNetworkingIdentity pIdentity1, in Native.SteamNetworkingIdentity pIdentity2);

            /// <summary>
            /// Get the identity assigned to this interface.
            /// E.g. on Steam, this is the user's SteamID, or for the gameserver interface, the SteamID assigned
            /// to the gameserver.  Returns false and sets the result to an invalid identity if we don't know
            /// our identity yet.  (E.g. GameServer has not logged in.  On Steam, the user will know their SteamID
            /// even if they are not signed into Steam.)
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool GetIdentity(ref Native.SteamNetworkingIdentity pIdentity);

            /// <summary>
            /// Indicate our desire to be ready participate in authenticated communications.
            /// If we are currently not ready, then steps will be taken to obtain the necessary
            /// certificates.   (This includes a certificate for us, as well as any CA certificates
            /// needed to authenticate peers.)
            /// </summary>
            /// <remarks>
            /// You can call this at program init time if you know that you are going to
            /// be making authenticated connections, so that we will be ready immediately when
            /// those connections are attempted.  (Note that essentially all connections require
            /// authentication, with the exception of ordinary UDP connections with authentication
            /// disabled using k_ESteamNetworkingConfig_IP_AllowWithoutAuth.)  If you don't call
            /// this function, we will wait until a feature is utilized that that necessitates
            /// these resources.You can also call this function to force a retry, if failure has occurred.
            /// Once we make an attempt and fail, we will not automatically retry.
            /// In this respect, the behavior of the system after trying and failing is the same
            /// as before the first attempt: attempting authenticated communication or calling
            /// this function will call the system to attempt to acquire the necessary resources.You can use GetAuthenticationStatus or listen for SteamNetAuthenticationStatus_t
            /// to monitor the status.Returns the current value that would be returned from GetAuthenticationStatus.
            /// </remarks>
            Native.ESteamNetworkingAvailability InitAuthentication();

            /// <summary>
            /// Query our readiness to participate in authenticated communications.  A
            /// SteamNetAuthenticationStatus_t callback is posted any time this status changes,
            /// but you can use this function to query it at any time.
            /// </summary>
            /// <remarks>
            /// The value of SteamNetAuthenticationStatus_t::m_eAvail is returned.  If you only
            /// want this high level status, you can pass NULL for pDetails.  If you want further
            /// details, pass non-NULL to receive them.
            /// </remarks>
            Native.ESteamNetworkingAvailability GetAuthenticationStatus(ref Native.SteamNetAuthenticationStatus_t pDetails);

            /// <summary>
            /// Create a new poll group.
            /// </summary>
            /// <remarks>
            /// You should destroy the poll group when you are done using DestroyPollGroup
            /// </remarks>
            uint CreatePollGroup();

            /// <summary>
            /// Destroy a poll group created with CreatePollGroup().
            /// </summary>
            /// <remarks>
            /// If there are any connections in the poll group, they are removed from the group,
            /// and left in a state where they are not part of any poll group.
            /// Returns false if passed an invalid poll group handle.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool DestroyPollGroup(uint hPollGroup);

            /// <summary>
            /// Assign a connection to a poll group.  Note that a connection may only belong to a
            /// single poll group.  Adding a connection to a poll group implicitly removes it from
            /// any other poll group it is in.
            /// </summary>
            /// <remarks>
            /// You can pass k_HSteamNetPollGroup_Invalid to remove a connection from its current
            /// poll group without adding it to a new poll group.If there are received messages currently pending on the connection, an attempt
            /// is made to add them to the queue of messages for the poll group in approximately
            /// the order that would have applied if the connection was already part of the poll
            /// group at the time that the messages were received.Returns false if the connection handle is invalid, or if the poll group handle
            /// is invalid (and not k_HSteamNetPollGroup_Invalid).
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool SetConnectionPollGroup(uint hConn, uint hPollGroup);

            /// <summary>
            /// Same as ReceiveMessagesOnConnection, but will return the next messages available
            /// on any connection in the poll group.  Examine SteamNetworkingMessage_t::m_conn
            /// to know which connection.  (SteamNetworkingMessage_t::m_nConnUserData might also
            /// be useful.)
            /// </summary>
            /// <remarks>
            /// Delivery order of messages among different connections will usually match the
            /// order that the last packet was received which completed the message.  But this
            /// is not a strong guarantee, especially for packets received right as a connection
            /// is being assigned to poll group.Delivery order of messages on the same connection is well defined and the
            /// same guarantees are present as mentioned in ReceiveMessagesOnConnection.
            /// (But the messages are not grouped by connection, so they will not necessarily
            /// appear consecutively in the list; they may be interleaved with messages for
            /// other connections.)
            /// </remarks>
            int ReceiveMessagesOnPollGroup(uint hPollGroup, Native.ISteamNetworkingMessages[] ppOutMessages, int nMaxMessages);

            /// <summary>
            /// Call this when you receive a ticket from your backend / matchmaking system.  Puts the
            /// ticket into a persistent cache, and optionally returns the parsed ticket.
            /// </summary>
            /// <remarks>
            /// See stamdatagram_ticketgen.h for more details.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool ReceivedRelayAuthTicket(IntPtr pvTicket, int cbTicket, Native.SteamDatagramRelayAuthTicket pOutParsedTicket);

            /// <summary>
            /// Search cache for a ticket to talk to the server on the specified virtual port.
            /// If found, returns the number of seconds until the ticket expires, and optionally
            /// the complete cracked ticket.  Returns 0 if we don't have a ticket.
            /// </summary>
            /// <remarks>
            /// Typically this is useful just to confirm that you have a ticket, before you
            /// call ConnectToHostedDedicatedServer to connect to the server.
            /// </remarks>
            int FindRelayAuthTicketForServer(ref Native.SteamNetworkingIdentity identityGameServer, int nRemoteVirtualPort, Native.SteamDatagramRelayAuthTicket pOutParsedTicket);

            /// <summary>
            /// Client call to connect to a server hosted in a Valve data center, on the specified virtual
            /// port.  You must have placed a ticket for this server into the cache, or else this connect
            /// attempt will fail!  If you are not issuing your own tickets, then to connect to a dedicated
            /// server via SDR in auto-ticket mode, use ConnectP2P.  (The server must be configured to allow
            /// this type of connection by listening using CreateListenSocketP2P.)
            /// </summary>
            /// <remarks>
            /// You may wonder why tickets are stored in a cache, instead of simply being passed as an argument
            /// here.  The reason is to make reconnection to a gameserver robust, even if the client computer loses
            /// connection to Steam or the central backend, or the app is restarted or crashes, etc.If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()
            /// when your app initializesIf you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint ConnectToHostedDedicatedServer(ref Native.SteamNetworkingIdentity identityTarget, int nRemoteVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

            /// <summary>
            /// Returns the value of the SDR_LISTEN_PORT environment variable.  This
            /// is the UDP server your server will be listening on.  This will
            /// configured automatically for you in production environments.
            /// </summary>
            /// <remarks>
            /// In development, you'll need to set it yourself.  See
            /// https://partner.steamgames.com/doc/api/ISteamNetworkingSockets
            /// for more information on how to configure dev environments.
            /// </remarks>
            ushort GetHostedDedicatedServerPort();

            /// <summary>
            /// Returns 0 if SDR_LISTEN_PORT is not set.  Otherwise, returns the data center the server
            /// is running in.  This will be k_SteamDatagramPOPID_dev in non-production environment.
            /// </summary>
            uint GetHostedDedicatedServerPOPID();

            /// <summary>
            /// Return info about the hosted server.  This contains the PoPID of the server,
            /// and opaque routing information that can be used by the relays to send traffic
            /// to your server.
            /// </summary>
            /// <remarks>
            /// You will need to send this information to your backend, and put it in tickets,
            /// so that the relays will know how to forward traffic from
            /// clients to your server.  See SteamDatagramRelayAuthTicket for more info.Also, note that the routing information is contained in SteamDatagramGameCoordinatorServerLogin,
            /// so if possible, it's preferred to use GetGameCoordinatorServerLogin to send this info
            /// to your game coordinator service, and also login securely at the same time.On a successful exit, k_EResultOK is returnedUnsuccessful exit:
            /// - Something other than k_EResultOK is returned.
            /// - k_EResultInvalidState: We are not configured to listen for SDR (SDR_LISTEN_SOCKET
            /// is not set.)
            /// - k_EResultPending: we do not (yet) have the authentication information needed.
            /// (See GetAuthenticationStatus.)  If you use environment variables to pre-fetch
            /// the network config, this data should always be available immediately.
            /// - A non-localized diagnostic debug message will be placed in m_data that describes
            /// the cause of the failure.NOTE: The returned blob is not encrypted.  Send it to your backend, but don't
            /// directly share it with clients.
            /// </remarks>
            Native.EResult GetHostedDedicatedServerAddress(Native.SteamDatagramHostedAddress pRouting);

            /// <summary>
            /// Create a listen socket on the specified virtual port.  The physical UDP port to use
            /// will be determined by the SDR_LISTEN_PORT environment variable.  If a UDP port is not
            /// configured, this call will fail.
            /// </summary>
            /// <remarks>
            /// This call MUST be made through the SteamGameServerNetworkingSockets() interface.This function should be used when you are using the ticket generator library
            /// to issue your own tickets.  Clients connecting to the server on this virtual
            /// port will need a ticket, and they must connect using ConnectToHostedDedicatedServer.If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint CreateHostedDedicatedServerListenSocket(int nLocalVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

            /// <summary>
            /// Generate an authentication blob that can be used to securely login with
            /// your backend, using SteamDatagram_ParseHostedServerLogin.  (See
            /// steamdatagram_gamecoordinator.h)
            /// </summary>
            /// <remarks>
            /// Before calling the function:
            /// - Populate the app data in pLoginInfo (m_cbAppData and m_appData).  You can leave
            /// all other fields uninitialized.
            /// - *pcbSignedBlob contains the size of the buffer at pBlob.  (It should be
            /// at least k_cbMaxSteamDatagramGameCoordinatorServerLoginSerialized.)On a successful exit:
            /// - k_EResultOK is returned
            /// - All of the remaining fields of pLoginInfo will be filled out.
            /// - *pcbSignedBlob contains the size of the serialized blob that has been
            /// placed into pBlob.Unsuccessful exit:
            /// - Something other than k_EResultOK is returned.
            /// - k_EResultNotLoggedOn: you are not logged in (yet)
            /// - See GetHostedDedicatedServerAddress for more potential failure return values.
            /// - A non-localized diagnostic debug message will be placed in pBlob that describes
            /// the cause of the failure.This works by signing the contents of the SteamDatagramGameCoordinatorServerLogin
            /// with the cert that is issued to this server.  In dev environments, it's OK if you do
            /// not have a cert.  (You will need to enable insecure dev login in SteamDatagram_ParseHostedServerLogin.)
            /// Otherwise, you will need a signed cert.NOTE: The routing blob returned here is not encrypted.  Send it to your backend
            /// and don't share it directly with clients.
            /// </remarks>
            Native.EResult GetGameCoordinatorServerLogin(Native.SteamDatagramGameCoordinatorServerLogin pLoginInfo, ref int pcbSignedBlob, IntPtr pBlob);

            /// <summary>
            /// Create a P2P "client" connection that does signaling over a custom
            /// rendezvous/signaling channel.
            /// </summary>
            /// <remarks>
            /// pSignaling points to a new object that you create just for this connection.
            /// It must stay valid until Release() is called.  Once you pass the
            /// object to this function, it assumes ownership.  Release() will be called
            /// from within the function call if the call fails.  Furthermore, until Release()
            /// is called, you should be prepared for methods to be invoked on your
            /// object from any thread!  You need to make sure your object is threadsafe!
            /// Furthermore, you should make sure that dispatching the methods is done
            /// as quickly as possible.This function will immediately construct a connection in the "connecting"
            /// state.  Soon after (perhaps before this function returns, perhaps in another thread),
            /// the connection will begin sending signaling messages by calling
            /// ISteamNetworkingConnectionSignaling::SendSignal.When the remote peer accepts the connection (See
            /// ISteamNetworkingSignalingRecvContext::OnConnectRequest),
            /// it will begin sending signaling messages.  When these messages are received,
            /// you can pass them to the connection using ReceivedP2PCustomSignal.If you know the identity of the peer that you expect to be on the other end,
            /// you can pass their identity to improve debug output or just detect bugs.
            /// If you don't know their identity yet, you can pass NULL, and their
            /// identity will be established in the connection handshake.If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()
            /// when your app initializesIf you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint ConnectP2PCustomSignaling(ref Native.ISteamNetworkingConnectionSignaling pSignaling, in Native.SteamNetworkingIdentity pPeerIdentity, int nRemoteVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

            /// <summary>
            /// Called when custom signaling has received a message.  When your
            /// signaling channel receives a message, it should save off whatever
            /// routing information was in the envelope into the context object,
            /// and then pass the payload to this function.
            /// </summary>
            /// <remarks>
            /// A few different things can happen next, depending on the message:- If the signal is associated with existing connection, it is dealt
            /// with immediately.  If any replies need to be sent, they will be
            /// dispatched using the ISteamNetworkingConnectionSignaling
            /// associated with the connection.
            /// - If the message represents a connection request (and the request
            /// is not redundant for an existing connection), a new connection
            /// will be created, and ReceivedConnectRequest will be called on your
            /// context object to determine how to proceed.
            /// - Otherwise, the message is for a connection that does not
            /// exist (anymore).  In this case, we *may* call SendRejectionReply
            /// on your context object.In any case, we will not save off pContext or access it after this
            /// function returns.Returns true if the message was parsed and dispatched without anything
            /// unusual or suspicious happening.  Returns false if there was some problem
            /// with the message that prevented ordinary handling.  (Debug output will
            /// usually have more information.)If you expect to be using relayed connections, then you probably want
            /// to call ISteamNetworkingUtils::InitRelayNetworkAccess() when your app initializes
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool ReceivedP2PCustomSignal(IntPtr pMsg, int cbMsg, ref Native.ISteamNetworkingSignalingRecvContext pContext);

            /// <summary>
            /// Get blob that describes a certificate request.  You can send this to your game coordinator.
            /// Upon entry, *pcbBlob should contain the size of the buffer.  On successful exit, it will
            /// return the number of bytes that were populated.  You can pass pBlob=NULL to query for the required
            /// size.  (512 bytes is a conservative estimate.)
            /// </summary>
            /// <remarks>
            /// Pass this blob to your game coordinator and call SteamDatagram_CreateCert.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool GetCertificateRequest(ref int pcbBlob, IntPtr pBlob, ref string errMsg);

            /// <summary>
            /// Set the certificate.  The certificate blob should be the output of
            /// SteamDatagram_CreateCert.
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool SetCertificate(IntPtr pCertificate, int cbCertificate, ref string errMsg);

            /// <summary>
            /// Reset the identity associated with this instance.
            /// Any open connections are closed.  Any previous certificates, etc are discarded.
            /// You can pass a specific identity that you want to use, or you can pass NULL,
            /// in which case the identity will be invalid until you set it using SetCertificate
            /// </summary>
            /// <remarks>
            /// NOTE: This function is not actually supported on Steam!  It is included
            /// for use on other platforms where the active user can sign out and
            /// a new user can sign in.
            /// </remarks>
            void ResetIdentity(in Native.SteamNetworkingIdentity pIdentity);

            /// <summary>
            /// Invoke all callback functions queued for this interface.
            /// See k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, etc
            /// </summary>
            /// <remarks>
            /// You don't need to call this if you are using Steam's callback dispatch
            /// mechanism (SteamAPI_RunCallbacks and SteamGameserver_RunCallbacks).
            /// </remarks>
            void RunCallbacks();

            /// <summary>
            /// Begin asynchronous process of allocating a fake IPv4 address that other
            /// peers can use to contact us via P2P.  IP addresses returned by this
            /// function are globally unique for a given appid.
            /// </summary>
            /// <remarks>
            /// nNumPorts is the numbers of ports you wish to reserve.  This is useful
            /// for the same reason that listening on multiple UDP ports is useful for
            /// different types of traffic.  Because these allocations come from a global
            /// namespace, there is a relatively strict limit on the maximum number of
            /// ports you may request.  (At the time of this writing, the limit is 4.)
            /// The Port assignments are *not* guaranteed to have any particular order
            /// or relationship!  Do *not* assume they are contiguous, even though that
            /// may often occur in practice.Returns false if a request was already in progress, true if a new request
            /// was started.  A SteamNetworkingFakeIP_t will be posted when the request
            /// completes.You can call this before you are logged in.  For gameservers, doing so is
            /// *required*, and all places where your public IP appears (such as the server
            /// browser) will be replaced by the FakeIP, and the fake port at index 0.
            /// A failure will not be posted (using SteamNetworkingFakeIP_t) unless we get
            /// logged in, and then the request fails.  Furthermore, it is assumed that
            /// FakeIP allocation is essential for your application to function, and so
            /// failure will not be reported until *several* retries have been attempted,
            /// possibly lasting several minutes.  It is highly recommended to treat failure
            /// as fatal.To communicate using a connection-oriented (TCP-style) API:
            /// - Server creates a listen socket using CreateListenSocketP2PFakeIP
            /// - Client connects using ConnectByIPAddress, passing in the FakeIP address.
            /// - The connection will behave mostly like a P2P connection.  The identities
            /// that appear in SteamNetConnectionInfo_t will be the FakeIP identity until
            /// we know the real identity.  Then it will be the real identity.  If the
            /// SteamNetConnectionInfo_t::m_addrRemote is valid, it will be a real IPv4
            /// address of a NAT-punched connection.  Otherwise, it will not be valid.To communicate using an ad-hoc sendto/recv from (UDP-style) API,
            /// use CreateFakeUDPPort.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool BeginAsyncRequestFakeIP(int nNumPorts);

            /// <summary>
            /// Return info about the FakeIP and port(s) that we have been assigned,
            /// if any.  idxFirstPort is currently reserved and must be zero.
            /// Make sure and check SteamNetworkingFakeIPResult_t::m_eResult
            /// </summary>
            void GetFakeIP(int idxFirstPort, Native.SteamNetworkingFakeIPResult_t pInfo);

            /// <summary>
            /// Create a listen socket that will listen for P2P connections sent
            /// to our FakeIP.  A peer can initiate connections to this listen
            /// socket by calling ConnectByIPAddress.
            /// </summary>
            /// <remarks>
            /// idxFakePort refers to the *index* of the fake port requested,
            /// not the actual port number.  For example, pass 0 to refer to the
            /// first port in the reservation.  You must call this only after calling
            /// BeginAsyncRequestFakeIP.  However, you do not need to wait for the
            /// request to complete before creating the listen socket.
            /// </remarks>
            uint CreateListenSocketP2PFakeIP(int idxFakePort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

            /// <summary>
            /// If the connection was initiated using the "FakeIP" system, then we
            /// we can get an IP address for the remote host.  If the remote host had
            /// a global FakeIP at the time the connection was established, this
            /// function will return that global IP.  Otherwise, a FakeIP that is
            /// unique locally will be allocated from the local FakeIP address space,
            /// and that will be returned.
            /// </summary>
            /// <remarks>
            /// The allocation of local FakeIPs attempts to assign addresses in
            /// a consistent manner.  If multiple connections are made to the
            /// same remote host, they *probably* will return the same FakeIP.
            /// However, since the namespace is limited, this cannot be guaranteed.On failure, returns:
            /// - k_EResultInvalidParam: invalid connection handle
            /// - k_EResultIPNotFound: This connection wasn't made using FakeIP system
            /// </remarks>
            Native.EResult GetRemoteFakeIPForConnection(uint hConn, ref Native.SteamNetworkingIPAddr pOutAddr);

            /// <summary>
            /// Get an interface that can be used like a UDP port to send/receive
            /// datagrams to a FakeIP address.  This is intended to make it easy
            /// to port existing UDP-based code to take advantage of SDR.
            /// </summary>
            /// <remarks>
            /// idxFakeServerPort refers to the *index* of the port allocated using
            /// BeginAsyncRequestFakeIP and is used to create "server" ports.  You may
            /// call this before the allocation has completed.  However, any attempts
            /// to send packets will fail until the allocation has succeeded.  When
            /// the peer receives packets sent from this interface, the from address
            /// of the packet will be the globally-unique FakeIP.  If you call this
            /// function multiple times and pass the same (nonnegative) fake port index,
            /// the same object will be returned, and this object is not reference counted.To create a "client" port (e.g. the equivalent of an ephemeral UDP port)
            /// pass -1.  In this case, a distinct object will be returned for each call.
            /// When the peer receives packets sent from this interface, the peer will
            /// assign a FakeIP from its own locally-controlled namespace.
            /// </remarks>
            Native.ISteamNetworkingFakeUDPPort CreateFakeUDPPort(int idxFakeServerPort);
        }

        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Misc networking utilities for checking the local networking environment
        /// and estimating pings.
        /// </summary>
        public interface ISteamNetworkingUtils
        {
            /// <summary>
            /// Allocate and initialize a message object.  Usually the reason
            /// you call this is to pass it to ISteamNetworkingSockets::SendMessages.
            /// The returned object will have all of the relevant fields cleared to zero.
            /// </summary>
            /// <remarks>
            /// Optionally you can also request that this system allocate space to
            /// hold the payload itself.  If cbAllocateBuffer is nonzero, the system
            /// will allocate memory to hold a payload of at least cbAllocateBuffer bytes.
            /// m_pData will point to the allocated buffer, m_cbSize will be set to the
            /// size, and m_pfnFreeData will be set to the proper function to free up
            /// the buffer.If cbAllocateBuffer=0, then no buffer is allocated.  m_pData will be NULL,
            /// m_cbSize will be zero, and m_pfnFreeData will be NULL.  You will need to
            /// set each of these.
            /// </remarks>
            ref Native.SteamNetworkingMessage_t AllocateMessage(int cbAllocateBuffer);

            /// <summary>
            /// Fetch current status of the relay network.
            /// </summary>
            /// <remarks>
            /// SteamRelayNetworkStatus_t is also a callback.  It will be triggered on
            /// both the user and gameserver interfaces any time the status changes, or
            /// ping measurement starts or stops.SteamRelayNetworkStatus_t::m_eAvail is returned.  If you want
            /// more details, you can pass a non-NULL value.
            /// </remarks>
            Native.ESteamNetworkingAvailability GetRelayNetworkStatus(ref Native.SteamRelayNetworkStatus_t pDetails);

            /// <summary>
            /// Return location info for the current host.  Returns the approximate
            /// age of the data, in seconds, or -1 if no data is available.
            /// </summary>
            /// <remarks>
            /// It takes a few seconds to initialize access to the relay network.  If
            /// you call this very soon after calling InitRelayNetworkAccess,
            /// the data may not be available yet.This always return the most up-to-date information we have available
            /// right now, even if we are in the middle of re-calculating ping times.
            /// </remarks>
            float GetLocalPingLocation(ref Native.SteamNetworkPingLocation_t result);

            /// <summary>
            /// Estimate the round-trip latency between two arbitrary locations, in
            /// milliseconds.  This is a conservative estimate, based on routing through
            /// the relay network.  For most basic relayed connections, this ping time
            /// will be pretty accurate, since it will be based on the route likely to
            /// be actually used.
            /// </summary>
            /// <remarks>
            /// If a direct IP route is used (perhaps via NAT traversal), then the route
            /// will be different, and the ping time might be better.  Or it might actually
            /// be a bit worse!  Standard IP routing is frequently suboptimal!But even in this case, the estimate obtained using this method is a
            /// reasonable upper bound on the ping time.  (Also it has the advantage
            /// of returning immediately and not sending any packets.)In a few cases we might not able to estimate the route.  In this case
            /// a negative value is returned.  k_nSteamNetworkingPing_Failed means
            /// the reason was because of some networking difficulty.  (Failure to
            /// ping, etc)  k_nSteamNetworkingPing_Unknown is returned if we cannot
            /// currently answer the question for some other reason.Do you need to be able to do this from a backend/matchmaking server?
            /// You are looking for the "game coordinator" library.
            /// </remarks>
            int EstimatePingTimeBetweenTwoLocations(ref Native.SteamNetworkPingLocation_t location1, ref Native.SteamNetworkPingLocation_t location2);

            /// <summary>
            /// Same as EstimatePingTime, but assumes that one location is the local host.
            /// This is a bit faster, especially if you need to calculate a bunch of
            /// these in a loop to find the fastest one.
            /// </summary>
            /// <remarks>
            /// In rare cases this might return a slightly different estimate than combining
            /// GetLocalPingLocation with EstimatePingTimeBetweenTwoLocations.  That's because
            /// this function uses a slightly more complete set of information about what
            /// route would be taken.
            /// </remarks>
            int EstimatePingTimeFromLocalHost(ref Native.SteamNetworkPingLocation_t remoteLocation);

            /// <summary>
            /// Convert a ping location into a text format suitable for sending over the wire.
            /// The format is a compact and human readable.  However, it is subject to change
            /// so please do not parse it yourself.  Your buffer must be at least
            /// k_cchMaxSteamNetworkingPingLocationString bytes.
            /// </summary>
            void ConvertPingLocationToString(ref Native.SteamNetworkPingLocation_t location, IntPtr pszBuf, int cchBufSize);

            /// <summary>
            /// Parse back SteamNetworkPingLocation_t string.  Returns false if we couldn't understand
            /// the string.
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool ParsePingLocationString([MarshalAs(UnmanagedType.LPStr)] string pszString, ref Native.SteamNetworkPingLocation_t result);

            /// <summary>
            /// Check if the ping data of sufficient recency is available, and if
            /// it's too old, start refreshing it.
            /// </summary>
            /// <remarks>
            /// Please only call this function when you *really* do need to force an
            /// immediate refresh of the data.  (For example, in response to a specific
            /// user input to refresh this information.)  Don't call it "just in case",
            /// before every connection, etc.  That will cause extra traffic to be sent
            /// for no benefit. The library will automatically refresh the information
            /// as needed.Returns true if sufficiently recent data is already available.Returns false if sufficiently recent data is not available.  In this
            /// case, ping measurement is initiated, if it is not already active.
            /// (You cannot restart a measurement already in progress.)You can use GetRelayNetworkStatus or listen for SteamRelayNetworkStatus_t
            /// to know when ping measurement completes.
            /// </remarks>
            [return: MarshalAs(UnmanagedType.U1)]
            bool CheckPingDataUpToDate(float flMaxAgeSeconds);

            /// <summary>
            /// Fetch ping time of best available relayed route from this host to
            /// the specified data center.
            /// </summary>
            int GetPingToDataCenter(uint popID, ref uint pViaRelayPoP);

            /// <summary>
            /// Get *direct* ping time to the relays at the data center.
            /// </summary>
            int GetDirectPingToPOP(uint popID);

            /// <summary>
            /// Get number of network points of presence in the config
            /// </summary>
            int GetPOPCount();

            /// <summary>
            /// Get list of all POP IDs.  Returns the number of entries that were filled into
            /// your list.
            /// </summary>
            int GetPOPList(ref uint list, int nListSz);

            /// <summary>
            /// Fetch current timestamp.  This timer has the following properties:
            /// </summary>
            /// <remarks>
            /// - Monotonicity is guaranteed.
            /// - The initial value will be at least 24*3600*30*1e6, i.e. about
            /// 30 days worth of microseconds.  In this way, the timestamp value of
            /// 0 will always be at least "30 days ago".  Also, negative numbers
            /// will never be returned.
            /// - Wraparound / overflow is not a practical concern.If you are running under the debugger and stop the process, the clock
            /// might not advance the full wall clock time that has elapsed between
            /// calls.  If the process is not blocked from normal operation, the
            /// timestamp values will track wall clock time, even if you don't call
            /// the function frequently.The value is only meaningful for this run of the process.  Don't compare
            /// it to values obtained on another computer, or other runs of the same process.
            /// </remarks>
            long GetLocalTimestamp();

            /// <summary>
            /// Set a function to receive network-related information that is useful for debugging.
            /// This can be very useful during development, but it can also be useful for troubleshooting
            /// problems with tech savvy end users.  If you have a console or other log that customers
            /// can examine, these log messages can often be helpful to troubleshoot network issues.
            /// (Especially any warning/error messages.)
            /// </summary>
            /// <remarks>
            /// The detail level indicates what message to invoke your callback on.  Lower numeric
            /// value means more important, and the value you pass is the lowest priority (highest
            /// numeric value) you wish to receive callbacks for.The value here controls the detail level for most messages.  You can control the
            /// detail level for various subsystems (perhaps only for certain connections) by
            /// adjusting the configuration values k_ESteamNetworkingConfig_LogLevel_Xxxxx.Except when debugging, you should only use k_ESteamNetworkingSocketsDebugOutputType_Msg
            /// or k_ESteamNetworkingSocketsDebugOutputType_Warning.  For best performance, do NOT
            /// request a high detail level and then filter out messages in your callback.  This incurs
            /// all of the expense of formatting the messages, which are then discarded.  Setting a high
            /// priority value (low numeric value) here allows the library to avoid doing this work.IMPORTANT: This may be called from a service thread, while we own a mutex, etc.
            /// Your output function must be threadsafe and fast!  Do not make any other
            /// Steamworks calls from within the handler.
            /// </remarks>
            void SetDebugOutputFunction(Native.ESteamNetworkingSocketsDebugOutputType eDetailLevel, Native.FSteamNetworkingSocketsDebugOutput pfnFunc);

            Native.ESteamNetworkingFakeIPType GetIPv4FakeIPType(uint nIPv4);

            /// <summary>
            /// Get the real identity associated with a given FakeIP.
            /// </summary>
            /// <remarks>
            /// On failure, returns:
            /// - k_EResultInvalidParam: the IP is not a FakeIP.
            /// - k_EResultNoMatch: we don't recognize that FakeIP and don't know the corresponding identity.FakeIP's used by active connections, or the FakeIPs assigned to local identities,
            /// will always work.  FakeIPs for recently destroyed connections will continue to
            /// return results for a little while, but not forever.  At some point, we will forget
            /// FakeIPs to save space.  It's reasonably safe to assume that you can read back the
            /// real identity of a connection very soon after it is destroyed.  But do not wait
            /// indefinitely.
            /// </remarks>
            Native.EResult GetRealIdentityForFakeIP(ref Native.SteamNetworkingIPAddr fakeIP, ref Native.SteamNetworkingIdentity pOutRealIdentity);

            /// <summary>
            /// Set a configuration value.
            /// - eValue: which value is being set
            /// - eScope: Onto what type of object are you applying the setting?
            /// - scopeArg: Which object you want to change?  (Ignored for global scope).  E.g. connection handle, listen socket handle, interface pointer, etc.
            /// - eDataType: What type of data is in the buffer at pValue?  This must match the type of the variable exactly!
            /// - pArg: Value to set it to.  You can pass NULL to remove a non-global setting at this scope,
            /// causing the value for that object to use global defaults.  Or at global scope, passing NULL
            /// will reset any custom value and restore it to the system default.
            /// NOTE: When setting pointers (e.g. callback functions), do not pass the function pointer directly.
            /// Your argument should be a pointer to a function pointer.
            /// </summary>
            [return: MarshalAs(UnmanagedType.U1)]
            bool SetConfigValue(Native.ESteamNetworkingConfigValue eValue, Native.ESteamNetworkingConfigScope eScopeType, long scopeObj, Native.ESteamNetworkingConfigDataType eDataType, IntPtr pArg);

            /// <summary>
            /// Get a configuration value.
            /// - eValue: which value to fetch
            /// - eScopeType: query setting on what type of object
            /// - eScopeArg: the object to query the setting for
            /// - pOutDataType: If non-NULL, the data type of the value is returned.
            /// - pResult: Where to put the result.  Pass NULL to query the required buffer size.  (k_ESteamNetworkingGetConfigValue_BufferTooSmall will be returned.)
            /// - cbResult: IN: the size of your buffer.  OUT: the number of bytes filled in or required.
            /// </summary>
            Native.ESteamNetworkingGetConfigValueResult GetConfigValue(Native.ESteamNetworkingConfigValue eValue, Native.ESteamNetworkingConfigScope eScopeType, long scopeObj, ref Native.ESteamNetworkingConfigDataType pOutDataType, IntPtr pResult, ref ulong cbResult);

            /// <summary>
            /// Get info about a configuration value.  Returns the name of the value,
            /// or NULL if the value doesn't exist.  Other output parameters can be NULL
            /// if you do not need them.
            /// </summary>
            [return: MarshalAs(UnmanagedType.LPStr)]
            string GetConfigValueInfo(Native.ESteamNetworkingConfigValue eValue, ref Native.ESteamNetworkingConfigDataType pOutDataType, ref Native.ESteamNetworkingConfigScope pOutScope);

            /// <summary>
            /// Iterate the list of all configuration values in the current environment that it might
            /// be possible to display or edit using a generic UI.  To get the first iterable value,
            /// pass k_ESteamNetworkingConfig_Invalid.  Returns k_ESteamNetworkingConfig_Invalid
            /// to signal end of list.
            /// </summary>
            /// <remarks>
            /// The bEnumerateDevVars argument can be used to include "dev" vars.  These are vars that
            /// are recommended to only be editable in "debug" or "dev" mode and typically should not be
            /// shown in a retail environment where a malicious local user might use this to cheat.
            /// </remarks>
            Native.ESteamNetworkingConfigValue IterateGenericEditableConfigValues(Native.ESteamNetworkingConfigValue eCurrent, [MarshalAs(UnmanagedType.U1)] bool bEnumerateDevVars);

            /// <summary>
            /// String conversions.  You'll usually access these using the respective
            /// inline methods.
            /// </summary>
            void SteamNetworkingIPAddr_ToString(ref Native.SteamNetworkingIPAddr addr, IntPtr buf, ulong cbBuf, [MarshalAs(UnmanagedType.U1)] bool bWithPort);

            [return: MarshalAs(UnmanagedType.U1)]
            bool SteamNetworkingIPAddr_ParseString(ref Native.SteamNetworkingIPAddr pAddr, [MarshalAs(UnmanagedType.LPStr)] string pszStr);

            Native.ESteamNetworkingFakeIPType SteamNetworkingIPAddr_GetFakeIPType(ref Native.SteamNetworkingIPAddr addr);

            void SteamNetworkingIdentity_ToString(ref Native.SteamNetworkingIdentity identity, IntPtr buf, ulong cbBuf);

            [return: MarshalAs(UnmanagedType.U1)]
            bool SteamNetworkingIdentity_ParseString(ref Native.SteamNetworkingIdentity pIdentity, [MarshalAs(UnmanagedType.LPStr)] string pszStr);
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FSteamNetworkingSocketsDebugOutput(Native.ESteamNetworkingSocketsDebugOutputType nType, [MarshalAs(UnmanagedType.LPStr)] string pszMsg);

        /// <summary>
        /// Utility class for printing a SteamNetworkingIdentity.
        /// E.g. printf( "Identity is '%s'@n ", SteamNetworkingIdentityRender( identity ).c_str() );
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIdentityRender
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string buf;
        }

        /// <summary>
        /// Utility class for printing a SteamNetworkingIPAddrRender.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIPAddrRender
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 48)]
            public string buf;
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void PFNPreMinidumpCallback(IntPtr context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetConnectionStatusChanged(ref Native.SteamNetConnectionStatusChangedCallback_t arg0);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetAuthenticationStatusChanged(ref Native.SteamNetAuthenticationStatus_t arg0);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamRelayNetworkStatusChanged(ref Native.SteamRelayNetworkStatus_t arg0);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingMessagesSessionRequest(ref Native.SteamNetworkingMessagesSessionRequest_t arg0);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingMessagesSessionFailed(ref Native.SteamNetworkingMessagesSessionFailed_t arg0);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingFakeIPResult(Native.SteamNetworkingFakeIPResult_t arg0);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr FnSteamNetworkingSocketsCreateConnectionSignaling(ref Native.ISteamNetworkingSockets pLocalInterface, ref Native.SteamNetworkingIdentity identityPeer, int nLocalVirtualPort, int nRemoteVirtualPort);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public delegate bool FSteamNetworkingSocketsCustomSignaling_SendSignal(IntPtr ctx, uint hConn, ref Native.SteamNetConnectionInfo_t info, IntPtr pMsg, int cbMsg);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FSteamNetworkingSocketsCustomSignaling_Release(IntPtr ctx);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr FSteamNetworkingCustomSignalingRecvContext_OnConnectRequest(IntPtr ctx, uint hConn, ref Native.SteamNetworkingIdentity identityPeer, int nLocalVirtualPort);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FSteamNetworkingCustomSignalingRecvContext_SendRejectionSignal(IntPtr ctx, ref Native.SteamNetworkingIdentity identityPeer, IntPtr pMsg, int cbMsg);

        public const uint k_uAppIdInvalid = 0;

        public const uint k_uDepotIdInvalid = 0;

        public const ulong k_uAPICallInvalid = 0;

        public const ulong k_ulPartyBeaconIdInvalid = 0;

        public const uint k_HAuthTicketInvalid = 0;

        public const uint k_unSteamAccountIDMask = 0xFFFFFFFF;

        public const uint k_unSteamAccountInstanceMask = 1048575;

        /// <summary>
        /// fixed instance for all individual users
        /// </summary>
        public const uint k_unSteamUserDefaultInstance = 1;

        public const int k_cchGameExtraInfoMax = 64;

        public const uint k_HSteamNetConnection_Invalid = 0;

        public const uint k_HSteamListenSocket_Invalid = 0;

        public const uint k_HSteamNetPollGroup_Invalid = 0;

        /// <summary>
        /// Max length of diagnostic error message
        /// </summary>
        public const int k_cchMaxSteamNetworkingErrMsg = 1024;

        /// <summary>
        /// Max length, in bytes (including null terminator) of the reason string
        /// when a connection is closed.
        /// </summary>
        public const int k_cchSteamNetworkingMaxConnectionCloseReason = 128;

        /// <summary>
        /// Max length, in bytes (include null terminator) of debug description
        /// of a connection.
        /// </summary>
        public const int k_cchSteamNetworkingMaxConnectionDescription = 128;

        /// <summary>
        /// We don't have a certificate for the remote host.
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Unauthenticated = 1;

        /// <summary>
        /// Information is being sent out over a wire unencrypted (by this library)
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Unencrypted = 2;

        /// <summary>
        /// Internal loopback buffers.  Won't be true for localhost.  (You can check the address to determine that.)  This implies k_nSteamNetworkConnectionInfoFlags_FastLAN
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers = 4;

        /// <summary>
        /// The connection is "fast" and "reliable".  Either internal/localhost (check the address to find out), or the peer is on the same LAN.  (Probably.  It's based on the address and the ping time, this is actually hard to determine unambiguously).
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Fast = 8;

        /// <summary>
        /// The connection is relayed somehow (SDR or TURN).
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Relayed = 16;

        /// <summary>
        /// We're taking advantage of dual-wifi multi-path
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_DualWifi = 32;

        /// <summary>
        /// Max size of a single message that we can SEND.
        /// Note: We might be wiling to receive larger messages,
        /// and our peer might, too.
        /// </summary>
        public const int k_cbMaxSteamNetworkingSocketsMessageSizeSend = 512 * 1024;

        /// <summary>
        /// Send the message unreliably. Can be lost.  Messages *can* be larger than a
        /// single MTU (UDP packet), but there is no retransmission, so if any piece
        /// of the message is lost, the entire message will be dropped.
        /// </summary>
        /// <remarks>
        /// The sending API does have some knowledge of the underlying connection, so
        /// if there is no NAT-traversal accomplished or there is a recognized adjustment
        /// happening on the connection, the packet will be batched until the connection
        /// is open again.Migration note: This is not exactly the same as k_EP2PSendUnreliable!  You
        /// probably want k_ESteamNetworkingSendType_UnreliableNoNagle
        /// </remarks>
        public const int k_nSteamNetworkingSend_Unreliable = 0;

        /// <summary>
        /// Disable Nagle's algorithm.
        /// By default, Nagle's algorithm is applied to all outbound messages.  This means
        /// that the message will NOT be sent immediately, in case further messages are
        /// sent soon after you send this, which can be grouped together.  Any time there
        /// is enough buffered data to fill a packet, the packets will be pushed out immediately,
        /// but partially-full packets not be sent until the Nagle timer expires.  See
        /// ISteamNetworkingSockets::FlushMessagesOnConnection, ISteamNetworkingMessages::FlushMessagesToUser
        /// </summary>
        /// <remarks>
        /// NOTE: Don't just send every message without Nagle because you want packets to get there
        /// quicker.  Make sure you understand the problem that Nagle is solving before disabling it.
        /// If you are sending small messages, often many at the same time, then it is very likely that
        /// it will be more efficient to leave Nagle enabled.  A typical proper use of this flag is
        /// when you are sending what you know will be the last message sent for a while (e.g. the last
        /// in the server simulation tick to a particular client), and you use this flag to flush all
        /// messages.
        /// </remarks>
        public const int k_nSteamNetworkingSend_NoNagle = 1;

        /// <summary>
        /// Send a message unreliably, bypassing Nagle's algorithm for this message and any messages
        /// currently pending on the Nagle timer.  This is equivalent to using k_ESteamNetworkingSend_Unreliable
        /// and then immediately flushing the messages using ISteamNetworkingSockets::FlushMessagesOnConnection
        /// or ISteamNetworkingMessages::FlushMessagesToUser.  (But using this flag is more efficient since you
        /// only make one API call.)
        /// </summary>
        public const int k_nSteamNetworkingSend_UnreliableNoNagle = k_nSteamNetworkingSend_Unreliable | k_nSteamNetworkingSend_NoNagle;

        /// <summary>
        /// If the message cannot be sent very soon (because the connection is still doing some initial
        /// handshaking, route negotiations, etc), then just drop it.  This is only applicable for unreliable
        /// messages.  Using this flag on reliable messages is invalid.
        /// </summary>
        public const int k_nSteamNetworkingSend_NoDelay = 4;

        /// <summary>
        /// Send an unreliable message, but if it cannot be sent relatively quickly, just drop it instead of queuing it.
        /// This is useful for messages that are not useful if they are excessively delayed, such as voice data.
        /// NOTE: The Nagle algorithm is not used, and if the message is not dropped, any messages waiting on the
        /// Nagle timer are immediately flushed.
        /// </summary>
        /// <remarks>
        /// A message will be dropped under the following circumstances:
        /// - the connection is not fully connected.  (E.g. the "Connecting" or "FindingRoute" states)
        /// - there is a sufficiently large number of messages queued up already such that the current message
        /// will not be placed on the wire in the next ~200ms or so.If a message is dropped for these reasons, k_EResultIgnored will be returned.
        /// </remarks>
        public const int k_nSteamNetworkingSend_UnreliableNoDelay = k_nSteamNetworkingSend_Unreliable | k_nSteamNetworkingSend_NoDelay | k_nSteamNetworkingSend_NoNagle;

        /// <summary>
        /// Reliable message send. Can send up to k_cbMaxSteamNetworkingSocketsMessageSizeSend bytes in a single message. 
        /// Does fragmentation/re-assembly of messages under the hood, as well as a sliding window for
        /// efficient sends of large chunks of data.
        /// </summary>
        /// <remarks>
        /// The Nagle algorithm is used.  See notes on k_ESteamNetworkingSendType_Unreliable for more details.
        /// See k_ESteamNetworkingSendType_ReliableNoNagle, ISteamNetworkingSockets::FlushMessagesOnConnection,
        /// ISteamNetworkingMessages::FlushMessagesToUserMigration note: This is NOT the same as k_EP2PSendReliable, it's more like k_EP2PSendReliableWithBuffering
        /// </remarks>
        public const int k_nSteamNetworkingSend_Reliable = 8;

        /// <summary>
        /// Send a message reliably, but bypass Nagle's algorithm.
        /// </summary>
        /// <remarks>
        /// Migration note: This is equivalent to k_EP2PSendReliable
        /// </remarks>
        public const int k_nSteamNetworkingSend_ReliableNoNagle = k_nSteamNetworkingSend_Reliable | k_nSteamNetworkingSend_NoNagle;

        /// <summary>
        /// By default, message sending is queued, and the work of encryption and talking to
        /// the operating system sockets, etc is done on a service thread.  This is usually a
        /// a performance win when messages are sent from the "main thread".  However, if this
        /// flag is set, and data is ready to be sent immediately (either from this message
        /// or earlier queued data), then that work will be done in the current thread, before
        /// the current call returns.  If data is not ready to be sent (due to rate limiting
        /// or Nagle), then this flag has no effect.
        /// </summary>
        /// <remarks>
        /// This is an advanced flag used to control performance at a very low level.  For
        /// most applications running on modern hardware with more than one CPU core, doing
        /// the work of sending on a service thread will yield the best performance.  Only
        /// use this flag if you have a really good reason and understand what you are doing.
        /// Otherwise you will probably just make performance worse.
        /// </remarks>
        public const int k_nSteamNetworkingSend_UseCurrentThread = 16;

        /// <summary>
        /// When sending a message using ISteamNetworkingMessages, automatically re-establish
        /// a broken session, without returning k_EResultNoConnection.  Without this flag,
        /// if you attempt to send a message, and the session was proactively closed by the
        /// peer, or an error occurred that disrupted communications, then you must close the
        /// session using ISteamNetworkingMessages::CloseSessionWithUser before attempting to
        /// send another message.  (Or you can simply add this flag and retry.)  In this way,
        /// the disruption cannot go unnoticed, and a more clear order of events can be
        /// ascertained. This is especially important when reliable messages are used, since
        /// if the connection is disrupted, some of those messages will not have been delivered,
        /// and it is in general not possible to know which.  Although a
        /// SteamNetworkingMessagesSessionFailed_t callback will be posted when an error occurs
        /// to notify you that a failure has happened, callbacks are asynchronous, so it is not
        /// possible to tell exactly when it happened.  And because the primary purpose of
        /// ISteamNetworkingMessages is to be like UDP, there is no notification when a peer closes
        /// the session.
        /// </summary>
        /// <remarks>
        /// If you are not using any reliable messages (e.g. you are using ISteamNetworkingMessages
        /// exactly as a transport replacement for UDP-style datagrams only), you may not need to
        /// know when an underlying connection fails, and so you may not need this notification.
        /// </remarks>
        public const int k_nSteamNetworkingSend_AutoRestartBrokenSession = 32;

        /// <summary>
        /// Max possible length of a ping location, in string format.  This is
        /// an extremely conservative worst case value which leaves room for future
        /// syntax enhancements.  Most strings in practice are a lot shorter.
        /// If you are storing many of these, you will very likely benefit from
        /// using dynamic memory.
        /// </summary>
        public const int k_cchMaxSteamNetworkingPingLocationString = 1024;

        /// <summary>
        /// Special values that are returned by some functions that return a ping.
        /// </summary>
        public const int k_nSteamNetworkingPing_Failed = -1;

        public const int k_nSteamNetworkingPing_Unknown = -2;

        /// <summary>
        /// Special value - use user defaults
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default = -1;

        /// <summary>
        /// Do not do any ICE work at all or share any IP addresses with peer
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable = 0;

        /// <summary>
        /// Relayed connection via TURN server.
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay = 1;

        /// <summary>
        /// host addresses that appear to be link-local or RFC1918 addresses
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private = 2;

        /// <summary>
        /// STUN reflexive addresses, or host address that isn't a "private" address
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public = 4;

        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All = 0x7fffffff;

        /// <summary>
        /// The POPID "dev" is used in non-production environments for testing.
        /// </summary>
        public const uint k_SteamDatagramPOPID_dev = ((uint)'d' << 16) | ((uint)'e' << 8) | (uint)'v';

        /// <summary>
        /// Unpack integer to string representation, including terminating '
        /// \
        /// 0'
        /// </summary>
        /// <remarks>
        /// See also SteamNetworkingPOPIDRender
        /// </remarks>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void GetSteamNetworkingLocationPOPStringFromID(uint id, ref sbyte[] szCode);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Native.ISteamNetworkingMessages SteamNetworkingMessages_LibV2();

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Native.ISteamNetworkingSockets SteamNetworkingSockets_LibV11();

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Native.ISteamNetworkingUtils SteamNetworkingUtils_LibV4();

        /// <summary>
        /// Call direct to static functions
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingIPAddr_ToString(in Native.SteamNetworkingIPAddr pAddr, IntPtr buf, ulong cbBuf, [MarshalAs(UnmanagedType.U1)] bool bWithPort);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamNetworkingIPAddr_ParseString(ref Native.SteamNetworkingIPAddr pAddr, [MarshalAs(UnmanagedType.LPStr)] string pszStr);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.ESteamNetworkingFakeIPType SteamNetworkingIPAddr_GetFakeIPType(in Native.SteamNetworkingIPAddr pAddr);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingIdentity_ToString(in Native.SteamNetworkingIdentity pIdentity, IntPtr buf, ulong cbBuf);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamNetworkingIdentity_ParseString(ref Native.SteamNetworkingIdentity pIdentity, ulong sizeofIdentity, [MarshalAs(UnmanagedType.LPStr)] string pszStr);

        /// <summary>
        /// Initialize the library.  Optionally, you can set an initial identity for the default
        /// interface that is returned by SteamNetworkingSockets().
        /// </summary>
        /// <remarks>
        /// On failure, false is returned, and a non-localized diagnostic message is returned.
        /// </remarks>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool GameNetworkingSockets_Init(in Native.SteamNetworkingIdentity pIdentity, ref string errMsg);

        /// <summary>
        /// Close all connections and listen sockets and free all resources
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void GameNetworkingSockets_Kill();

        /// <summary>
        /// Custom memory allocation methods.  If you call this, you MUST call it exactly once,
        /// before calling any other API function.  *Most* allocations will pass through these,
        /// especially all allocations that are per-connection.  A few allocations
        /// might still go to the default CRT malloc and operator new.
        /// To use this, you must compile the library with STEAMNETWORKINGSOCKETS_ENABLE_MEM_OVERRIDE
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingSockets_SetCustomMemoryAllocator(Native.pfn_malloc_delegate pfn_malloc, Native.pfn_free_delegate pfn_free, Native.pfn_realloc_delegate pfn_realloc);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr pfn_malloc_delegate(ulong s);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void pfn_free_delegate(IntPtr p);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr pfn_realloc_delegate(IntPtr p, ulong s);


        /// <summary>
        /// Statistics about the global lock.
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingSockets_SetLockWaitWarningThreshold(long usecThreshold);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingSockets_SetLockAcquiredCallback(Native.callback_delegate callback);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void callback_delegate([MarshalAs(UnmanagedType.LPStr)] string tags, long usecWaited);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingSockets_SetLockHeldCallback(Native.callback_delegate callback);


        /// <summary>
        /// ISteamNetworkingSockets
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Native.ISteamNetworkingSockets SteamAPI_SteamNetworkingSockets_v009();

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP(ref Native.ISteamNetworkingSockets self, ref Native.SteamNetworkingIPAddr localAddress, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress(ref Native.ISteamNetworkingSockets self, ref Native.SteamNetworkingIPAddr address, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P(ref Native.ISteamNetworkingSockets self, int nLocalVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P(ref Native.ISteamNetworkingSockets self, int nLocalVirtualPort, int nOptions, IntPtr pOptions);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_ConnectP2P(ref Native.ISteamNetworkingSockets self, ref Native.SteamNetworkingIdentity identityRemote, int nRemoteVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.EResult SteamAPI_ISteamNetworkingSockets_AcceptConnection(ref Native.ISteamNetworkingSockets self, uint hConn);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_CloseConnection(ref Native.ISteamNetworkingSockets self, uint hPeer, int nReason, [MarshalAs(UnmanagedType.LPStr)] string pszDebug, [MarshalAs(UnmanagedType.U1)] bool bEnableLinger);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_CloseListenSocket(ref Native.ISteamNetworkingSockets self, uint hSocket);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_SetConnectionUserData(ref Native.ISteamNetworkingSockets self, uint hPeer, long nUserData);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern long SteamAPI_ISteamNetworkingSockets_GetConnectionUserData(ref Native.ISteamNetworkingSockets self, uint hPeer);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_ISteamNetworkingSockets_SetConnectionName(ref Native.ISteamNetworkingSockets self, uint hPeer, [MarshalAs(UnmanagedType.LPStr)] string pszName);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_GetConnectionName(ref Native.ISteamNetworkingSockets self, uint hPeer, IntPtr pszName, int nMaxLen);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.EResult SteamAPI_ISteamNetworkingSockets_SendMessageToConnection(ref Native.ISteamNetworkingSockets self, uint hConn, IntPtr pData, uint cbData, int nSendFlags, ref long pOutMessageNumber);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_ISteamNetworkingSockets_SendMessages(ref Native.ISteamNetworkingSockets self, int nMessages, out IntPtr pMessages, ref long pOutMessageNumberOrResult);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.EResult SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection(ref Native.ISteamNetworkingSockets self, uint hConn);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection(ref Native.ISteamNetworkingSockets self, uint hConn, out IntPtr ppOutMessages, int nMaxMessages);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_GetConnectionInfo(ref Native.ISteamNetworkingSockets self, uint hConn, ref Native.SteamNetConnectionInfo_t pInfo);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus(ref Native.ISteamNetworkingSockets self, uint hConn, ref Native.SteamNetworkingQuickConnectionStatus pStats);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus(ref Native.ISteamNetworkingSockets self, uint hConn, IntPtr pszBuf, int cbBuf);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress(ref Native.ISteamNetworkingSockets self, uint hSocket, ref Native.SteamNetworkingIPAddr address);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_CreateSocketPair(ref Native.ISteamNetworkingSockets self, ref uint pOutConnection1, ref uint pOutConnection2, [MarshalAs(UnmanagedType.U1)] bool bUseNetworkLoopback, in Native.SteamNetworkingIdentity pIdentity1, in Native.SteamNetworkingIdentity pIdentity2);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_GetIdentity(ref Native.ISteamNetworkingSockets self, ref Native.SteamNetworkingIdentity pIdentity);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.ESteamNetworkingAvailability SteamAPI_ISteamNetworkingSockets_InitAuthentication(ref Native.ISteamNetworkingSockets self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.ESteamNetworkingAvailability SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus(ref Native.ISteamNetworkingSockets self, ref Native.SteamNetAuthenticationStatus_t pDetails);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_CreatePollGroup(ref Native.ISteamNetworkingSockets self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_DestroyPollGroup(ref Native.ISteamNetworkingSockets self, uint hPollGroup);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup(ref Native.ISteamNetworkingSockets self, uint hConn, uint hPollGroup);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup(ref Native.ISteamNetworkingSockets self, uint hPollGroup, out IntPtr ppOutMessages, int nMaxMessages);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket(ref Native.ISteamNetworkingSockets self, IntPtr pvTicket, int cbTicket, Native.SteamDatagramRelayAuthTicket pOutParsedTicket);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer(ref Native.ISteamNetworkingSockets self, ref Native.SteamNetworkingIdentity identityGameServer, int nRemoteVirtualPort, Native.SteamDatagramRelayAuthTicket pOutParsedTicket);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer(ref Native.ISteamNetworkingSockets self, ref Native.SteamNetworkingIdentity identityTarget, int nRemoteVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort(ref Native.ISteamNetworkingSockets self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID(ref Native.ISteamNetworkingSockets self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.EResult SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress(ref Native.ISteamNetworkingSockets self, Native.SteamDatagramHostedAddress pRouting);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket(ref Native.ISteamNetworkingSockets self, int nLocalVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.EResult SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin(ref Native.ISteamNetworkingSockets self, Native.SteamDatagramGameCoordinatorServerLogin pLoginInfo, ref int pcbSignedBlob, IntPtr pBlob);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling(ref Native.ISteamNetworkingSockets self, ref Native.ISteamNetworkingConnectionSignaling pSignaling, in Native.SteamNetworkingIdentity pPeerIdentity, int nRemoteVirtualPort, int nOptions, in Native.SteamNetworkingConfigValue_t pOptions);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal(ref Native.ISteamNetworkingSockets self, IntPtr pMsg, int cbMsg, ref Native.ISteamNetworkingSignalingRecvContext pContext);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_GetCertificateRequest(ref Native.ISteamNetworkingSockets self, ref int pcbBlob, IntPtr pBlob, ref string errMsg);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_SetCertificate(ref Native.ISteamNetworkingSockets self, IntPtr pCertificate, int cbCertificate, ref string errMsg);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_ISteamNetworkingSockets_RunCallbacks(ref Native.ISteamNetworkingSockets self);

        /// <summary>
        /// ISteamNetworkingUtils
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Native.ISteamNetworkingUtils SteamAPI_SteamNetworkingUtils_v003();

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Native.SteamNetworkingMessage_t SteamAPI_ISteamNetworkingUtils_AllocateMessage(ref Native.ISteamNetworkingUtils self, int cbAllocateBuffer);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess(ref Native.ISteamNetworkingUtils self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.ESteamNetworkingAvailability SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus(ref Native.ISteamNetworkingUtils self, ref Native.SteamRelayNetworkStatus_t pDetails);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern float SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation(ref Native.ISteamNetworkingUtils self, ref Native.SteamNetworkPingLocation_t result);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations(ref Native.ISteamNetworkingUtils self, ref Native.SteamNetworkPingLocation_t location1, ref Native.SteamNetworkPingLocation_t location2);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost(ref Native.ISteamNetworkingUtils self, ref Native.SteamNetworkPingLocation_t remoteLocation);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString(ref Native.ISteamNetworkingUtils self, ref Native.SteamNetworkPingLocation_t location, IntPtr pszBuf, int cchBufSize);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_ParsePingLocationString(ref Native.ISteamNetworkingUtils self, [MarshalAs(UnmanagedType.LPStr)] string pszString, ref Native.SteamNetworkPingLocation_t result);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate(ref Native.ISteamNetworkingUtils self, float flMaxAgeSeconds);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter(ref Native.ISteamNetworkingUtils self, uint popID, ref uint pViaRelayPoP);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP(ref Native.ISteamNetworkingUtils self, uint popID);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingUtils_GetPOPCount(ref Native.ISteamNetworkingUtils self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern int SteamAPI_ISteamNetworkingUtils_GetPOPList(ref Native.ISteamNetworkingUtils self, ref uint list, int nListSz);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern long SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp(ref Native.ISteamNetworkingUtils self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingSocketsDebugOutputType eDetailLevel, Native.FSteamNetworkingSocketsDebugOutput pfnFunc);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingConfigValue eValue, int val);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingConfigValue eValue, float val);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingConfigValue eValue, [MarshalAs(UnmanagedType.LPStr)] string val);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingConfigValue eValue, IntPtr val);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32(ref Native.ISteamNetworkingUtils self, uint hConn, Native.ESteamNetworkingConfigValue eValue, int val);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat(ref Native.ISteamNetworkingUtils self, uint hConn, Native.ESteamNetworkingConfigValue eValue, float val);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString(ref Native.ISteamNetworkingUtils self, uint hConn, Native.ESteamNetworkingConfigValue eValue, [MarshalAs(UnmanagedType.LPStr)] string val);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged(ref Native.ISteamNetworkingUtils self, Native.FnSteamNetConnectionStatusChanged fnCallback);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged(ref Native.ISteamNetworkingUtils self, Native.FnSteamNetAuthenticationStatusChanged fnCallback);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged(ref Native.ISteamNetworkingUtils self, Native.FnSteamRelayNetworkStatusChanged fnCallback);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetConfigValue(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingConfigValue eValue, Native.ESteamNetworkingConfigScope eScopeType, long scopeObj, Native.ESteamNetworkingConfigDataType eDataType, IntPtr pArg);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct(ref Native.ISteamNetworkingUtils self, ref Native.SteamNetworkingConfigValue_t opt, Native.ESteamNetworkingConfigScope eScopeType, long scopeObj);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.ESteamNetworkingGetConfigValueResult SteamAPI_ISteamNetworkingUtils_GetConfigValue(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingConfigValue eValue, Native.ESteamNetworkingConfigScope eScopeType, long scopeObj, ref Native.ESteamNetworkingConfigDataType pOutDataType, IntPtr pResult, ref ulong cbResult);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        public static extern string SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingConfigValue eValue, ref Native.ESteamNetworkingConfigDataType pOutDataType, ref Native.ESteamNetworkingConfigScope pOutScope);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Native.ESteamNetworkingConfigValue SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues(ref Native.ISteamNetworkingUtils self, Native.ESteamNetworkingConfigValue eCurrent, [MarshalAs(UnmanagedType.U1)] bool bEnumerateDevVars);

        /// <summary>
        /// SteamNetworkingIPAddr
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIPAddr_Clear(ref Native.SteamNetworkingIPAddr self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros(ref Native.SteamNetworkingIPAddr self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIPAddr_SetIPv6(ref Native.SteamNetworkingIPAddr self, ref byte ipv6, ushort nPort);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIPAddr_SetIPv4(ref Native.SteamNetworkingIPAddr self, uint nIP, ushort nPort);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIPAddr_IsIPv4(ref Native.SteamNetworkingIPAddr self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint SteamAPI_SteamNetworkingIPAddr_GetIPv4(ref Native.SteamNetworkingIPAddr self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost(ref Native.SteamNetworkingIPAddr self, ushort nPort);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIPAddr_IsLocalHost(ref Native.SteamNetworkingIPAddr self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIPAddr_IsEqualTo(ref Native.SteamNetworkingIPAddr self, ref Native.SteamNetworkingIPAddr x);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIPAddr_ToString(in Native.SteamNetworkingIPAddr self, IntPtr buf, ulong cbBuf, [MarshalAs(UnmanagedType.U1)] bool bWithPort);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIPAddr_ParseString(ref Native.SteamNetworkingIPAddr self, [MarshalAs(UnmanagedType.LPStr)] string pszStr);

        /// <summary>
        /// SteamNetworkingIdentity
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIdentity_Clear(ref Native.SteamNetworkingIdentity self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIdentity_IsInvalid(ref Native.SteamNetworkingIdentity self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIdentity_SetSteamID(ref Native.SteamNetworkingIdentity self, ulong steamID);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong SteamAPI_SteamNetworkingIdentity_GetSteamID(ref Native.SteamNetworkingIdentity self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIdentity_SetSteamID64(ref Native.SteamNetworkingIdentity self, ulong steamID);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong SteamAPI_SteamNetworkingIdentity_GetSteamID64(ref Native.SteamNetworkingIdentity self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIdentity_SetIPAddr(ref Native.SteamNetworkingIdentity self, ref Native.SteamNetworkingIPAddr addr);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref readonly Native.SteamNetworkingIPAddr SteamAPI_SteamNetworkingIdentity_GetIPAddr(ref Native.SteamNetworkingIdentity self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIdentity_SetLocalHost(ref Native.SteamNetworkingIdentity self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIdentity_IsLocalHost(ref Native.SteamNetworkingIdentity self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIdentity_SetGenericString(ref Native.SteamNetworkingIdentity self, [MarshalAs(UnmanagedType.LPStr)] string pszString);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        public static extern string SteamAPI_SteamNetworkingIdentity_GetGenericString(ref Native.SteamNetworkingIdentity self);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIdentity_SetGenericBytes(ref Native.SteamNetworkingIdentity self, IntPtr data, uint cbLen);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref byte SteamAPI_SteamNetworkingIdentity_GetGenericBytes(ref Native.SteamNetworkingIdentity self, ref int cbLen);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIdentity_IsEqualTo(ref Native.SteamNetworkingIdentity self, ref Native.SteamNetworkingIdentity x);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingIdentity_ToString(in Native.SteamNetworkingIdentity self, IntPtr buf, ulong cbBuf);

        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_SteamNetworkingIdentity_ParseString(ref Native.SteamNetworkingIdentity self, ulong sizeofIdentity, [MarshalAs(UnmanagedType.LPStr)] string pszStr);

        /// <summary>
        /// SteamNetworkingMessage_t
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamAPI_SteamNetworkingMessage_t_Release(ref Native.SteamNetworkingMessage_t self);

        /// <summary>
        /// Create an ISteamNetworkingConnectionSignaling object from plain C primitives.
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Native.ISteamNetworkingConnectionSignaling SteamAPI_ISteamNetworkingSockets_CreateCustomSignaling(IntPtr ctx, Native.FSteamNetworkingSocketsCustomSignaling_SendSignal fnSendSignal, Native.FSteamNetworkingSocketsCustomSignaling_Release fnRelease);

        /// <summary>
        /// Same as SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal, but using plain C primitives.
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal2(ref Native.ISteamNetworkingSockets self, IntPtr pMsg, int cbMsg, IntPtr ctx, Native.FSteamNetworkingCustomSignalingRecvContext_OnConnectRequest fnOnConnectRequest, Native.FSteamNetworkingCustomSignalingRecvContext_SendRejectionSignal fnSendRejectionSignal);
    }
}
#pragma warning restore IDE0065 // Misplaced using directive
#pragma warning restore IDE1006 // Naming Styles
#pragma warning restore IDE0046 // Convert to conditional expression
#pragma warning restore IDE0007 // Use implicit type
#pragma warning restore IDE0011 // Add braces
#pragma warning restore IDE0034 // Simplify 'default' expression
#pragma warning restore IDE0059 // Unnecessary assignment of a value
#pragma warning restore IDE0018 // Inline variable declaration
#pragma warning restore IDE0044 // Add readonly modifier
