//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Steam
{
    using System.Runtime.InteropServices;
    
    public static partial class Networking
    {
        /// <summary>
        /// This callback is posted whenever a connection is created, destroyed, or changes state.
        /// The m_info field will contain a complete description of the connection at the time the
        /// change occurred and the callback was posted.  In particular, m_eState will have the
        /// new connection state.
        /// </summary>
        /// <remarks>
        /// You will usually need to listen for this callback to know when:
        /// - A new connection arrives on a listen socket.
        /// m_info.m_hListenSocket will be set, m_eOldState = k_ESteamNetworkingConnectionState_None,
        /// and m_info.m_eState = k_ESteamNetworkingConnectionState_Connecting.
        /// See ISteamNetworkigSockets::AcceptConnection.
        /// - A connection you initiated has been accepted by the remote host.
        /// m_eOldState = k_ESteamNetworkingConnectionState_Connecting, and
        /// m_info.m_eState = k_ESteamNetworkingConnectionState_Connected.
        /// Some connections might transition to k_ESteamNetworkingConnectionState_FindingRoute first.
        /// - A connection has been actively rejected or closed by the remote host.
        /// m_eOldState = k_ESteamNetworkingConnectionState_Connecting or k_ESteamNetworkingConnectionState_Connected,
        /// and m_info.m_eState = k_ESteamNetworkingConnectionState_ClosedByPeer.  m_info.m_eEndReason
        /// and m_info.m_szEndDebug will have for more details.
        /// NOTE: upon receiving this callback, you must still destroy the connection using
        /// ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details
        /// passed to the function are not used in this case, since the connection is already closed.)
        /// - A problem was detected with the connection, and it has been closed by the local host.
        /// The most common failure is timeout, but other configuration or authentication failures
        /// can cause this.  m_eOldState = k_ESteamNetworkingConnectionState_Connecting or
        /// k_ESteamNetworkingConnectionState_Connected, and m_info.m_eState = k_ESteamNetworkingConnectionState_ProblemDetectedLocally.
        /// m_info.m_eEndReason and m_info.m_szEndDebug will have for more details.
        /// NOTE: upon receiving this callback, you must still destroy the connection using
        /// ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details
        /// passed to the function are not used in this case, since the connection is already closed.)Remember that callbacks are posted to a queue, and networking connections can
        /// change at any time.  It is possible that the connection has already changed
        /// state by the time you process this callback.Also note that callbacks will be posted when connections are created and destroyed by your own API calls.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetConnectionStatusChangedCallback_t
        {
            public enum SteamNetConnectionStatusChangedCallback_tAnonymousEnum : int
            {
                Icallback = unchecked((int)2000 + 1),
            }
            
            /// <summary>
            /// Connection handle
            /// </summary>
            public Networking.HSteamNetConnection m_hConn;
            
            /// <summary>
            /// Full connection info
            /// </summary>
            public Networking.SteamNetConnectionInfo_t m_info;
            
            /// <summary>
            /// Previous state.  (Current state is in m_info.m_eState)
            /// </summary>
            public Networking.ESteamNetworkingConnectionState m_eOldState;
        }
        
        /// <summary>
        /// A struct used to describe our readiness to participate in authenticated,
        /// encrypted communication.  In order to do this we need:
        /// </summary>
        /// <remarks>
        /// - The list of trusted CA certificates that might be relevant for this
        /// app.
        /// - A valid certificate issued by a CA.This callback is posted whenever the state of our readiness changes.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetAuthenticationStatus_t
        {
            public enum SteamNetAuthenticationStatus_tAnonymousEnum : int
            {
                Icallback = unchecked((int)2000 + 2),
            }
            
            /// <summary>
            /// Status
            /// </summary>
            public Networking.ESteamNetworkingAvailability m_eAvail;
            
            /// <summary>
            /// Non-localized English language status.  For diagnostic/debugging
            /// purposes only.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string m_debugMsg;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamNetworkingFakeIPResult_t : IEquatable<SteamNetworkingFakeIPResult_t>
        {
            private readonly IntPtr _handle;
            
            public SteamNetworkingFakeIPResult_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamNetworkingFakeIPResult_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamNetworkingFakeIPResult_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamNetworkingFakeIPResult_t left, SteamNetworkingFakeIPResult_t right) => left.Equals(right);
            
            public static bool operator !=(SteamNetworkingFakeIPResult_t left, SteamNetworkingFakeIPResult_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ISteamNetworkingFakeUDPPort : IEquatable<ISteamNetworkingFakeUDPPort>
        {
            private readonly IntPtr _handle;
            
            public ISteamNetworkingFakeUDPPort(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ISteamNetworkingFakeUDPPort other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ISteamNetworkingFakeUDPPort other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ISteamNetworkingFakeUDPPort left, ISteamNetworkingFakeUDPPort right) => left.Equals(right);
            
            public static bool operator !=(ISteamNetworkingFakeUDPPort left, ISteamNetworkingFakeUDPPort right) => !left.Equals(right);
        }
        
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Networking.ISteamNetworkingSockets SteamNetworkingSockets_LibV11();
    }
}
