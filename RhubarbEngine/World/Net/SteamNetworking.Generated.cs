//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Steam
{
    using System.Runtime.InteropServices;
    
    public static partial class Networking
    {
        public enum ESteamIPType : int
        {
            Esteamiptypeipv4 = unchecked((int)0),
            
            Esteamiptypeipv6 = unchecked((int)1),
        }
        
        /// <summary>
        /// Steam universes.  Each universe is a self-contained Steam instance.
        /// </summary>
        public enum EUniverse : int
        {
            Euniverseinvalid = unchecked((int)0),
            
            Euniversepublic = unchecked((int)1),
            
            Euniversebeta = unchecked((int)2),
            
            Euniverseinternal = unchecked((int)3),
            
            Euniversedev = unchecked((int)4),
            
            /// <summary>
            /// k_EUniverseRC = 5,				// no such universe anymore
            /// </summary>
            Euniversemax,
        }
        
        /// <summary>
        /// General result codes
        /// </summary>
        public enum EResult : int
        {
            /// <summary>
            /// no result
            /// </summary>
            Eresultnone = unchecked((int)0),
            
            /// <summary>
            /// success
            /// </summary>
            Eresultok = unchecked((int)1),
            
            /// <summary>
            /// generic failure
            /// </summary>
            Eresultfail = unchecked((int)2),
            
            /// <summary>
            /// no/failed network connection
            /// </summary>
            Eresultnoconnection = unchecked((int)3),
            
            /// <summary>
            /// password/ticket is invalid
            /// </summary>
            Eresultinvalidpassword = unchecked((int)5),
            
            /// <summary>
            /// same user logged in elsewhere
            /// </summary>
            Eresultloggedinelsewhere = unchecked((int)6),
            
            /// <summary>
            /// protocol version is incorrect
            /// </summary>
            Eresultinvalidprotocolver = unchecked((int)7),
            
            /// <summary>
            /// a parameter is incorrect
            /// </summary>
            Eresultinvalidparam = unchecked((int)8),
            
            /// <summary>
            /// file was not found
            /// </summary>
            Eresultfilenotfound = unchecked((int)9),
            
            /// <summary>
            /// called method busy - action not taken
            /// </summary>
            Eresultbusy = unchecked((int)10),
            
            /// <summary>
            /// called object was in an invalid state
            /// </summary>
            Eresultinvalidstate = unchecked((int)11),
            
            /// <summary>
            /// name is invalid
            /// </summary>
            Eresultinvalidname = unchecked((int)12),
            
            /// <summary>
            /// email is invalid
            /// </summary>
            Eresultinvalidemail = unchecked((int)13),
            
            /// <summary>
            /// name is not unique
            /// </summary>
            Eresultduplicatename = unchecked((int)14),
            
            /// <summary>
            /// access is denied
            /// </summary>
            Eresultaccessdenied = unchecked((int)15),
            
            /// <summary>
            /// operation timed out
            /// </summary>
            Eresulttimeout = unchecked((int)16),
            
            /// <summary>
            /// VAC2 banned
            /// </summary>
            Eresultbanned = unchecked((int)17),
            
            /// <summary>
            /// account not found
            /// </summary>
            Eresultaccountnotfound = unchecked((int)18),
            
            /// <summary>
            /// steamID is invalid
            /// </summary>
            Eresultinvalidsteamid = unchecked((int)19),
            
            /// <summary>
            /// The requested service is currently unavailable
            /// </summary>
            Eresultserviceunavailable = unchecked((int)20),
            
            /// <summary>
            /// The user is not logged on
            /// </summary>
            Eresultnotloggedon = unchecked((int)21),
            
            /// <summary>
            /// Request is pending (may be in process, or waiting on third party)
            /// </summary>
            Eresultpending = unchecked((int)22),
            
            /// <summary>
            /// Encryption or Decryption failed
            /// </summary>
            Eresultencryptionfailure = unchecked((int)23),
            
            /// <summary>
            /// Insufficient privilege
            /// </summary>
            Eresultinsufficientprivilege = unchecked((int)24),
            
            /// <summary>
            /// Too much of a good thing
            /// </summary>
            Eresultlimitexceeded = unchecked((int)25),
            
            /// <summary>
            /// Access has been revoked (used for revoked guest passes)
            /// </summary>
            Eresultrevoked = unchecked((int)26),
            
            /// <summary>
            /// License/Guest pass the user is trying to access is expired
            /// </summary>
            Eresultexpired = unchecked((int)27),
            
            /// <summary>
            /// Guest pass has already been redeemed by account, cannot be acked again
            /// </summary>
            Eresultalreadyredeemed = unchecked((int)28),
            
            /// <summary>
            /// The request is a duplicate and the action has already occurred in the past, ignored this time
            /// </summary>
            Eresultduplicaterequest = unchecked((int)29),
            
            /// <summary>
            /// All the games in this guest pass redemption request are already owned by the user
            /// </summary>
            Eresultalreadyowned = unchecked((int)30),
            
            /// <summary>
            /// IP address not found
            /// </summary>
            Eresultipnotfound = unchecked((int)31),
            
            /// <summary>
            /// failed to write change to the data store
            /// </summary>
            Eresultpersistfailed = unchecked((int)32),
            
            /// <summary>
            /// failed to acquire access lock for this operation
            /// </summary>
            Eresultlockingfailed = unchecked((int)33),
            
            Eresultlogonsessionreplaced = unchecked((int)34),
            
            Eresultconnectfailed = unchecked((int)35),
            
            Eresulthandshakefailed = unchecked((int)36),
            
            Eresultiofailure = unchecked((int)37),
            
            Eresultremotedisconnect = unchecked((int)38),
            
            /// <summary>
            /// failed to find the shopping cart requested
            /// </summary>
            Eresultshoppingcartnotfound = unchecked((int)39),
            
            /// <summary>
            /// a user didn't allow it
            /// </summary>
            Eresultblocked = unchecked((int)40),
            
            /// <summary>
            /// target is ignoring sender
            /// </summary>
            Eresultignored = unchecked((int)41),
            
            /// <summary>
            /// nothing matching the request found
            /// </summary>
            Eresultnomatch = unchecked((int)42),
            
            Eresultaccountdisabled = unchecked((int)43),
            
            /// <summary>
            /// this service is not accepting content changes right now
            /// </summary>
            Eresultservicereadonly = unchecked((int)44),
            
            /// <summary>
            /// account doesn't have value, so this feature isn't available
            /// </summary>
            Eresultaccountnotfeatured = unchecked((int)45),
            
            /// <summary>
            /// allowed to take this action, but only because requester is admin
            /// </summary>
            Eresultadministratorok = unchecked((int)46),
            
            /// <summary>
            /// A Version mismatch in content transmitted within the Steam protocol.
            /// </summary>
            Eresultcontentversion = unchecked((int)47),
            
            /// <summary>
            /// The current CM can't service the user making a request, user should try another.
            /// </summary>
            Eresulttryanothercm = unchecked((int)48),
            
            /// <summary>
            /// You are already logged in elsewhere, this cached credential login has failed.
            /// </summary>
            Eresultpasswordrequiredtokicksession = unchecked((int)49),
            
            /// <summary>
            /// You are already logged in elsewhere, you must wait
            /// </summary>
            Eresultalreadyloggedinelsewhere = unchecked((int)50),
            
            /// <summary>
            /// Long running operation (content download) suspended/paused
            /// </summary>
            Eresultsuspended = unchecked((int)51),
            
            /// <summary>
            /// Operation canceled (typically by user: content download)
            /// </summary>
            Eresultcancelled = unchecked((int)52),
            
            /// <summary>
            /// Operation canceled because data is ill formed or unrecoverable
            /// </summary>
            Eresultdatacorruption = unchecked((int)53),
            
            /// <summary>
            /// Operation canceled - not enough disk space.
            /// </summary>
            Eresultdiskfull = unchecked((int)54),
            
            /// <summary>
            /// an remote call or IPC call failed
            /// </summary>
            Eresultremotecallfailed = unchecked((int)55),
            
            /// <summary>
            /// Password could not be verified as it's unset server side
            /// </summary>
            Eresultpasswordunset = unchecked((int)56),
            
            /// <summary>
            /// External account (PSN, Facebook...) is not linked to a Steam account
            /// </summary>
            Eresultexternalaccountunlinked = unchecked((int)57),
            
            /// <summary>
            /// PSN ticket was invalid
            /// </summary>
            Eresultpsnticketinvalid = unchecked((int)58),
            
            /// <summary>
            /// External account (PSN, Facebook...) is already linked to some other account, must explicitly request to replace/delete the link first
            /// </summary>
            Eresultexternalaccountalreadylinked = unchecked((int)59),
            
            /// <summary>
            /// The sync cannot resume due to a conflict between the local and remote files
            /// </summary>
            Eresultremotefileconflict = unchecked((int)60),
            
            /// <summary>
            /// The requested new password is not legal
            /// </summary>
            Eresultillegalpassword = unchecked((int)61),
            
            /// <summary>
            /// new value is the same as the old one ( secret question and answer )
            /// </summary>
            Eresultsameaspreviousvalue = unchecked((int)62),
            
            /// <summary>
            /// account login denied due to 2nd factor authentication failure
            /// </summary>
            Eresultaccountlogondenied = unchecked((int)63),
            
            /// <summary>
            /// The requested new password is not legal
            /// </summary>
            Eresultcannotuseoldpassword = unchecked((int)64),
            
            /// <summary>
            /// account login denied due to auth code invalid
            /// </summary>
            Eresultinvalidloginauthcode = unchecked((int)65),
            
            /// <summary>
            /// account login denied due to 2nd factor auth failure - and no mail has been sent
            /// </summary>
            Eresultaccountlogondeniednomail = unchecked((int)66),
            
            /// <summary>
            /// 
            /// </summary>
            Eresulthardwarenotcapableofipt = unchecked((int)67),
            
            /// <summary>
            /// 
            /// </summary>
            Eresultiptiniterror = unchecked((int)68),
            
            /// <summary>
            /// operation failed due to parental control restrictions for current user
            /// </summary>
            Eresultparentalcontrolrestricted = unchecked((int)69),
            
            /// <summary>
            /// Facebook query returned an error
            /// </summary>
            Eresultfacebookqueryerror = unchecked((int)70),
            
            /// <summary>
            /// account login denied due to auth code expired
            /// </summary>
            Eresultexpiredloginauthcode = unchecked((int)71),
            
            Eresultiploginrestrictionfailed = unchecked((int)72),
            
            Eresultaccountlockeddown = unchecked((int)73),
            
            Eresultaccountlogondeniedverifiedemailrequired = unchecked((int)74),
            
            Eresultnomatchingurl = unchecked((int)75),
            
            /// <summary>
            /// parse failure, missing field, etc.
            /// </summary>
            Eresultbadresponse = unchecked((int)76),
            
            /// <summary>
            /// The user cannot complete the action until they re-enter their password
            /// </summary>
            Eresultrequirepasswordreentry = unchecked((int)77),
            
            /// <summary>
            /// the value entered is outside the acceptable range
            /// </summary>
            Eresultvalueoutofrange = unchecked((int)78),
            
            /// <summary>
            /// something happened that we didn't expect to ever happen
            /// </summary>
            Eresultunexpectederror = unchecked((int)79),
            
            /// <summary>
            /// The requested service has been configured to be unavailable
            /// </summary>
            Eresultdisabled = unchecked((int)80),
            
            /// <summary>
            /// The set of files submitted to the CEG server are not valid !
            /// </summary>
            Eresultinvalidcegsubmission = unchecked((int)81),
            
            /// <summary>
            /// The device being used is not allowed to perform this action
            /// </summary>
            Eresultrestricteddevice = unchecked((int)82),
            
            /// <summary>
            /// The action could not be complete because it is region restricted
            /// </summary>
            Eresultregionlocked = unchecked((int)83),
            
            /// <summary>
            /// Temporary rate limit exceeded, try again later, different from k_EResultLimitExceeded which may be permanent
            /// </summary>
            Eresultratelimitexceeded = unchecked((int)84),
            
            /// <summary>
            /// Need two-factor code to login
            /// </summary>
            Eresultaccountlogindeniedneedtwofactor = unchecked((int)85),
            
            /// <summary>
            /// The thing we're trying to access has been deleted
            /// </summary>
            Eresultitemdeleted = unchecked((int)86),
            
            /// <summary>
            /// login attempt failed, try to throttle response to possible attacker
            /// </summary>
            Eresultaccountlogindeniedthrottle = unchecked((int)87),
            
            /// <summary>
            /// two factor code mismatch
            /// </summary>
            Eresulttwofactorcodemismatch = unchecked((int)88),
            
            /// <summary>
            /// activation code for two-factor didn't match
            /// </summary>
            Eresulttwofactoractivationcodemismatch = unchecked((int)89),
            
            /// <summary>
            /// account has been associated with multiple partners
            /// </summary>
            Eresultaccountassociatedtomultiplepartners = unchecked((int)90),
            
            /// <summary>
            /// data not modified
            /// </summary>
            Eresultnotmodified = unchecked((int)91),
            
            /// <summary>
            /// the account does not have a mobile device associated with it
            /// </summary>
            Eresultnomobiledevice = unchecked((int)92),
            
            /// <summary>
            /// the time presented is out of range or tolerance
            /// </summary>
            Eresulttimenotsynced = unchecked((int)93),
            
            /// <summary>
            /// SMS code failure (no match, none pending, etc.)
            /// </summary>
            Eresultsmscodefailed = unchecked((int)94),
            
            /// <summary>
            /// Too many accounts access this resource
            /// </summary>
            Eresultaccountlimitexceeded = unchecked((int)95),
            
            /// <summary>
            /// Too many changes to this account
            /// </summary>
            Eresultaccountactivitylimitexceeded = unchecked((int)96),
            
            /// <summary>
            /// Too many changes to this phone
            /// </summary>
            Eresultphoneactivitylimitexceeded = unchecked((int)97),
            
            /// <summary>
            /// Cannot refund to payment method, must use wallet
            /// </summary>
            Eresultrefundtowallet = unchecked((int)98),
            
            /// <summary>
            /// Cannot send an email
            /// </summary>
            Eresultemailsendfailure = unchecked((int)99),
            
            /// <summary>
            /// Can't perform operation till payment has settled
            /// </summary>
            Eresultnotsettled = unchecked((int)100),
            
            /// <summary>
            /// Needs to provide a valid captcha
            /// </summary>
            Eresultneedcaptcha = unchecked((int)101),
            
            /// <summary>
            /// a game server login token owned by this token's owner has been banned
            /// </summary>
            Eresultgsltdenied = unchecked((int)102),
            
            /// <summary>
            /// game server owner is denied for other reason (account lock, community ban, vac ban, missing phone)
            /// </summary>
            Eresultgsownerdenied = unchecked((int)103),
            
            /// <summary>
            /// the type of thing we were requested to act on is invalid
            /// </summary>
            Eresultinvaliditemtype = unchecked((int)104),
            
            /// <summary>
            /// the ip address has been banned from taking this action
            /// </summary>
            Eresultipbanned = unchecked((int)105),
            
            /// <summary>
            /// this token has expired from disuse; can be reset for use
            /// </summary>
            Eresultgsltexpired = unchecked((int)106),
            
            /// <summary>
            /// user doesn't have enough wallet funds to complete the action
            /// </summary>
            Eresultinsufficientfunds = unchecked((int)107),
            
            /// <summary>
            /// There are too many of this thing pending already
            /// </summary>
            Eresulttoomanypending = unchecked((int)108),
            
            /// <summary>
            /// No site licenses found
            /// </summary>
            Eresultnositelicensesfound = unchecked((int)109),
            
            /// <summary>
            /// the WG couldn't send a response because we exceeded max network send size
            /// </summary>
            Eresultwgnetworksendexceeded = unchecked((int)110),
            
            /// <summary>
            /// the user is not mutually friends
            /// </summary>
            Eresultaccountnotfriends = unchecked((int)111),
            
            /// <summary>
            /// the user is limited
            /// </summary>
            Eresultlimiteduseraccount = unchecked((int)112),
            
            /// <summary>
            /// item can't be removed
            /// </summary>
            Eresultcantremoveitem = unchecked((int)113),
            
            /// <summary>
            /// account has been deleted
            /// </summary>
            Eresultaccountdeleted = unchecked((int)114),
            
            /// <summary>
            /// A license for this already exists, but cancelled
            /// </summary>
            Eresultexistingusercancelledlicense = unchecked((int)115),
            
            /// <summary>
            /// access is denied because of a community cooldown (probably from support profile data resets)
            /// </summary>
            Eresultcommunitycooldown = unchecked((int)116),
            
            /// <summary>
            /// No launcher was specified, but a launcher was needed to choose correct realm for operation.
            /// </summary>
            Eresultnolauncherspecified = unchecked((int)117),
            
            /// <summary>
            /// User must agree to china SSA or global SSA before login
            /// </summary>
            Eresultmustagreetossa = unchecked((int)118),
            
            /// <summary>
            /// The specified launcher type is no longer supported; the user should be directed elsewhere
            /// </summary>
            Eresultlaunchermigrated = unchecked((int)119),
            
            /// <summary>
            /// The user's realm does not match the realm of the requested resource
            /// </summary>
            Eresultsteamrealmmismatch = unchecked((int)120),
            
            /// <summary>
            /// signature check did not match
            /// </summary>
            Eresultinvalidsignature = unchecked((int)121),
            
            /// <summary>
            /// Failed to parse input
            /// </summary>
            Eresultparsefailure = unchecked((int)122),
            
            /// <summary>
            /// account does not have a verified phone number
            /// </summary>
            Eresultnoverifiedphone = unchecked((int)123),
        }
        
        /// <summary>
        /// Error codes for use with the voice functions
        /// </summary>
        public enum EVoiceResult : int
        {
            Evoiceresultok = unchecked((int)0),
            
            Evoiceresultnotinitialized = unchecked((int)1),
            
            Evoiceresultnotrecording = unchecked((int)2),
            
            Evoiceresultnodata = unchecked((int)3),
            
            Evoiceresultbuffertoosmall = unchecked((int)4),
            
            Evoiceresultdatacorrupted = unchecked((int)5),
            
            Evoiceresultrestricted = unchecked((int)6),
            
            Evoiceresultunsupportedcodec = unchecked((int)7),
            
            Evoiceresultreceiveroutofdate = unchecked((int)8),
            
            Evoiceresultreceiverdidnotanswer = unchecked((int)9),
        }
        
        /// <summary>
        /// Result codes to GSHandleClientDeny/Kick
        /// </summary>
        public enum EDenyReason : int
        {
            Edenyinvalid = unchecked((int)0),
            
            Edenyinvalidversion = unchecked((int)1),
            
            Edenygeneric = unchecked((int)2),
            
            Edenynotloggedon = unchecked((int)3),
            
            Edenynolicense = unchecked((int)4),
            
            Edenycheater = unchecked((int)5),
            
            Edenyloggedinelsewhere = unchecked((int)6),
            
            Edenyunknowntext = unchecked((int)7),
            
            Edenyincompatibleanticheat = unchecked((int)8),
            
            Edenymemorycorruption = unchecked((int)9),
            
            Edenyincompatiblesoftware = unchecked((int)10),
            
            Edenysteamconnectionlost = unchecked((int)11),
            
            Edenysteamconnectionerror = unchecked((int)12),
            
            Edenysteamresponsetimedout = unchecked((int)13),
            
            Edenysteamvalidationstalled = unchecked((int)14),
            
            Edenysteamownerleftguestuser = unchecked((int)15),
        }
        
        /// <summary>
        /// results from BeginAuthSession
        /// </summary>
        public enum EBeginAuthSessionResult : int
        {
            /// <summary>
            /// Ticket is valid for this game and this steamID.
            /// </summary>
            Ebeginauthsessionresultok = unchecked((int)0),
            
            /// <summary>
            /// Ticket is not valid.
            /// </summary>
            Ebeginauthsessionresultinvalidticket = unchecked((int)1),
            
            /// <summary>
            /// A ticket has already been submitted for this steamID
            /// </summary>
            Ebeginauthsessionresultduplicaterequest = unchecked((int)2),
            
            /// <summary>
            /// Ticket is from an incompatible interface version
            /// </summary>
            Ebeginauthsessionresultinvalidversion = unchecked((int)3),
            
            /// <summary>
            /// Ticket is not for this game
            /// </summary>
            Ebeginauthsessionresultgamemismatch = unchecked((int)4),
            
            /// <summary>
            /// Ticket has expired
            /// </summary>
            Ebeginauthsessionresultexpiredticket = unchecked((int)5),
        }
        
        /// <summary>
        /// Callback values for callback ValidateAuthTicketResponse_t which is a response to BeginAuthSession
        /// </summary>
        public enum EAuthSessionResponse : int
        {
            /// <summary>
            /// Steam has verified the user is online, the ticket is valid and ticket has not been reused.
            /// </summary>
            Eauthsessionresponseok = unchecked((int)0),
            
            /// <summary>
            /// The user in question is not connected to steam
            /// </summary>
            Eauthsessionresponseusernotconnectedtosteam = unchecked((int)1),
            
            /// <summary>
            /// The license has expired.
            /// </summary>
            Eauthsessionresponsenolicenseorexpired = unchecked((int)2),
            
            /// <summary>
            /// The user is VAC banned for this game.
            /// </summary>
            Eauthsessionresponsevacbanned = unchecked((int)3),
            
            /// <summary>
            /// The user account has logged in elsewhere and the session containing the game instance has been disconnected.
            /// </summary>
            Eauthsessionresponseloggedinelsewhere = unchecked((int)4),
            
            /// <summary>
            /// VAC has been unable to perform anti-cheat checks on this user
            /// </summary>
            Eauthsessionresponsevacchecktimedout = unchecked((int)5),
            
            /// <summary>
            /// The ticket has been canceled by the issuer
            /// </summary>
            Eauthsessionresponseauthticketcanceled = unchecked((int)6),
            
            /// <summary>
            /// This ticket has already been used, it is not valid.
            /// </summary>
            Eauthsessionresponseauthticketinvalidalreadyused = unchecked((int)7),
            
            /// <summary>
            /// This ticket is not from a user instance currently connected to steam.
            /// </summary>
            Eauthsessionresponseauthticketinvalid = unchecked((int)8),
            
            /// <summary>
            /// The user is banned for this game. The ban came via the web api and not VAC
            /// </summary>
            Eauthsessionresponsepublisherissuedban = unchecked((int)9),
        }
        
        /// <summary>
        /// results from UserHasLicenseForApp
        /// </summary>
        public enum EUserHasLicenseForAppResult : int
        {
            /// <summary>
            /// User has a license for specified app
            /// </summary>
            Euserhaslicenseresulthaslicense = unchecked((int)0),
            
            /// <summary>
            /// User does not have a license for the specified app
            /// </summary>
            Euserhaslicenseresultdoesnothavelicense = unchecked((int)1),
            
            /// <summary>
            /// User has not been authenticated
            /// </summary>
            Euserhaslicenseresultnoauth = unchecked((int)2),
        }
        
        /// <summary>
        /// Steam account types
        /// </summary>
        public enum EAccountType : int
        {
            Eaccounttypeinvalid = unchecked((int)0),
            
            /// <summary>
            /// single user account
            /// </summary>
            Eaccounttypeindividual = unchecked((int)1),
            
            /// <summary>
            /// multiseat (e.g. cybercafe) account
            /// </summary>
            Eaccounttypemultiseat = unchecked((int)2),
            
            /// <summary>
            /// game server account
            /// </summary>
            Eaccounttypegameserver = unchecked((int)3),
            
            /// <summary>
            /// anonymous game server account
            /// </summary>
            Eaccounttypeanongameserver = unchecked((int)4),
            
            /// <summary>
            /// pending
            /// </summary>
            Eaccounttypepending = unchecked((int)5),
            
            /// <summary>
            /// content server
            /// </summary>
            Eaccounttypecontentserver = unchecked((int)6),
            
            Eaccounttypeclan = unchecked((int)7),
            
            Eaccounttypechat = unchecked((int)8),
            
            /// <summary>
            /// Fake SteamID for local PSN account on PS3 or Live account on 360, etc.
            /// </summary>
            Eaccounttypeconsoleuser = unchecked((int)9),
            
            Eaccounttypeanonuser = unchecked((int)10),
            
            /// <summary>
            /// Max of 16 items in this field
            /// </summary>
            Eaccounttypemax,
        }
        
        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Chat Entry Types (previously was only friend-to-friend message types)
        /// -----------------------------------------------------------------------------
        /// </summary>
        public enum EChatEntryType : int
        {
            Echatentrytypeinvalid = unchecked((int)0),
            
            /// <summary>
            /// Normal text message from another user
            /// </summary>
            Echatentrytypechatmsg = unchecked((int)1),
            
            /// <summary>
            /// Another user is typing (not used in multi-user chat)
            /// </summary>
            Echatentrytypetyping = unchecked((int)2),
            
            /// <summary>
            /// Invite from other user into that users current game
            /// </summary>
            Echatentrytypeinvitegame = unchecked((int)3),
            
            /// <summary>
            /// text emote message (deprecated, should be treated as ChatMsg)
            /// </summary>
            Echatentrytypeemote = unchecked((int)4),
            
            /// <summary>
            /// user has left the conversation ( closed chat window )
            /// </summary>
            Echatentrytypeleftconversation = unchecked((int)6),
            
            /// <summary>
            /// user has entered the conversation (used in multi-user chat and group chat)
            /// </summary>
            Echatentrytypeentered = unchecked((int)7),
            
            /// <summary>
            /// user was kicked (data: 64-bit steamid of actor performing the kick)
            /// </summary>
            Echatentrytypewaskicked = unchecked((int)8),
            
            /// <summary>
            /// user was banned (data: 64-bit steamid of actor performing the ban)
            /// </summary>
            Echatentrytypewasbanned = unchecked((int)9),
            
            /// <summary>
            /// user disconnected
            /// </summary>
            Echatentrytypedisconnected = unchecked((int)10),
            
            /// <summary>
            /// a chat message from user's chat history or offilne message
            /// </summary>
            Echatentrytypehistoricalchat = unchecked((int)11),
            
            /// <summary>
            /// a link was removed by the chat filter.
            /// </summary>
            Echatentrytypelinkblocked = unchecked((int)14),
        }
        
        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Chat Room Enter Responses
        /// -----------------------------------------------------------------------------
        /// </summary>
        public enum EChatRoomEnterResponse : int
        {
            /// <summary>
            /// Success
            /// </summary>
            Echatroomenterresponsesuccess = unchecked((int)1),
            
            /// <summary>
            /// Chat doesn't exist (probably closed)
            /// </summary>
            Echatroomenterresponsedoesntexist = unchecked((int)2),
            
            /// <summary>
            /// General Denied - You don't have the permissions needed to join the chat
            /// </summary>
            Echatroomenterresponsenotallowed = unchecked((int)3),
            
            /// <summary>
            /// Chat room has reached its maximum size
            /// </summary>
            Echatroomenterresponsefull = unchecked((int)4),
            
            /// <summary>
            /// Unexpected Error
            /// </summary>
            Echatroomenterresponseerror = unchecked((int)5),
            
            /// <summary>
            /// You are banned from this chat room and may not join
            /// </summary>
            Echatroomenterresponsebanned = unchecked((int)6),
            
            /// <summary>
            /// Joining this chat is not allowed because you are a limited user (no value on account)
            /// </summary>
            Echatroomenterresponselimited = unchecked((int)7),
            
            /// <summary>
            /// Attempt to join a clan chat when the clan is locked or disabled
            /// </summary>
            Echatroomenterresponseclandisabled = unchecked((int)8),
            
            /// <summary>
            /// Attempt to join a chat when the user has a community lock on their account
            /// </summary>
            Echatroomenterresponsecommunityban = unchecked((int)9),
            
            /// <summary>
            /// Join failed - some member in the chat has blocked you from joining
            /// </summary>
            Echatroomenterresponsememberblockedyou = unchecked((int)10),
            
            /// <summary>
            /// Join failed - you have blocked some member already in the chat
            /// </summary>
            Echatroomenterresponseyoublockedmember = unchecked((int)11),
            
            /// <summary>
            /// Join failed - to many join attempts in a very short period of time
            /// </summary>
            Echatroomenterresponseratelimitexceeded = unchecked((int)15),
        }
        
        /// <summary>
        /// Special flags for Chat accounts - they go in the top 8 bits
        /// of the steam ID's "instance", leaving 12 for the actual instances
        /// </summary>
        public enum EChatSteamIDInstanceFlags : int
        {
            /// <summary>
            /// top 8 bits are flags
            /// </summary>
            Echataccountinstancemask = unchecked((int)0x00000FFF),
            
            /// <summary>
            /// top bit
            /// </summary>
            Echatinstanceflagclan = unchecked((int)(k_unSteamAccountInstanceMask+1)>>1),
            
            /// <summary>
            /// next one down, etc
            /// </summary>
            Echatinstanceflaglobby = unchecked((int)(k_unSteamAccountInstanceMask+1)>>2),
            
            /// <summary>
            /// next one down, etc
            /// </summary>
            Echatinstanceflagmmslobby = unchecked((int)(k_unSteamAccountInstanceMask+1)>>3),
        }
        
        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Possible positions to tell the overlay to show notifications in
        /// -----------------------------------------------------------------------------
        /// </summary>
        public enum ENotificationPosition : int
        {
            Epositiontopleft = unchecked((int)0),
            
            Epositiontopright = unchecked((int)1),
            
            Epositionbottomleft = unchecked((int)2),
            
            Epositionbottomright = unchecked((int)3),
        }
        
        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Broadcast upload result details
        /// -----------------------------------------------------------------------------
        /// </summary>
        public enum EBroadcastUploadResult : int
        {
            /// <summary>
            /// broadcast state unknown
            /// </summary>
            Ebroadcastuploadresultnone = unchecked((int)0),
            
            /// <summary>
            /// broadcast was good, no problems
            /// </summary>
            Ebroadcastuploadresultok = unchecked((int)1),
            
            /// <summary>
            /// broadcast init failed
            /// </summary>
            Ebroadcastuploadresultinitfailed = unchecked((int)2),
            
            /// <summary>
            /// broadcast frame upload failed
            /// </summary>
            Ebroadcastuploadresultframefailed = unchecked((int)3),
            
            /// <summary>
            /// broadcast upload timed out
            /// </summary>
            Ebroadcastuploadresulttimeout = unchecked((int)4),
            
            /// <summary>
            /// broadcast send too much data
            /// </summary>
            Ebroadcastuploadresultbandwidthexceeded = unchecked((int)5),
            
            /// <summary>
            /// broadcast FPS too low
            /// </summary>
            Ebroadcastuploadresultlowfps = unchecked((int)6),
            
            /// <summary>
            /// broadcast sending not enough key frames
            /// </summary>
            Ebroadcastuploadresultmissingkeyframes = unchecked((int)7),
            
            /// <summary>
            /// broadcast client failed to connect to relay
            /// </summary>
            Ebroadcastuploadresultnoconnection = unchecked((int)8),
            
            /// <summary>
            /// relay dropped the upload
            /// </summary>
            Ebroadcastuploadresultrelayfailed = unchecked((int)9),
            
            /// <summary>
            /// the client changed broadcast settings
            /// </summary>
            Ebroadcastuploadresultsettingschanged = unchecked((int)10),
            
            /// <summary>
            /// client failed to send audio data
            /// </summary>
            Ebroadcastuploadresultmissingaudio = unchecked((int)11),
            
            /// <summary>
            /// clients was too slow uploading
            /// </summary>
            Ebroadcastuploadresulttoofarbehind = unchecked((int)12),
            
            /// <summary>
            /// server failed to keep up with transcode
            /// </summary>
            Ebroadcastuploadresulttranscodebehind = unchecked((int)13),
            
            /// <summary>
            /// Broadcast does not have permissions to play game
            /// </summary>
            Ebroadcastuploadresultnotallowedtoplay = unchecked((int)14),
            
            /// <summary>
            /// RTMP host to busy to take new broadcast stream, choose another
            /// </summary>
            Ebroadcastuploadresultbusy = unchecked((int)15),
            
            /// <summary>
            /// Account banned from community broadcast
            /// </summary>
            Ebroadcastuploadresultbanned = unchecked((int)16),
            
            /// <summary>
            /// We already already have an stream running.
            /// </summary>
            Ebroadcastuploadresultalreadyactive = unchecked((int)17),
            
            /// <summary>
            /// We explicitly shutting down a broadcast
            /// </summary>
            Ebroadcastuploadresultforcedoff = unchecked((int)18),
            
            /// <summary>
            /// Audio stream was too far behind video
            /// </summary>
            Ebroadcastuploadresultaudiobehind = unchecked((int)19),
            
            /// <summary>
            /// Broadcast Server was shut down
            /// </summary>
            Ebroadcastuploadresultshutdown = unchecked((int)20),
            
            /// <summary>
            /// broadcast uploader TCP disconnected
            /// </summary>
            Ebroadcastuploadresultdisconnect = unchecked((int)21),
            
            /// <summary>
            /// invalid video settings
            /// </summary>
            Ebroadcastuploadresultvideoinitfailed = unchecked((int)22),
            
            /// <summary>
            /// invalid audio settings
            /// </summary>
            Ebroadcastuploadresultaudioinitfailed = unchecked((int)23),
        }
        
        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: Reasons a user may not use the Community Market.
        /// Used in MarketEligibilityResponse_t.
        /// -----------------------------------------------------------------------------
        /// </summary>
        [Flags]
        public enum EMarketNotAllowedReasonFlags : int
        {
            EmarketnotallowedreasonNone = unchecked((int)0),
            
            /// <summary>
            /// A back-end call failed or something that might work again on retry
            /// </summary>
            EmarketnotallowedreasonTemporaryfailure = unchecked((int)(1  << (int) 0)),
            
            /// <summary>
            /// Disabled account
            /// </summary>
            EmarketnotallowedreasonAccountdisabled = unchecked((int)(1  << (int) 1)),
            
            /// <summary>
            /// Locked account
            /// </summary>
            EmarketnotallowedreasonAccountlockeddown = unchecked((int)(1  << (int) 2)),
            
            /// <summary>
            /// Limited account (no purchases)
            /// </summary>
            EmarketnotallowedreasonAccountlimited = unchecked((int)(1  << (int) 3)),
            
            /// <summary>
            /// The account is banned from trading items
            /// </summary>
            EmarketnotallowedreasonTradebanned = unchecked((int)(1  << (int) 4)),
            
            /// <summary>
            /// Wallet funds aren't tradable because the user has had no purchase
            /// activity in the last year or has had no purchases prior to last month
            /// </summary>
            EmarketnotallowedreasonAccountnottrusted = unchecked((int)(1  << (int) 5)),
            
            /// <summary>
            /// The user doesn't have Steam Guard enabled
            /// </summary>
            EmarketnotallowedreasonSteamguardnotenabled = unchecked((int)(1  << (int) 6)),
            
            /// <summary>
            /// The user has Steam Guard, but it hasn't been enabled for the required
            /// number of days
            /// </summary>
            EmarketnotallowedreasonSteamguardonlyrecentlyenabled = unchecked((int)(1  << (int) 7)),
            
            /// <summary>
            /// The user has recently forgotten their password and reset it
            /// </summary>
            EmarketnotallowedreasonRecentpasswordreset = unchecked((int)(1  << (int) 8)),
            
            /// <summary>
            /// The user has recently funded his or her wallet with a new payment method
            /// </summary>
            EmarketnotallowedreasonNewpaymentmethod = unchecked((int)(1  << (int) 9)),
            
            /// <summary>
            /// An invalid cookie was sent by the user
            /// </summary>
            EmarketnotallowedreasonInvalidcookie = unchecked((int)(1  << (int) 10)),
            
            /// <summary>
            /// The user has Steam Guard, but is using a new computer or web browser
            /// </summary>
            EmarketnotallowedreasonUsingnewdevice = unchecked((int)(1  << (int) 11)),
            
            /// <summary>
            /// The user has recently refunded a store purchase by his or herself
            /// </summary>
            EmarketnotallowedreasonRecentselfrefund = unchecked((int)(1  << (int) 12)),
            
            /// <summary>
            /// The user has recently funded his or her wallet with a new payment method that cannot be verified
            /// </summary>
            EmarketnotallowedreasonNewpaymentmethodcannotbeverified = unchecked((int)(1  << (int) 13)),
            
            /// <summary>
            /// Not only is the account not trusted, but they have no recent purchases at all
            /// </summary>
            EmarketnotallowedreasonNorecentpurchases = unchecked((int)(1  << (int) 14)),
            
            /// <summary>
            /// User accepted a wallet gift that was recently purchased
            /// </summary>
            EmarketnotallowedreasonAcceptedwalletgift = unchecked((int)(1  << (int) 15)),
        }
        
        /// <summary>
        /// describes XP / progress restrictions to apply for games with duration control /
        /// anti-indulgence enabled for minor Steam China users.
        /// </summary>
        /// <remarks>
        /// WARNING: DO NOT RENUMBER
        /// </remarks>
        public enum EDurationControlProgress : int
        {
            /// <summary>
            /// Full progress
            /// </summary>
            EdurationcontrolprogressFull = unchecked((int)0),
            
            /// <summary>
            /// deprecated - XP or persistent rewards should be halved
            /// </summary>
            EdurationcontrolprogressHalf = unchecked((int)1),
            
            /// <summary>
            /// deprecated - XP or persistent rewards should be stopped
            /// </summary>
            EdurationcontrolprogressNone = unchecked((int)2),
            
            /// <summary>
            /// allowed 3h time since 5h gap/break has elapsed, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolExitsoon3h = unchecked((int)3),
            
            /// <summary>
            /// allowed 5h time in calendar day has elapsed, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolExitsoon5h = unchecked((int)4),
            
            /// <summary>
            /// game running after day period, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolExitsoonNight = unchecked((int)5),
        }
        
        /// <summary>
        /// describes which notification timer has expired, for steam china duration control feature
        /// </summary>
        /// <remarks>
        /// WARNING: DO NOT RENUMBER
        /// </remarks>
        public enum EDurationControlNotification : int
        {
            /// <summary>
            /// just informing you about progress, no notification to show
            /// </summary>
            EdurationcontrolnotificationNone = unchecked((int)0),
            
            /// <summary>
            /// "you've been playing for N hours"
            /// </summary>
            Edurationcontrolnotification1hour = unchecked((int)1),
            
            /// <summary>
            /// deprecated - "you've been playing for 3 hours; take a break"
            /// </summary>
            Edurationcontrolnotification3hours = unchecked((int)2),
            
            /// <summary>
            /// deprecated - "your XP / progress is half normal"
            /// </summary>
            EdurationcontrolnotificationHalfprogress = unchecked((int)3),
            
            /// <summary>
            /// deprecated - "your XP / progress is zero"
            /// </summary>
            EdurationcontrolnotificationNoprogress = unchecked((int)4),
            
            /// <summary>
            /// allowed 3h time since 5h gap/break has elapsed, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolnotificationExitsoon3h = unchecked((int)5),
            
            /// <summary>
            /// allowed 5h time in calendar day has elapsed, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolnotificationExitsoon5h = unchecked((int)6),
            
            /// <summary>
            /// game running after day period, game should exit - steam will terminate the game soon
            /// </summary>
            EdurationcontrolnotificationExitsoonNight = unchecked((int)7),
        }
        
        /// <summary>
        /// Specifies a game's online state in relation to duration control
        /// </summary>
        public enum EDurationControlOnlineState : int
        {
            /// <summary>
            /// nil value
            /// </summary>
            EdurationcontrolonlinestateInvalid = unchecked((int)0),
            
            /// <summary>
            /// currently in offline play - single-player, offline co-op, etc.
            /// </summary>
            EdurationcontrolonlinestateOffline = unchecked((int)1),
            
            /// <summary>
            /// currently in online play
            /// </summary>
            EdurationcontrolonlinestateOnline = unchecked((int)2),
            
            /// <summary>
            /// currently in online play and requests not to be interrupted
            /// </summary>
            EdurationcontrolonlinestateOnlinehighpri = unchecked((int)3),
        }
        
        public enum EGameSearchErrorCode_t : int
        {
            EgamesearcherrorcodeOk = unchecked((int)1),
            
            EgamesearcherrorcodeFailedSearchAlreadyInProgress = unchecked((int)2),
            
            EgamesearcherrorcodeFailedNoSearchInProgress = unchecked((int)3),
            
            /// <summary>
            /// if not the lobby leader can not call SearchForGameWithLobby
            /// </summary>
            EgamesearcherrorcodeFailedNotLobbyLeader = unchecked((int)4),
            
            /// <summary>
            /// no host is available that matches those search params
            /// </summary>
            EgamesearcherrorcodeFailedNoHostAvailable = unchecked((int)5),
            
            /// <summary>
            /// search params are invalid
            /// </summary>
            EgamesearcherrorcodeFailedSearchParamsInvalid = unchecked((int)6),
            
            /// <summary>
            /// offline, could not communicate with server
            /// </summary>
            EgamesearcherrorcodeFailedOffline = unchecked((int)7),
            
            /// <summary>
            /// either the user or the application does not have priveledges to do this
            /// </summary>
            EgamesearcherrorcodeFailedNotauthorized = unchecked((int)8),
            
            /// <summary>
            /// unknown error
            /// </summary>
            EgamesearcherrorcodeFailedUnknownError = unchecked((int)9),
        }
        
        public enum EPlayerResult_t : int
        {
            /// <summary>
            /// failed to connect after confirming
            /// </summary>
            Eplayerresultfailedtoconnect = unchecked((int)1),
            
            /// <summary>
            /// quit game without completing it
            /// </summary>
            Eplayerresultabandoned = unchecked((int)2),
            
            /// <summary>
            /// kicked by other players/moderator/server rules
            /// </summary>
            Eplayerresultkicked = unchecked((int)3),
            
            /// <summary>
            /// player stayed to end but game did not conclude successfully ( nofault to player )
            /// </summary>
            Eplayerresultincomplete = unchecked((int)4),
            
            /// <summary>
            /// player completed game
            /// </summary>
            Eplayerresultcompleted = unchecked((int)5),
        }
        
        public enum ESteamIPv6ConnectivityProtocol : int
        {
            Esteamipv6connectivityprotocolInvalid = unchecked((int)0),
            
            /// <summary>
            /// because a proxy may make this different than other protocols
            /// </summary>
            Esteamipv6connectivityprotocolHttp = unchecked((int)1),
            
            /// <summary>
            /// test UDP connectivity. Uses a port that is commonly needed for other Steam stuff. If UDP works, TCP probably works.
            /// </summary>
            Esteamipv6connectivityprotocolUdp = unchecked((int)2),
        }
        
        /// <summary>
        /// For the above transport protocol, what do we think the local machine's connectivity to the internet over ipv6 is like
        /// </summary>
        public enum ESteamIPv6ConnectivityState : int
        {
            /// <summary>
            /// We haven't run a test yet
            /// </summary>
            Esteamipv6connectivitystateUnknown = unchecked((int)0),
            
            /// <summary>
            /// We have recently been able to make a request on ipv6 for the given protocol
            /// </summary>
            Esteamipv6connectivitystateGood = unchecked((int)1),
            
            /// <summary>
            /// We failed to make a request, either because this machine has no ipv6 address assigned, or it has no upstream connectivity
            /// </summary>
            Esteamipv6connectivitystateBad = unchecked((int)2),
        }
        
        /// <summary>
        /// Different methods of describing the identity of a network host
        /// </summary>
        public enum ESteamNetworkingIdentityType : int
        {
            /// <summary>
            /// Dummy/empty/invalid.
            /// Please note that if we parse a string that we don't recognize
            /// but that appears reasonable, we will NOT use this type.  Instead
            /// we'll use k_ESteamNetworkingIdentityType_UnknownType.
            /// </summary>
            EsteamnetworkingidentitytypeInvalid = unchecked((int)0),
            
            /// <summary>
            /// 64-bit CSteamID
            /// </summary>
            EsteamnetworkingidentitytypeSteamid = unchecked((int)16),
            
            /// <summary>
            /// Use their IP address (and port) as their "identity".
            /// These types of identities are always unauthenticated.
            /// They are useful for porting plain sockets code, and other
            /// situations where you don't care about authentication.  In this
            /// case, the local identity will be "localhost",
            /// and the remote address will be their network address.
            /// </summary>
            /// <remarks>
            /// We use the same type for either IPv4 or IPv6, and
            /// the address is always store as IPv6.  We use IPv4
            /// mapped addresses to handle IPv4.
            /// </remarks>
            EsteamnetworkingidentitytypeIpaddress = unchecked((int)1),
            
            /// <summary>
            /// Generic string/binary blobs.  It's up to your app to interpret this.
            /// This library can tell you if the remote host presented a certificate
            /// signed by somebody you have chosen to trust, with this identity on it.
            /// It's up to you to ultimately decide what this identity means.
            /// </summary>
            EsteamnetworkingidentitytypeGenericstring = unchecked((int)2),
            
            /// <summary>
            /// Generic string/binary blobs.  It's up to your app to interpret this.
            /// This library can tell you if the remote host presented a certificate
            /// signed by somebody you have chosen to trust, with this identity on it.
            /// It's up to you to ultimately decide what this identity means.
            /// </summary>
            EsteamnetworkingidentitytypeGenericbytes = unchecked((int)3),
            
            /// <summary>
            /// This identity type is used when we parse a string that looks like is a
            /// valid identity, just of a kind that we don't recognize.  In this case, we
            /// can often still communicate with the peer!  Allowing such identities
            /// for types we do not recognize useful is very useful for forward
            /// compatibility.
            /// </summary>
            EsteamnetworkingidentitytypeUnknowntype = unchecked((int)4),
            
            /// <summary>
            /// Make sure this enum is stored in an int.
            /// </summary>
            EsteamnetworkingidentitytypeForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// "Fake IPs" are assigned to hosts, to make it easier to interface with
        /// older code that assumed all hosts will have an IPv4 address
        /// </summary>
        public enum ESteamNetworkingFakeIPType : int
        {
            /// <summary>
            /// Error, argument was not even an IP address, etc.
            /// </summary>
            EsteamnetworkingfakeiptypeInvalid,
            
            /// <summary>
            /// Argument was a valid IP, but was not from the reserved "fake" range
            /// </summary>
            EsteamnetworkingfakeiptypeNotfake,
            
            /// <summary>
            /// Globally unique (for a given app) IPv4 address.  Address space managed by Steam
            /// </summary>
            EsteamnetworkingfakeiptypeGlobalipv4,
            
            /// <summary>
            /// Locally unique IPv4 address.  Address space managed by the local process.  For internal use only; should not be shared!
            /// </summary>
            EsteamnetworkingfakeiptypeLocalipv4,
            
            EsteamnetworkingfakeiptypeForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// High level connection status
        /// </summary>
        public enum ESteamNetworkingConnectionState : int
        {
            /// <summary>
            /// Dummy value used to indicate an error condition in the API.
            /// Specified connection doesn't exist or has already been closed.
            /// </summary>
            EsteamnetworkingconnectionstateNone = unchecked((int)0),
            
            /// <summary>
            /// We are trying to establish whether peers can talk to each other,
            /// whether they WANT to talk to each other, perform basic auth,
            /// and exchange crypt keys.
            /// </summary>
            /// <remarks>
            /// - For connections on the "client" side (initiated locally):
            /// We're in the process of trying to establish a connection.
            /// Depending on the connection type, we might not know who they are.
            /// Note that it is not possible to tell if we are waiting on the
            /// network to complete handshake packets, or for the application layer
            /// to accept the connection.- For connections on the "server" side (accepted through listen socket):
            /// We have completed some basic handshake and the client has presented
            /// some proof of identity.  The connection is ready to be accepted
            /// using AcceptConnection().In either case, any unreliable packets sent now are almost certain
            /// to be dropped.  Attempts to receive packets are guaranteed to fail.
            /// You may send messages if the send mode allows for them to be queued.
            /// but if you close the connection before the connection is actually
            /// established, any queued messages will be discarded immediately.
            /// (We will not attempt to flush the queue and confirm delivery to the
            /// remote host, which ordinarily happens when a connection is closed.)
            /// </remarks>
            EsteamnetworkingconnectionstateConnecting = unchecked((int)1),
            
            /// <summary>
            /// Some connection types use a back channel or trusted 3rd party
            /// for earliest communication.  If the server accepts the connection,
            /// then these connections switch into the rendezvous state.  During this
            /// state, we still have not yet established an end-to-end route (through
            /// the relay network), and so if you send any messages unreliable, they
            /// are going to be discarded.
            /// </summary>
            EsteamnetworkingconnectionstateFindingroute = unchecked((int)2),
            
            /// <summary>
            /// We've received communications from our peer (and we know
            /// who they are) and are all good.  If you close the connection now,
            /// we will make our best effort to flush out any reliable sent data that
            /// has not been acknowledged by the peer.  (But note that this happens
            /// from within the application process, so unlike a TCP connection, you are
            /// not totally handing it off to the operating system to deal with it.)
            /// </summary>
            EsteamnetworkingconnectionstateConnected = unchecked((int)3),
            
            /// <summary>
            /// Connection has been closed by our peer, but not closed locally.
            /// The connection still exists from an API perspective.  You must close the
            /// handle to free up resources.  If there are any messages in the inbound queue,
            /// you may retrieve them.  Otherwise, nothing may be done with the connection
            /// except to close it.
            /// </summary>
            /// <remarks>
            /// This stats is similar to CLOSE_WAIT in the TCP state machine.
            /// </remarks>
            EsteamnetworkingconnectionstateClosedbypeer = unchecked((int)4),
            
            /// <summary>
            /// A disruption in the connection has been detected locally.  (E.g. timeout,
            /// local internet connection disrupted, etc.)
            /// </summary>
            /// <remarks>
            /// The connection still exists from an API perspective.  You must close the
            /// handle to free up resources.Attempts to send further messages will fail.  Any remaining received messages
            /// in the queue are available.
            /// </remarks>
            EsteamnetworkingconnectionstateProblemdetectedlocally = unchecked((int)5),
            
            /// <summary>
            /// We've disconnected on our side, and from an API perspective the connection is closed.
            /// No more data may be sent or received.  All reliable data has been flushed, or else
            /// we've given up and discarded it.  We do not yet know for sure that the peer knows
            /// the connection has been closed, however, so we're just hanging around so that if we do
            /// get a packet from them, we can send them the appropriate packets so that they can
            /// know why the connection was closed (and not have to rely on a timeout, which makes
            /// it appear as if something is wrong).
            /// </summary>
            EsteamnetworkingconnectionstateFinwait = unchecked((int)-1),
            
            /// <summary>
            /// We've disconnected on our side, and from an API perspective the connection is closed.
            /// No more data may be sent or received.  From a network perspective, however, on the wire,
            /// we have not yet given any indication to the peer that the connection is closed.
            /// We are in the process of flushing out the last bit of reliable data.  Once that is done,
            /// we will inform the peer that the connection has been closed, and transition to the
            /// FinWait state.
            /// </summary>
            /// <remarks>
            /// Note that no indication is given to the remote host that we have closed the connection,
            /// until the data has been flushed.  If the remote host attempts to send us data, we will
            /// do whatever is necessary to keep the connection alive until it can be closed properly.
            /// But in fact the data will be discarded, since there is no way for the application to
            /// read it back.  Typically this is not a problem, as application protocols that utilize
            /// the lingering functionality are designed for the remote host to wait for the response
            /// before sending any more data.
            /// </remarks>
            EsteamnetworkingconnectionstateLinger = unchecked((int)-2),
            
            /// <summary>
            /// Connection is completely inactive and ready to be destroyed
            /// </summary>
            EsteamnetworkingconnectionstateDead = unchecked((int)-3),
            
            /// <summary>
            /// Connection is completely inactive and ready to be destroyed
            /// </summary>
            EsteamnetworkingconnectionstateForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Describe the status of a particular network resource
        /// </summary>
        public enum ESteamNetworkingAvailability : int
        {
            /// <summary>
            /// A dependent resource is missing, so this service is unavailable.  (E.g. we cannot talk to routers because Internet is down or we don't have the network config.)
            /// </summary>
            EsteamnetworkingavailabilityCannottry = unchecked((int)-102),
            
            /// <summary>
            /// We have tried for enough time that we would expect to have been successful by now.  We have never been successful
            /// </summary>
            EsteamnetworkingavailabilityFailed = unchecked((int)-101),
            
            /// <summary>
            /// We tried and were successful at one time, but now it looks like we have a problem
            /// </summary>
            EsteamnetworkingavailabilityPreviously = unchecked((int)-100),
            
            /// <summary>
            /// We previously failed and are currently retrying
            /// </summary>
            EsteamnetworkingavailabilityRetrying = unchecked((int)-10),
            
            /// <summary>
            /// We don't know because we haven't ever checked/tried
            /// </summary>
            EsteamnetworkingavailabilityNevertried = unchecked((int)1),
            
            /// <summary>
            /// We're waiting on a dependent resource to be acquired.  (E.g. we cannot obtain a cert until we are logged into Steam.  We cannot measure latency to relays until we have the network config.)
            /// </summary>
            EsteamnetworkingavailabilityWaiting = unchecked((int)2),
            
            /// <summary>
            /// We're actively trying now, but are not yet successful.
            /// </summary>
            EsteamnetworkingavailabilityAttempting = unchecked((int)3),
            
            /// <summary>
            /// Resource is online/available
            /// </summary>
            EsteamnetworkingavailabilityCurrent = unchecked((int)100),
            
            /// <summary>
            /// Internal dummy/sentinel, or value is not applicable in this context
            /// </summary>
            EsteamnetworkingavailabilityUnknown = unchecked((int)0),
            
            EsteamnetworkingavailabilityForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Enumerate various causes of connection termination.  These are designed to work similar
        /// to HTTP error codes: the numeric range gives you a rough classification as to the source
        /// of the problem.
        /// </summary>
        public enum ESteamNetConnectionEnd : int
        {
            /// <summary>
            /// Invalid/sentinel value
            /// </summary>
            EsteamnetconnectionendInvalid = unchecked((int)0),
            
            /// <summary>
            /// 1xxx: Application ended the connection in a "usual" manner.
            /// E.g.: user intentionally disconnected from the server,
            /// gameplay ended normally, etc
            /// </summary>
            EsteamnetconnectionendAppMin = unchecked((int)1000),
            
            /// <summary>
            /// 1xxx: Application ended the connection in a "usual" manner.
            /// E.g.: user intentionally disconnected from the server,
            /// gameplay ended normally, etc
            /// </summary>
            EsteamnetconnectionendAppGeneric,
            
            /// <summary>
            /// Use codes in this range for "normal" disconnection
            /// </summary>
            EsteamnetconnectionendAppMax = unchecked((int)1999),
            
            /// <summary>
            /// 2xxx: Application ended the connection in some sort of exceptional
            /// or unusual manner that might indicate a bug or configuration
            /// issue.
            /// </summary>
            EsteamnetconnectionendAppexceptionMin = unchecked((int)2000),
            
            /// <summary>
            /// 2xxx: Application ended the connection in some sort of exceptional
            /// or unusual manner that might indicate a bug or configuration
            /// issue.
            /// </summary>
            EsteamnetconnectionendAppexceptionGeneric,
            
            /// <summary>
            /// Use codes in this range for "unusual" disconnection
            /// </summary>
            EsteamnetconnectionendAppexceptionMax = unchecked((int)2999),
            
            /// <summary>
            /// 3xxx: Connection failed or ended because of problem with the
            /// local host or their connection to the Internet.
            /// </summary>
            EsteamnetconnectionendLocalMin = unchecked((int)3000),
            
            /// <summary>
            /// You cannot do what you want to do because you're running in offline mode.
            /// </summary>
            EsteamnetconnectionendLocalOfflinemode = unchecked((int)3001),
            
            /// <summary>
            /// We're having trouble contacting many (perhaps all) relays.
            /// Since it's unlikely that they all went offline at once, the best
            /// explanation is that we have a problem on our end.  Note that we don't
            /// bother distinguishing between "many" and "all", because in practice,
            /// it takes time to detect a connection problem, and by the time
            /// the connection has timed out, we might not have been able to
            /// actively probe all of the relay clusters, even if we were able to
            /// contact them at one time.  So this code just means that:
            /// </summary>
            /// <remarks>
            /// * We don't have any recent successful communication with any relay.
            /// * We have evidence of recent failures to communicate with multiple relays.
            /// </remarks>
            EsteamnetconnectionendLocalManyrelayconnectivity = unchecked((int)3002),
            
            /// <summary>
            /// A hosted server is having trouble talking to the relay
            /// that the client was using, so the problem is most likely
            /// on our end
            /// </summary>
            EsteamnetconnectionendLocalHostedserverprimaryrelay = unchecked((int)3003),
            
            /// <summary>
            /// We're not able to get the SDR network config.  This is
            /// *almost* always a local issue, since the network config
            /// comes from the CDN, which is pretty darn reliable.
            /// </summary>
            EsteamnetconnectionendLocalNetworkconfig = unchecked((int)3004),
            
            /// <summary>
            /// Steam rejected our request because we don't have rights
            /// to do this.
            /// </summary>
            EsteamnetconnectionendLocalRights = unchecked((int)3005),
            
            /// <summary>
            /// ICE P2P rendezvous failed because we were not able to
            /// determine our "public" address (e.g. reflexive address via STUN)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendLocalP2pIceNopublicaddresses = unchecked((int)3006),
            
            /// <summary>
            /// ICE P2P rendezvous failed because we were not able to
            /// determine our "public" address (e.g. reflexive address via STUN)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendLocalMax = unchecked((int)3999),
            
            /// <summary>
            /// 4xxx: Connection failed or ended, and it appears that the
            /// cause does NOT have to do with the local host or their
            /// connection to the Internet.  It could be caused by the
            /// remote host, or it could be somewhere in between.
            /// </summary>
            EsteamnetconnectionendRemoteMin = unchecked((int)4000),
            
            /// <summary>
            /// The connection was lost, and as far as we can tell our connection
            /// to relevant services (relays) has not been disrupted.  This doesn't
            /// mean that the problem is "their fault", it just means that it doesn't
            /// appear that we are having network issues on our end.
            /// </summary>
            EsteamnetconnectionendRemoteTimeout = unchecked((int)4001),
            
            /// <summary>
            /// Something was invalid with the cert or crypt handshake
            /// info you gave me, I don't understand or like your key types,
            /// etc.
            /// </summary>
            EsteamnetconnectionendRemoteBadcrypt = unchecked((int)4002),
            
            /// <summary>
            /// You presented me with a cert that was I was able to parse
            /// and *technically* we could use encrypted communication.
            /// But there was a problem that prevents me from checking your identity
            /// or ensuring that somebody int he middle can't observe our communication.
            /// E.g.: - the CA key was missing (and I don't accept unsigned certs)
            /// - The CA key isn't one that I trust,
            /// - The cert doesn't was appropriately restricted by app, user, time, data center, etc.
            /// - The cert wasn't issued to you.
            /// - etc
            /// </summary>
            EsteamnetconnectionendRemoteBadcert = unchecked((int)4003),
            
            /// <summary>
            /// Something wrong with the protocol version you are using.
            /// (Probably the code you are running is too old.)
            /// </summary>
            EsteamnetconnectionendRemoteBadprotocolversion = unchecked((int)4006),
            
            /// <summary>
            /// NAT punch failed failed because we never received any public
            /// addresses from the remote host.  (But we did receive some
            /// signals form them.)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendRemoteP2pIceNopublicaddresses = unchecked((int)4007),
            
            /// <summary>
            /// NAT punch failed failed because we never received any public
            /// addresses from the remote host.  (But we did receive some
            /// signals form them.)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendRemoteMax = unchecked((int)4999),
            
            /// <summary>
            /// 5xxx: Connection failed for some other reason.
            /// </summary>
            EsteamnetconnectionendMiscMin = unchecked((int)5000),
            
            /// <summary>
            /// A failure that isn't necessarily the result of a software bug,
            /// but that should happen rarely enough that it isn't worth specifically
            /// writing UI or making a localized message for.
            /// The debug string should contain further details.
            /// </summary>
            EsteamnetconnectionendMiscGeneric = unchecked((int)5001),
            
            /// <summary>
            /// Generic failure that is most likely a software bug.
            /// </summary>
            EsteamnetconnectionendMiscInternalerror = unchecked((int)5002),
            
            /// <summary>
            /// The connection to the remote host timed out, but we
            /// don't know if the problem is on our end, in the middle,
            /// or on their end.
            /// </summary>
            EsteamnetconnectionendMiscTimeout = unchecked((int)5003),
            
            /// <summary>
            /// There's some trouble talking to Steam.
            /// </summary>
            EsteamnetconnectionendMiscSteamconnectivity = unchecked((int)5005),
            
            /// <summary>
            /// A server in a dedicated hosting situation has no relay sessions
            /// active with which to talk back to a client.  (It's the client's
            /// job to open and maintain those sessions.)
            /// </summary>
            EsteamnetconnectionendMiscNorelaysessionstoclient = unchecked((int)5006),
            
            /// <summary>
            /// P2P rendezvous failed in a way that we don't have more specific
            /// information
            /// </summary>
            EsteamnetconnectionendMiscP2pRendezvous = unchecked((int)5008),
            
            /// <summary>
            /// NAT punch failed, probably due to NAT/firewall configuration.
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendMiscP2pNatFirewall = unchecked((int)5009),
            
            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendMiscPeersentnoconnection = unchecked((int)5010),
            
            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendMiscMax = unchecked((int)5999),
            
            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Configuration values can be applied to different types of objects.
        /// </summary>
        public enum ESteamNetworkingConfigScope : int
        {
            /// <summary>
            /// Get/set global option, or defaults.  Even options that apply to more specific scopes
            /// have global scope, and you may be able to just change the global defaults.  If you
            /// need different settings per connection (for example), then you will need to set those
            /// options at the more specific scope.
            /// </summary>
            EsteamnetworkingconfigGlobal = unchecked((int)1),
            
            /// <summary>
            /// Some options are specific to a particular interface.  Note that all connection
            /// and listen socket settings can also be set at the interface level, and they will
            /// apply to objects created through those interfaces.
            /// </summary>
            EsteamnetworkingconfigSocketsinterface = unchecked((int)2),
            
            /// <summary>
            /// Options for a listen socket.  Listen socket options can be set at the interface layer,
            /// if  you have multiple listen sockets and they all use the same options.
            /// You can also set connection options on a listen socket, and they set the defaults
            /// for all connections accepted through this listen socket.  (They will be used if you don't
            /// set a connection option.)
            /// </summary>
            EsteamnetworkingconfigListensocket = unchecked((int)3),
            
            /// <summary>
            /// Options for a specific connection.
            /// </summary>
            EsteamnetworkingconfigConnection = unchecked((int)4),
            
            /// <summary>
            /// Options for a specific connection.
            /// </summary>
            EsteamnetworkingconfigscopeForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Different configuration values have different data types
        /// </summary>
        public enum ESteamNetworkingConfigDataType : int
        {
            EsteamnetworkingconfigInt32 = unchecked((int)1),
            
            EsteamnetworkingconfigInt64 = unchecked((int)2),
            
            EsteamnetworkingconfigFloat = unchecked((int)3),
            
            EsteamnetworkingconfigString = unchecked((int)4),
            
            EsteamnetworkingconfigPtr = unchecked((int)5),
            
            EsteamnetworkingconfigdatatypeForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Configuration options
        /// </summary>
        public enum ESteamNetworkingConfigValue : int
        {
            EsteamnetworkingconfigInvalid = unchecked((int)0),
            
            /// <summary>
            /// [connection int32] Timeout value (in ms) to use when first connecting
            /// </summary>
            EsteamnetworkingconfigTimeoutinitial = unchecked((int)24),
            
            /// <summary>
            /// [connection int32] Timeout value (in ms) to use after connection is established
            /// </summary>
            EsteamnetworkingconfigTimeoutconnected = unchecked((int)25),
            
            /// <summary>
            /// [connection int32] Upper limit of buffered pending bytes to be sent,
            /// if this is reached SendMessage will return k_EResultLimitExceeded
            /// Default is 512k (524288 bytes)
            /// </summary>
            EsteamnetworkingconfigSendbuffersize = unchecked((int)9),
            
            /// <summary>
            /// [connection int64] Get/set userdata as a configuration option.
            /// The default value is -1.   You may want to set the user data as
            /// a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData
            /// in two specific instances:
            /// </summary>
            /// <remarks>
            /// - You wish to set the userdata atomically when creating
            /// an outbound connection, so that the userdata is filled in properly
            /// for any callbacks that happen.  However, note that this trick
            /// only works for connections initiated locally!  For incoming
            /// connections, multiple state transitions may happen and
            /// callbacks be queued, before you are able to service the first
            /// callback!  Be careful!- You can set the default userdata for all newly created connections
            /// by setting this value at a higher level (e.g. on the listen
            /// socket or at the global level.)  Then this default
            /// value will be inherited when the connection is created.
            /// This is useful in case -1 is a valid userdata value, and you
            /// wish to use something else as the default value so you can
            /// tell if it has been set or not.HOWEVER: once a connection is created, the effective value is
            /// then bound to the connection.  Unlike other connection options,
            /// if you change it again at a higher level, the new value will not
            /// be inherited by connections.Using the userdata field in callback structs is not advised because
            /// of tricky race conditions.  Instead, you might try one of these methods:- Use a separate map with the HSteamNetConnection as the key.
            /// - Fetch the userdata from the connection in your callback
            /// using ISteamNetworkingSockets::GetConnectionUserData, to
            /// ensure you have the current value.
            /// </remarks>
            EsteamnetworkingconfigConnectionuserdata = unchecked((int)40),
            
            /// <summary>
            /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
            /// This value will control the min/max allowed sending rate that 
            /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
            /// </summary>
            EsteamnetworkingconfigSendratemin = unchecked((int)10),
            
            /// <summary>
            /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
            /// This value will control the min/max allowed sending rate that 
            /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
            /// </summary>
            EsteamnetworkingconfigSendratemax = unchecked((int)11),
            
            /// <summary>
            /// [connection int32] Nagle time, in microseconds.  When SendMessage is called, if
            /// the outgoing message is less than the size of the MTU, it will be
            /// queued for a delay equal to the Nagle timer value.  This is to ensure
            /// that if the application sends several small messages rapidly, they are
            /// coalesced into a single packet.
            /// See historical RFC 896.  Value is in microseconds. 
            /// Default is 5000us (5ms).
            /// </summary>
            EsteamnetworkingconfigNagletime = unchecked((int)12),
            
            /// <summary>
            /// [connection int32] Don't automatically fail IP connections that don't have
            /// strong auth.  On clients, this means we will attempt the connection even if
            /// we don't know our identity or can't get a cert.  On the server, it means that
            /// we won't automatically reject a connection due to a failure to authenticate.
            /// (You can examine the incoming connection and decide whether to accept it.)
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, and you should not let users modify it in
            /// production.
            /// </remarks>
            EsteamnetworkingconfigIpAllowwithoutauth = unchecked((int)23),
            
            /// <summary>
            /// [connection int32] Do not send UDP packets with a payload of
            /// larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize
            /// is automatically adjusted
            /// </summary>
            EsteamnetworkingconfigMtuPacketsize = unchecked((int)32),
            
            /// <summary>
            /// [connection int32] (read only) Maximum message size you can send that
            /// will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize
            /// </summary>
            EsteamnetworkingconfigMtuDatasize = unchecked((int)33),
            
            /// <summary>
            /// [connection int32] Allow unencrypted (and unauthenticated) communication.
            /// 0: Not allowed (the default)
            /// 1: Allowed, but prefer encrypted
            /// 2: Allowed, and preferred
            /// 3: Required.  (Fail the connection if the peer requires encryption.)
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, since its purpose is to disable encryption.
            /// You should not let users modify it in production.  (But note that it requires
            /// the peer to also modify their value in order for encryption to be disabled.)
            /// </remarks>
            EsteamnetworkingconfigUnencrypted = unchecked((int)34),
            
            /// <summary>
            /// [connection int32] Set this to 1 on outbound connections and listen sockets,
            /// to enable "symmetric connect mode", which is useful in the following
            /// common peer-to-peer use case:
            /// </summary>
            /// <remarks>
            /// - The two peers are "equal" to each other.  (Neither is clearly the "client"
            /// or "server".)
            /// - Either peer may initiate the connection, and indeed they may do this
            /// at the same time
            /// - The peers only desire a single connection to each other, and if both
            /// peers initiate connections simultaneously, a protocol is needed for them
            /// to resolve the conflict, so that we end up with a single connection.This use case is both common, and involves subtle race conditions and tricky
            /// pitfalls, which is why the API has support for dealing with it.If an incoming connection arrives on a listen socket or via custom signaling,
            /// and the application has not attempted to make a matching outbound connection
            /// in symmetric mode, then the incoming connection can be accepted as usual.
            /// A "matching" connection means that the relevant endpoint information matches.
            /// (At the time this comment is being written, this is only supported for P2P
            /// connections, which means that the peer identities must match, and the virtual
            /// port must match.  At a later time, symmetric mode may be supported for other
            /// connection types.)If connections are initiated by both peers simultaneously, race conditions
            /// can arise, but fortunately, most of them are handled internally and do not
            /// require any special awareness from the application.  However, there
            /// is one important case that application code must be aware of:
            /// If application code attempts an outbound connection using a ConnectXxx
            /// function in symmetric mode, and a matching incoming connection is already
            /// waiting on a listen socket, then instead of forming a new connection,
            /// the ConnectXxx call will accept the existing incoming connection, and return
            /// a connection handle to this accepted connection.
            /// IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t
            /// has probably *already* been posted to the queue for the incoming connection!
            /// (Once callbacks are posted to the queue, they are not modified.)  It doesn't
            /// matter if the callback has not been consumed by the app.  Thus, application
            /// code that makes use of symmetric connections must be aware that, when processing a
            /// SteamNetConnectionStatusChangedCallback_t for an incoming connection, the
            /// m_hConn may refer to a new connection that the app has has not
            /// seen before (the usual case), but it may also refer to a connection that
            /// has already been accepted implicitly through a call to Connect()!  In this
            /// case, AcceptConnection() will return k_EResultDuplicateRequest.Only one symmetric connection to a given peer (on a given virtual port)
            /// may exist at any given time.  If client code attempts to create a connection,
            /// and a (live) connection already exists on the local host, then either the
            /// existing connection will be accepted as described above, or the attempt
            /// to create a new connection will fail.  Furthermore, linger mode functionality
            /// is not supported on symmetric connections.A more complicated race condition can arise if both peers initiate a connection
            /// at roughly the same time.  In this situation, each peer will receive an incoming
            /// connection from the other peer, when the application code has already initiated
            /// an outgoing connection to that peer.  The peers must resolve this conflict and
            /// decide who is going to act as the "server" and who will act as the "client".
            /// Typically the application does not need to be aware of this case as it is handled
            /// internally.  On both sides, the will observe their outbound connection being
            /// "accepted", although one of them one have been converted internally to act
            /// as the "server".In general, symmetric mode should be all-or-nothing: do not mix symmetric
            /// connections with a non-symmetric connection that it might possible "match"
            /// with.  If you use symmetric mode on any connections, then both peers should
            /// use it on all connections, and the corresponding listen socket, if any.  The
            /// behaviour when symmetric and ordinary connections are mixed is not defined by
            /// this API, and you should not rely on it.  (This advice only applies when connections
            /// might possibly "match".  For example, it's OK to use all symmetric mode
            /// connections on one virtual port, and all ordinary, non-symmetric connections
            /// on a different virtual port, as there is no potential for ambiguity.)When using the feature, you should set it in the following situations on
            /// applicable objects:- When creating an outbound connection using ConnectXxx function
            /// - When creating a listen socket.  (Note that this will automatically cause
            /// any accepted connections to inherit the flag.)
            /// - When using custom signaling, before accepting an incoming connection.Setting the flag on listen socket and accepted connections will enable the
            /// API to automatically deal with duplicate incoming connections, even if the
            /// local host has not made any outbound requests.  (In general, such duplicate
            /// requests from a peer are ignored internally and will not be visible to the
            /// application code.  The previous connection must be closed or resolved first.)
            /// </remarks>
            EsteamnetworkingconfigSymmetricconnect = unchecked((int)37),
            
            /// <summary>
            /// [connection int32] For connection types that use "virtual ports", this can be used
            /// to assign a local virtual port.  For incoming connections, this will always be the
            /// virtual port of the listen socket (or the port requested by the remote host if custom
            /// signaling is used and the connection is accepted), and cannot be changed.  For
            /// connections initiated locally, the local virtual port will default to the same as the
            /// requested remote virtual port, if you do not specify a different option when creating
            /// the connection.  The local port is only relevant for symmetric connections, when
            /// determining if two connections "match."  In this case, if you need the local and remote
            /// port to differ, you can set this value.
            /// </summary>
            /// <remarks>
            /// You can also read back this value on listen sockets.This value should not be read or written in any other context.
            /// </remarks>
            EsteamnetworkingconfigLocalvirtualport = unchecked((int)38),
            
            /// <summary>
            /// [connection int32] True to enable diagnostics reporting through
            /// generic platform UI.  (Only available on Steam.)
            /// </summary>
            EsteamnetworkingconfigEnablediagnosticsui = unchecked((int)46),
            
            /// <summary>
            /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
            /// This is a global option only, since it is applied at a low level
            /// where we don't have much context
            /// </summary>
            EsteamnetworkingconfigFakepacketlossSend = unchecked((int)2),
            
            /// <summary>
            /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
            /// This is a global option only, since it is applied at a low level
            /// where we don't have much context
            /// </summary>
            EsteamnetworkingconfigFakepacketlossRecv = unchecked((int)3),
            
            /// <summary>
            /// [global int32].  Delay all outbound/inbound packets by N ms
            /// </summary>
            EsteamnetworkingconfigFakepacketlagSend = unchecked((int)4),
            
            /// <summary>
            /// [global int32].  Delay all outbound/inbound packets by N ms
            /// </summary>
            EsteamnetworkingconfigFakepacketlagRecv = unchecked((int)5),
            
            /// <summary>
            /// [global float] 0-100 Percentage of packets we will add additional delay
            /// to (causing them to be reordered)
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderSend = unchecked((int)6),
            
            /// <summary>
            /// [global float] 0-100 Percentage of packets we will add additional delay
            /// to (causing them to be reordered)
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderRecv = unchecked((int)7),
            
            /// <summary>
            /// [global int32] Extra delay, in ms, to apply to reordered packets.
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderTime = unchecked((int)8),
            
            /// <summary>
            /// [global float 0--100] Globally duplicate some percentage of packets we send
            /// </summary>
            EsteamnetworkingconfigFakepacketdupSend = unchecked((int)26),
            
            /// <summary>
            /// [global float 0--100] Globally duplicate some percentage of packets we send
            /// </summary>
            EsteamnetworkingconfigFakepacketdupRecv = unchecked((int)27),
            
            /// <summary>
            /// [global int32] Amount of delay, in ms, to delay duplicated packets.
            /// (We chose a random delay between 0 and this value)
            /// </summary>
            EsteamnetworkingconfigFakepacketdupTimemax = unchecked((int)28),
            
            /// <summary>
            /// [global int32] Trace every UDP packet, similar to Wireshark or tcpdump.
            /// Value is max number of bytes to dump.  -1 disables tracing.
            /// 0 only traces the info but no actual data bytes
            /// </summary>
            EsteamnetworkingconfigPackettracemaxbytes = unchecked((int)41),
            
            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitSendRate = unchecked((int)42),
            
            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitSendBurst = unchecked((int)43),
            
            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitRecvRate = unchecked((int)44),
            
            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitRecvBurst = unchecked((int)45),
            
            /// <summary>
            /// [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked
            /// when the state of a connection changes.
            /// </summary>
            /// <remarks>
            /// IMPORTANT: callbacks are dispatched to the handler that is in effect at the time
            /// the event occurs, which might be in another thread.  For example, immediately after
            /// creating a listen socket, you may receive an incoming connection.  And then immediately
            /// after this, the remote host may close the connection.  All of this could happen
            /// before the function to create the listen socket has returned.  For this reason,
            /// callbacks usually must be in effect at the time of object creation.  This means
            /// you should set them when you are creating the listen socket or connection, or have
            /// them in effect so they will be inherited at the time of object creation.For example:exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );
            /// SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );
            /// SteamNetworkingIPAddr localAddress; localAddress.Clear();
            /// HSteamListenSocket hListenSock = SteamNetworkingSockets()-&gt;CreateListenSocketIP( localAddress, 1, 
            /// &amp;opt
            /// );When accepting an incoming connection, there is no atomic way to switch the
            /// callback.  However, if the connection is DOA, AcceptConnection() will fail, and
            /// you can fetch the state of the connection at that time.If all connections and listen sockets can use the same callback, the simplest
            /// method is to set it globally before you create any listen sockets or connections.
            /// </remarks>
            EsteamnetworkingconfigCallbackConnectionstatuschanged = unchecked((int)201),
            
            /// <summary>
            /// [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked
            /// when our auth state changes.  If you use this, install the callback before creating
            /// any connections or listen sockets, and don't change it.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged
            /// </summary>
            EsteamnetworkingconfigCallbackAuthstatuschanged = unchecked((int)202),
            
            /// <summary>
            /// [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked
            /// when our auth state changes.  If you use this, install the callback before creating
            /// any connections or listen sockets, and don't change it.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged
            /// </summary>
            EsteamnetworkingconfigCallbackRelaynetworkstatuschanged = unchecked((int)203),
            
            /// <summary>
            /// [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked
            /// when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest
            /// </summary>
            EsteamnetworkingconfigCallbackMessagessessionrequest = unchecked((int)204),
            
            /// <summary>
            /// [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked
            /// when a session you have initiated, or accepted either fails to connect, or loses
            /// connection in some unexpected way.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed
            /// </summary>
            EsteamnetworkingconfigCallbackMessagessessionfailed = unchecked((int)205),
            
            /// <summary>
            /// [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will
            /// be invoked when we need to create a signaling object for a connection
            /// initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,
            /// ISteamNetworkingMessages.
            /// </summary>
            EsteamnetworkingconfigCallbackCreateconnectionsignaling = unchecked((int)206),
            
            /// <summary>
            /// [global FnSteamNetworkingFakeIPResult] Callback that's invoked when
            /// a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,
            /// ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult
            /// </summary>
            EsteamnetworkingconfigCallbackFakeipresult = unchecked((int)207),
            
            /// <summary>
            /// [connection string] Comma-separated list of STUN servers that can be used
            /// for NAT piercing.  If you set this to an empty string, NAT piercing will
            /// not be attempted.  Also if "public" candidates are not allowed for
            /// P2P_Transport_ICE_Enable, then this is ignored.
            /// </summary>
            EsteamnetworkingconfigP2pStunServerlist = unchecked((int)103),
            
            /// <summary>
            /// [connection int32] What types of ICE candidates to share with the peer.
            /// See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values
            /// </summary>
            EsteamnetworkingconfigP2pTransportIceEnable = unchecked((int)104),
            
            /// <summary>
            /// [connection int32] When selecting P2P transport, add various
            /// penalties to the scores for selected transports.  (Route selection
            /// scores are on a scale of milliseconds.  The score begins with the
            /// route ping time and is then adjusted.)
            /// </summary>
            EsteamnetworkingconfigP2pTransportIcePenalty = unchecked((int)105),
            
            /// <summary>
            /// [connection int32] When selecting P2P transport, add various
            /// penalties to the scores for selected transports.  (Route selection
            /// scores are on a scale of milliseconds.  The score begins with the
            /// route ping time and is then adjusted.)
            /// </summary>
            EsteamnetworkingconfigP2pTransportSdrPenalty = unchecked((int)106),
            
            /// <summary>
            /// [int32 global] If the first N pings to a port all fail, mark that port as unavailable for
            /// a while, and try a different one.  Some ISPs and routers may drop the first
            /// packet, so setting this to 1 may greatly disrupt communications.
            /// </summary>
            EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfailinitial = unchecked((int)19),
            
            /// <summary>
            /// [int32 global] If N consecutive pings to a port fail, after having received successful 
            /// communication, mark that port as unavailable for a while, and try a 
            /// different one.
            /// </summary>
            EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfail = unchecked((int)20),
            
            /// <summary>
            /// [int32 global] Minimum number of lifetime pings we need to send, before we think our estimate
            /// is solid.  The first ping to each cluster is very often delayed because of NAT,
            /// routers not having the best route, etc.  Until we've sent a sufficient number
            /// of pings, our estimate is often inaccurate.  Keep pinging until we get this
            /// many pings.
            /// </summary>
            EsteamnetworkingconfigSdrclientMinpingsbeforepingaccurate = unchecked((int)21),
            
            /// <summary>
            /// [int32 global] Set all steam datagram traffic to originate from the same
            /// local port. By default, we open up a new UDP socket (on a different local
            /// port) for each relay.  This is slightly less optimal, but it works around
            /// some routers that don't implement NAT properly.  If you have intermittent
            /// problems talking to relays that might be NAT related, try toggling
            /// this flag
            /// </summary>
            EsteamnetworkingconfigSdrclientSinglesocket = unchecked((int)22),
            
            /// <summary>
            /// [global string] Code of relay cluster to force use.  If not empty, we will
            /// only use relays in that cluster.  E.g. 'iad'
            /// </summary>
            EsteamnetworkingconfigSdrclientForcerelaycluster = unchecked((int)29),
            
            /// <summary>
            /// [connection string] For debugging, generate our own (unsigned) ticket, using
            /// the specified  gameserver address.  Router must be configured to accept unsigned
            /// tickets.
            /// </summary>
            EsteamnetworkingconfigSdrclientDebugticketaddress = unchecked((int)30),
            
            /// <summary>
            /// [global string] For debugging.  Override list of relays from the config with
            /// this set (maybe just one).  Comma-separated list.
            /// </summary>
            EsteamnetworkingconfigSdrclientForceproxyaddr = unchecked((int)31),
            
            /// <summary>
            /// [global string] For debugging.  Force ping times to clusters to be the specified
            /// values.  A comma separated list of 
            /// &lt;cluster
            /// &gt;=
            /// &lt;ms
            /// &gt; values.  E.g. "sto=32,iad=100"
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, you probably should not let users modify it
            /// in production.
            /// </remarks>
            EsteamnetworkingconfigSdrclientFakeclusterping = unchecked((int)36),
            
            /// <summary>
            /// [connection int32] RTT calculations for inline pings and replies
            /// </summary>
            EsteamnetworkingconfigLoglevelAckrtt = unchecked((int)13),
            
            /// <summary>
            /// [connection int32] log SNP packets send/recv
            /// </summary>
            EsteamnetworkingconfigLoglevelPacketdecode = unchecked((int)14),
            
            /// <summary>
            /// [connection int32] log each message send/recv
            /// </summary>
            EsteamnetworkingconfigLoglevelMessage = unchecked((int)15),
            
            /// <summary>
            /// [connection int32] dropped packets
            /// </summary>
            EsteamnetworkingconfigLoglevelPacketgaps = unchecked((int)16),
            
            /// <summary>
            /// [connection int32] P2P rendezvous messages
            /// </summary>
            EsteamnetworkingconfigLoglevelP2prendezvous = unchecked((int)17),
            
            /// <summary>
            /// [global int32] Ping relays
            /// </summary>
            EsteamnetworkingconfigLoglevelSdrrelaypings = unchecked((int)18),
            
            /// <summary>
            /// Deleted, do not use
            /// </summary>
            EsteamnetworkingconfigDeletedEnumeratedevvars = unchecked((int)35),
            
            /// <summary>
            /// Deleted, do not use
            /// </summary>
            EsteamnetworkingconfigvalueForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Return value of ISteamNetworkintgUtils::GetConfigValue
        /// </summary>
        public enum ESteamNetworkingGetConfigValueResult : int
        {
            /// <summary>
            /// No such configuration value
            /// </summary>
            EsteamnetworkinggetconfigvalueBadvalue = unchecked((int)-1),
            
            /// <summary>
            /// Bad connection handle, etc
            /// </summary>
            EsteamnetworkinggetconfigvalueBadscopeobj = unchecked((int)-2),
            
            /// <summary>
            /// Couldn't fit the result in your buffer
            /// </summary>
            EsteamnetworkinggetconfigvalueBuffertoosmall = unchecked((int)-3),
            
            EsteamnetworkinggetconfigvalueOk = unchecked((int)1),
            
            /// <summary>
            /// A value was not set at this level, but the effective (inherited) value was returned.
            /// </summary>
            EsteamnetworkinggetconfigvalueOkinherited = unchecked((int)2),
            
            EsteamnetworkinggetconfigvalueresultForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Detail level for diagnostic output callback.
        /// See ISteamNetworkingUtils::SetDebugOutputFunction
        /// </summary>
        public enum ESteamNetworkingSocketsDebugOutputType : int
        {
            EsteamnetworkingsocketsdebugoutputtypeNone = unchecked((int)0),
            
            /// <summary>
            /// You used the API incorrectly, or an internal error happened
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeBug = unchecked((int)1),
            
            /// <summary>
            /// Run-time error condition that isn't the result of a bug.  (E.g. we are offline, cannot bind a port, etc)
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeError = unchecked((int)2),
            
            /// <summary>
            /// Nothing is wrong, but this is an important notification
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeImportant = unchecked((int)3),
            
            EsteamnetworkingsocketsdebugoutputtypeWarning = unchecked((int)4),
            
            /// <summary>
            /// Recommended amount
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeMsg = unchecked((int)5),
            
            /// <summary>
            /// Quite a bit
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeVerbose = unchecked((int)6),
            
            /// <summary>
            /// Practically everything
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeDebug = unchecked((int)7),
            
            /// <summary>
            /// Wall of text, detailed packet contents breakdown, etc
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeEverything = unchecked((int)8),
            
            EsteamnetworkingsocketsdebugoutputtypeForce32bit = unchecked((int)0x7fffffff),
        }
        
        public enum __AnonymousCppEnum_steam_api_common_279AnonymousEnum : int
        {
            Isteamnetworkingsocketscallbacks = unchecked((int)1220),
        }
        
        public enum __AnonymousCppEnum_steam_api_common_331AnonymousEnum : int
        {
            Isteamnetworkingmessagescallbacks = unchecked((int)1250),
        }
        
        public enum __AnonymousCppEnum_steam_api_common_384AnonymousEnum : int
        {
            Isteamnetworkingutilscallbacks = unchecked((int)1280),
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamIPAddress_t
        {
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamIPAddress_tunion
            {
                /// <summary>
                /// Host order
                /// </summary>
                [FieldOffset(0)]
                public uint m_unIPv4;
                
                /// <summary>
                /// Network order! Same as inaddr_in6.  (0011:2233:4455:6677:8899:aabb:ccdd:eeff)
                /// </summary>
                [FieldOffset(0)]
                public fixed byte m_rgubIPv6[16];
                
                /// <summary>
                /// big endian
                /// </summary>
                [FieldOffset(0)]
                public fixed ulong m_ipv6Qword[2];
            }
            
            public Networking.ESteamIPType m_eType;
        }
        
        /// <summary>
        /// Steam ID structure (64 bits total)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct CSteamID
        {
            /// <summary>
            /// 64 bits total
            /// </summary>
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct SteamID_t
            {
                [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
                public partial struct SteamIDComponent_t
                {
                    private uint __bitfield__0;
                    
                    /// <summary>
                    /// unique account identifier
                    /// </summary>
                    public uint m_unAccountID
                    {
                        get
                        {
                            return unchecked((uint)((__bitfield__0 >> 0) & 0b11111111111111111111111111111111));
                        }
                        set
                        {
                            __bitfield__0 = (__bitfield__0 & unchecked((uint)0b00000000000000000000000000000000)) | ((((uint)value) & (unchecked((uint)0b11111111111111111111111111111111)) << 0));
                        }
                    }
                    
                    private uint __bitfield__2;
                    
                    /// <summary>
                    /// dynamic instance ID
                    /// </summary>
                    public uint m_unAccountInstance
                    {
                        get
                        {
                            return unchecked((uint)((__bitfield__2 >> 0) & 0b11111111111111111111));
                        }
                        set
                        {
                            __bitfield__2 = (__bitfield__2 & unchecked((uint)0b11111111111100000000000000000000)) | ((((uint)value) & (unchecked((uint)0b11111111111111111111)) << 0));
                        }
                    }
                    
                    /// <summary>
                    /// type of account - can't show as EAccountType, due to signed / unsigned difference
                    /// </summary>
                    public uint m_EAccountType
                    {
                        get
                        {
                            return unchecked((uint)((__bitfield__2 >> 20) & 0b1111));
                        }
                        set
                        {
                            __bitfield__2 = (__bitfield__2 & unchecked((uint)0b11111111000011111111111111111111)) | ((((uint)value) & (unchecked((uint)0b1111)) << 20));
                        }
                    }
                    
                    /// <summary>
                    /// universe this account belongs to
                    /// </summary>
                    public Networking.EUniverse m_EUniverse
                    {
                        get
                        {
                            return unchecked((Networking.EUniverse)((__bitfield__2 >> 24) & 0b11111111));
                        }
                        set
                        {
                            __bitfield__2 = (__bitfield__2 & unchecked((uint)0b00000000111111111111111111111111)) | ((((uint)value) & (unchecked((uint)0b11111111)) << 24));
                        }
                    }
                }
                
                [FieldOffset(0)]
                public Networking.CSteamID.SteamID_t.SteamIDComponent_t m_comp;
                
                [FieldOffset(0)]
                public ulong m_unAll64Bits;
            }
            
            public Networking.CSteamID.SteamID_t m_steamid;
        }
        
        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Purpose: encapsulates an appID/modID pair
        /// -----------------------------------------------------------------------------
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct CGameID
        {
            /// <summary>
            /// Internal stuff.  Use the accessors above if possible
            /// </summary>
            public enum EGameIDType : int
            {
                Egameidtypeapp = unchecked((int)0),
                
                Egameidtypegamemod = unchecked((int)1),
                
                Egameidtypeshortcut = unchecked((int)2),
                
                Egameidtypep2p = unchecked((int)3),
            }
            
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public partial struct GameID_t
            {
                private uint __bitfield__0;
                
                public uint m_nAppID
                {
                    get
                    {
                        return unchecked((uint)((__bitfield__0 >> 0) & 0b111111111111111111111111));
                    }
                    set
                    {
                        __bitfield__0 = (__bitfield__0 & unchecked((uint)0b11111111000000000000000000000000)) | ((((uint)value) & (unchecked((uint)0b111111111111111111111111)) << 0));
                    }
                }
                
                public uint m_nType
                {
                    get
                    {
                        return unchecked((uint)((__bitfield__0 >> 24) & 0b11111111));
                    }
                    set
                    {
                        __bitfield__0 = (__bitfield__0 & unchecked((uint)0b00000000111111111111111111111111)) | ((((uint)value) & (unchecked((uint)0b11111111)) << 24));
                    }
                }
                
                private uint __bitfield__3;
                
                public uint m_nModID
                {
                    get
                    {
                        return unchecked((uint)((__bitfield__3 >> 0) & 0b11111111111111111111111111111111));
                    }
                    set
                    {
                        __bitfield__3 = (__bitfield__3 & unchecked((uint)0b00000000000000000000000000000000)) | ((((uint)value) & (unchecked((uint)0b11111111111111111111111111111111)) << 0));
                    }
                }
            }
            
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct CGameIDunion
            {
                [FieldOffset(0)]
                public ulong m_ulGameID;
                
                [FieldOffset(0)]
                public Networking.CGameID.GameID_t m_gameID;
            }
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct ValvePackingSentinel_t
        {
            public uint m_u32;
            
            public ulong m_u64;
            
            public ushort m_u16;
            
            public double m_d;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramRelayAuthTicket : IEquatable<SteamDatagramRelayAuthTicket>
        {
            private readonly IntPtr _handle;
            
            public SteamDatagramRelayAuthTicket(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamDatagramRelayAuthTicket other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamDatagramRelayAuthTicket other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamDatagramRelayAuthTicket left, SteamDatagramRelayAuthTicket right) => left.Equals(right);
            
            public static bool operator !=(SteamDatagramRelayAuthTicket left, SteamDatagramRelayAuthTicket right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramHostedAddress : IEquatable<SteamDatagramHostedAddress>
        {
            private readonly IntPtr _handle;
            
            public SteamDatagramHostedAddress(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamDatagramHostedAddress other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamDatagramHostedAddress other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamDatagramHostedAddress left, SteamDatagramHostedAddress right) => left.Equals(right);
            
            public static bool operator !=(SteamDatagramHostedAddress left, SteamDatagramHostedAddress right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramGameCoordinatorServerLogin : IEquatable<SteamDatagramGameCoordinatorServerLogin>
        {
            private readonly IntPtr _handle;
            
            public SteamDatagramGameCoordinatorServerLogin(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamDatagramGameCoordinatorServerLogin other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamDatagramGameCoordinatorServerLogin other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamDatagramGameCoordinatorServerLogin left, SteamDatagramGameCoordinatorServerLogin right) => left.Equals(right);
            
            public static bool operator !=(SteamDatagramGameCoordinatorServerLogin left, SteamDatagramGameCoordinatorServerLogin right) => !left.Equals(right);
        }
        
        /// <summary>
        /// This callback is posted whenever a connection is created, destroyed, or changes state.
        /// The m_info field will contain a complete description of the connection at the time the
        /// change occurred and the callback was posted.  In particular, m_eState will have the
        /// new connection state.
        /// </summary>
        /// <remarks>
        /// You will usually need to listen for this callback to know when:
        /// - A new connection arrives on a listen socket.
        /// m_info.m_hListenSocket will be set, m_eOldState = k_ESteamNetworkingConnectionState_None,
        /// and m_info.m_eState = k_ESteamNetworkingConnectionState_Connecting.
        /// See ISteamNetworkigSockets::AcceptConnection.
        /// - A connection you initiated has been accepted by the remote host.
        /// m_eOldState = k_ESteamNetworkingConnectionState_Connecting, and
        /// m_info.m_eState = k_ESteamNetworkingConnectionState_Connected.
        /// Some connections might transition to k_ESteamNetworkingConnectionState_FindingRoute first.
        /// - A connection has been actively rejected or closed by the remote host.
        /// m_eOldState = k_ESteamNetworkingConnectionState_Connecting or k_ESteamNetworkingConnectionState_Connected,
        /// and m_info.m_eState = k_ESteamNetworkingConnectionState_ClosedByPeer.  m_info.m_eEndReason
        /// and m_info.m_szEndDebug will have for more details.
        /// NOTE: upon receiving this callback, you must still destroy the connection using
        /// ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details
        /// passed to the function are not used in this case, since the connection is already closed.)
        /// - A problem was detected with the connection, and it has been closed by the local host.
        /// The most common failure is timeout, but other configuration or authentication failures
        /// can cause this.  m_eOldState = k_ESteamNetworkingConnectionState_Connecting or
        /// k_ESteamNetworkingConnectionState_Connected, and m_info.m_eState = k_ESteamNetworkingConnectionState_ProblemDetectedLocally.
        /// m_info.m_eEndReason and m_info.m_szEndDebug will have for more details.
        /// NOTE: upon receiving this callback, you must still destroy the connection using
        /// ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details
        /// passed to the function are not used in this case, since the connection is already closed.)Remember that callbacks are posted to a queue, and networking connections can
        /// change at any time.  It is possible that the connection has already changed
        /// state by the time you process this callback.Also note that callbacks will be posted when connections are created and destroyed by your own API calls.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetConnectionStatusChangedCallback_t
        {
            public enum SteamNetConnectionStatusChangedCallback_tAnonymousEnum : int
            {
                Icallback,
            }
            
            /// <summary>
            /// Connection handle
            /// </summary>
            public uint m_hConn;
            
            /// <summary>
            /// Full connection info
            /// </summary>
            public Networking.SteamNetConnectionInfo_t m_info;
            
            /// <summary>
            /// Previous state.  (Current state is in m_info.m_eState)
            /// </summary>
            public Networking.ESteamNetworkingConnectionState m_eOldState;
        }
        
        /// <summary>
        /// Describe the state of a connection.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetConnectionInfo_t
        {
            /// <summary>
            /// Who is on the other end?  Depending on the connection type and phase of the connection, we might not know
            /// </summary>
            public Networking.SteamNetworkingIdentity m_identityRemote;
            
            /// <summary>
            /// Arbitrary user data set by the local application code
            /// </summary>
            public long m_nUserData;
            
            /// <summary>
            /// Handle to listen socket this was connected on, or k_HSteamListenSocket_Invalid if we initiated the connection
            /// </summary>
            public uint m_hListenSocket;
            
            /// <summary>
            /// Remote address.  Might be all 0's if we don't know it, or if this is N/A.
            /// (E.g. Basically everything except direct UDP connection.)
            /// </summary>
            public Networking.SteamNetworkingIPAddr m_addrRemote;
            
            public ushort m__pad1;
            
            /// <summary>
            /// What data center is the remote host in?  (0 if we don't know.)
            /// </summary>
            public uint m_idPOPRemote;
            
            /// <summary>
            /// What relay are we using to communicate with the remote host?
            /// (0 if not applicable.)
            /// </summary>
            public uint m_idPOPRelay;
            
            /// <summary>
            /// High level state of the connection
            /// </summary>
            public Networking.ESteamNetworkingConnectionState m_eState;
            
            /// <summary>
            /// Basic cause of the connection termination or problem.
            /// See ESteamNetConnectionEnd for the values used
            /// </summary>
            public int m_eEndReason;
            
            /// <summary>
            /// Human-readable, but non-localized explanation for connection
            /// termination or problem.  This is intended for debugging /
            /// diagnostic purposes only, not to display to users.  It might
            /// have some details specific to the issue.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string m_szEndDebug;
            
            /// <summary>
            /// Debug description.  This includes the internal connection ID,
            /// connection type (and peer information), and any name
            /// given to the connection by the app.  This string is used in various
            /// internal logging messages.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string m_szConnectionDescription;
            
            /// <summary>
            /// Misc flags.  Bitmask of k_nSteamNetworkConnectionInfoFlags_Xxxx
            /// </summary>
            public int m_nFlags;
            
            /// <summary>
            /// Internal stuff, room to change API easily
            /// </summary>
            public fixed uint reserved[63];
        }
        
        /// <summary>
        /// An abstract way to represent the identity of a network host.  All identities can
        /// be represented as simple string.  Furthermore, this string representation is actually
        /// used on the wire in several places, even though it is less efficient, in order to
        /// facilitate forward compatibility.  (Old client code can handle an identity type that
        /// it doesn't understand.)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIdentity
        {
            /// <summary>
            /// Max sizes
            /// </summary>
            public enum SteamNetworkingIdentityAnonymousEnum : int
            {
                /// <summary>
                /// Max length of the buffer needed to hold any identity, formatted in string format by ToString
                /// </summary>
                Cchmaxstring = unchecked((int)128),
                
                /// <summary>
                /// Max length of the string for generic string identities.  Including terminating '
                /// \
                /// 0'
                /// </summary>
                Cchmaxgenericstring = unchecked((int)32),
                
                Cbmaxgenericbytes = unchecked((int)32),
            }
            
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamNetworkingIdentityUnion
            {
                [FieldOffset(0)]
                public ulong m_steamID64;
                
                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
                public string m_szGenericString;
                
                [FieldOffset(0)]
                public fixed byte m_genericBytes[32];
                
                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
                public string m_szUnknownRawString;
                
                [FieldOffset(0)]
                public Networking.SteamNetworkingIPAddr m_ip;
                
                /// <summary>
                /// Pad structure to leave easy room for future expansion
                /// </summary>
                [FieldOffset(0)]
                public fixed uint m_reserved[32];
            }
            
            /// <summary>
            /// Type of identity.
            /// </summary>
            public Networking.ESteamNetworkingIdentityType m_eType;
            
            /// <summary>
            /// Internal representation.  Don't access this directly, use the accessors!
            /// </summary>
            /// <remarks>
            /// Number of bytes that are relevant below.  This MUST ALWAYS be
            /// set.  (Use the accessors!)  This is important to enable old code to work
            /// with new identity types.
            /// </remarks>
            public int m_cbSize;
        }
        
        /// <summary>
        /// Store an IP and port.  IPv6 is always used; IPv4 is represented using
        /// "IPv4-mapped" addresses: IPv4 aa.bb.cc.dd =&gt; IPv6 ::ffff:aabb:ccdd
        /// (RFC 4291 section 2.5.5.2.)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIPAddr
        {
            /// <summary>
            /// Max length of the buffer needed to hold IP formatted using ToString, including '
            /// \
            /// 0'
            /// ([0123:4567:89ab:cdef:0123:4567:89ab:cdef]:12345)
            /// </summary>
            public enum SteamNetworkingIPAddrAnonymousEnum : int
            {
                Cchmaxstring = unchecked((int)48),
            }
            
            /// <summary>
            /// RFC4038, section 4.2
            /// </summary>
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public unsafe partial struct IPv4MappedAddress
            {
                public ulong m_8zeros;
                
                public ushort m_0000;
                
                public ushort m_ffff;
                
                /// <summary>
                /// NOTE: As bytes, i.e. network byte order
                /// </summary>
                public fixed byte m_ip[4];
            }
            
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamNetworkingIPAddrunion
            {
                [FieldOffset(0)]
                public fixed byte m_ipv6[16];
                
                [FieldOffset(0)]
                public Networking.SteamNetworkingIPAddr.IPv4MappedAddress m_ipv4;
            }
            
            /// <summary>
            /// Host byte order
            /// </summary>
            public ushort m_port;
        }
        
        /// <summary>
        /// A struct used to describe our readiness to participate in authenticated,
        /// encrypted communication.  In order to do this we need:
        /// </summary>
        /// <remarks>
        /// - The list of trusted CA certificates that might be relevant for this
        /// app.
        /// - A valid certificate issued by a CA.This callback is posted whenever the state of our readiness changes.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetAuthenticationStatus_t
        {
            public enum SteamNetAuthenticationStatus_tAnonymousEnum : int
            {
                Icallback,
            }
            
            /// <summary>
            /// Status
            /// </summary>
            public Networking.ESteamNetworkingAvailability m_eAvail;
            
            /// <summary>
            /// Non-localized English language status.  For diagnostic/debugging
            /// purposes only.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string m_debugMsg;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamRelayNetworkStatus_t : IEquatable<SteamRelayNetworkStatus_t>
        {
            private readonly IntPtr _handle;
            
            public SteamRelayNetworkStatus_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamRelayNetworkStatus_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamRelayNetworkStatus_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamRelayNetworkStatus_t left, SteamRelayNetworkStatus_t right) => left.Equals(right);
            
            public static bool operator !=(SteamRelayNetworkStatus_t left, SteamRelayNetworkStatus_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamNetworkingMessagesSessionRequest_t : IEquatable<SteamNetworkingMessagesSessionRequest_t>
        {
            private readonly IntPtr _handle;
            
            public SteamNetworkingMessagesSessionRequest_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamNetworkingMessagesSessionRequest_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamNetworkingMessagesSessionRequest_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamNetworkingMessagesSessionRequest_t left, SteamNetworkingMessagesSessionRequest_t right) => left.Equals(right);
            
            public static bool operator !=(SteamNetworkingMessagesSessionRequest_t left, SteamNetworkingMessagesSessionRequest_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamNetworkingMessagesSessionFailed_t : IEquatable<SteamNetworkingMessagesSessionFailed_t>
        {
            private readonly IntPtr _handle;
            
            public SteamNetworkingMessagesSessionFailed_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamNetworkingMessagesSessionFailed_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamNetworkingMessagesSessionFailed_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamNetworkingMessagesSessionFailed_t left, SteamNetworkingMessagesSessionFailed_t right) => left.Equals(right);
            
            public static bool operator !=(SteamNetworkingMessagesSessionFailed_t left, SteamNetworkingMessagesSessionFailed_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamNetworkingFakeIPResult_t : IEquatable<SteamNetworkingFakeIPResult_t>
        {
            private readonly IntPtr _handle;
            
            public SteamNetworkingFakeIPResult_t(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamNetworkingFakeIPResult_t other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamNetworkingFakeIPResult_t other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamNetworkingFakeIPResult_t left, SteamNetworkingFakeIPResult_t right) => left.Equals(right);
            
            public static bool operator !=(SteamNetworkingFakeIPResult_t left, SteamNetworkingFakeIPResult_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Quick connection state, pared down to something you could call
        /// more frequently without it being too big of a perf hit.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetworkingQuickConnectionStatus
        {
            /// <summary>
            /// High level state of the connection
            /// </summary>
            public Networking.ESteamNetworkingConnectionState m_eState;
            
            /// <summary>
            /// Current ping (ms)
            /// </summary>
            public int m_nPing;
            
            /// <summary>
            /// Connection quality measured locally, 0...1.  (Percentage of packets delivered
            /// end-to-end in order).
            /// </summary>
            public float m_flConnectionQualityLocal;
            
            /// <summary>
            /// Packet delivery success rate as observed from remote host
            /// </summary>
            public float m_flConnectionQualityRemote;
            
            /// <summary>
            /// Current data rates from recent history.
            /// </summary>
            public float m_flOutPacketsPerSec;
            
            public float m_flOutBytesPerSec;
            
            public float m_flInPacketsPerSec;
            
            public float m_flInBytesPerSec;
            
            /// <summary>
            /// Estimate rate that we believe that we can send data to our peer.
            /// Note that this could be significantly higher than m_flOutBytesPerSec,
            /// meaning the capacity of the channel is higher than you are sending data.
            /// (That's OK!)
            /// </summary>
            public int m_nSendRateBytesPerSecond;
            
            /// <summary>
            /// Number of bytes pending to be sent.  This is data that you have recently
            /// requested to be sent but has not yet actually been put on the wire.  The
            /// reliable number ALSO includes data that was previously placed on the wire,
            /// but has now been scheduled for re-transmission.  Thus, it's possible to
            /// observe m_cbPendingReliable increasing between two checks, even if no
            /// calls were made to send reliable data between the checks.  Data that is
            /// awaiting the Nagle delay will appear in these numbers.
            /// </summary>
            public int m_cbPendingUnreliable;
            
            public int m_cbPendingReliable;
            
            /// <summary>
            /// Number of bytes of reliable data that has been placed the wire, but
            /// for which we have not yet received an acknowledgment, and thus we may
            /// have to re-transmit.
            /// </summary>
            public int m_cbSentUnackedReliable;
            
            /// <summary>
            /// If you asked us to send a message right now, how long would that message
            /// sit in the queue before we actually started putting packets on the wire?
            /// (And assuming Nagle does not cause any packets to be delayed.)
            /// </summary>
            /// <remarks>
            /// In general, data that is sent by the application is limited by the
            /// bandwidth of the channel.  If you send data faster than this, it must
            /// be queued and put on the wire at a metered rate.  Even sending a small amount
            /// of data (e.g. a few MTU, say ~3k) will require some of the data to be delayed
            /// a bit.In general, the estimated delay will be approximately equal to( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecondplus or minus one MTU.  It depends on how much time has elapsed since the last
            /// packet was put on the wire.  For example, the queue might have *just* been emptied,
            /// and the last packet placed on the wire, and we are exactly up against the send
            /// rate limit.  In that case we might need to wait for one packet's worth of time to
            /// elapse before we can send again.  On the other extreme, the queue might have data
            /// in it waiting for Nagle.  (This will always be less than one packet, because as soon
            /// as we have a complete packet we would send it.)  In that case, we might be ready
            /// to send data now, and this value will be 0.
            /// </remarks>
            public long m_usecQueueTime;
            
            /// <summary>
            /// Internal stuff, room to change API easily
            /// </summary>
            public fixed uint reserved[16];
        }
        
        /// <summary>
        /// A message that has been received.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingMessage_t
        {
            /// <summary>
            /// Message payload
            /// </summary>
            public IntPtr m_pData;
            
            /// <summary>
            /// Size of the payload.
            /// </summary>
            public int m_cbSize;
            
            /// <summary>
            /// For messages received on connections: what connection did this come from?
            /// For outgoing messages: what connection to send it to?
            /// Not used when using the ISteamNetworkingMessages interface
            /// </summary>
            public uint m_conn;
            
            /// <summary>
            /// For inbound messages: Who sent this to us?
            /// For outbound messages on connections: not used.
            /// For outbound messages on the ad-hoc ISteamNetworkingMessages interface: who should we send this to?
            /// </summary>
            public Networking.SteamNetworkingIdentity m_identityPeer;
            
            /// <summary>
            /// For messages received on connections, this is the user data
            /// associated with the connection.
            /// </summary>
            /// <remarks>
            /// This is *usually* the same as calling GetConnection() and then
            /// fetching the user data associated with that connection, but for
            /// the following subtle differences:- This user data will match the connection's user data at the time
            /// is captured at the time the message is returned by the API.
            /// If you subsequently change the userdata on the connection,
            /// this won't be updated.
            /// - This is an inline call, so it's *much* faster.
            /// - You might have closed the connection, so fetching the user data
            /// would not be possible.Not used when sending messages,
            /// </remarks>
            public long m_nConnUserData;
            
            /// <summary>
            /// Local timestamp when the message was received
            /// Not used for outbound messages.
            /// </summary>
            public long m_usecTimeReceived;
            
            /// <summary>
            /// Message number assigned by the sender.
            /// This is not used for outbound messages
            /// </summary>
            public long m_nMessageNumber;
            
            /// <summary>
            /// Function used to free up m_pData.  This mechanism exists so that
            /// apps can create messages with buffers allocated from their own
            /// heap, and pass them into the library.  This function will
            /// usually be something like:
            /// </summary>
            /// <remarks>
            /// free( pMsg-&gt;m_pData );
            /// </remarks>
            public Networking.SteamNetworkingMessage_t.m_pfnFreeDatadelegate m_pfnFreeData;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void m_pfnFreeDatadelegate(ref Networking.SteamNetworkingMessage_t pMsg);
            
            /// <summary>
            /// Function to used to decrement the internal reference count and, if
            /// it's zero, release the message.  You should not set this function pointer,
            /// or need to access this directly!  Use the Release() function instead!
            /// </summary>
            public Networking.SteamNetworkingMessage_t.m_pfnReleasedelegate m_pfnRelease;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void m_pfnReleasedelegate(ref Networking.SteamNetworkingMessage_t pMsg);
            
            /// <summary>
            /// When using ISteamNetworkingMessages, the channel number the message was received on
            /// (Not used for messages sent or received on "connections")
            /// </summary>
            public int m_nChannel;
            
            /// <summary>
            /// Bitmask of k_nSteamNetworkingSend_xxx flags.
            /// For received messages, only the k_nSteamNetworkingSend_Reliable bit is valid.
            /// For outbound messages, all bits are relevant
            /// </summary>
            public int m_nFlags;
            
            /// <summary>
            /// Arbitrary user data that you can use when sending messages using
            /// ISteamNetworkingUtils::AllocateMessage and ISteamNetworkingSockets::SendMessage.
            /// (The callback you set in m_pfnFreeData might use this field.)
            /// </summary>
            /// <remarks>
            /// Not used for received messages.
            /// </remarks>
            public long m_nUserData;
        }
        
        /// <summary>
        /// Object that describes a "location" on the Internet with sufficient
        /// detail that we can reasonably estimate an upper bound on the ping between
        /// the two hosts, even if a direct route between the hosts is not possible,
        /// and the connection must be routed through the Steam Datagram Relay network.
        /// This does not contain any information that identifies the host.  Indeed,
        /// if two hosts are in the same building or otherwise have nearly identical
        /// networking characteristics, then it's valid to use the same location
        /// object for both of them.
        /// </summary>
        /// <remarks>
        /// NOTE: This object should only be used in the same process!  Do not serialize it,
        /// send it over the wire, or persist it in a file or database!  If you need
        /// to do that, convert it to a string representation using the methods in
        /// ISteamNetworkingUtils().
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetworkPingLocation_t
        {
            public fixed byte m_data[512];
        }
        
        /// <summary>
        /// In a few places we need to set configuration options on listen sockets and connections, and
        /// have them take effect *before* the listen socket or connection really starts doing anything.
        /// Creating the object and then setting the options "immediately" after creation doesn't work
        /// completely, because network packets could be received between the time the object is created and
        /// when the options are applied.  To set options at creation time in a reliable way, they must be
        /// passed to the creation function.  This structure is used to pass those options.
        /// </summary>
        /// <remarks>
        /// For the meaning of these fields, see ISteamNetworkingUtils::SetConfigValue.  Basically
        /// when the object is created, we just iterate over the list of options and call
        /// ISteamNetworkingUtils::SetConfigValueStruct, where the scope arguments are supplied by the
        /// object being created.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingConfigValue_t
        {
            /// <summary>
            /// Option value
            /// </summary>
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct SteamNetworkingConfigValue_t_union_m_val
            {
                [FieldOffset(0)]
                public int m_int32;
                
                [FieldOffset(0)]
                public long m_int64;
                
                [FieldOffset(0)]
                public float m_float;
                
                /// <summary>
                /// Points to your '
                /// \
                /// 0'-terminated buffer
                /// </summary>
                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.LPStr)]
                public string m_string;
                
                [FieldOffset(0)]
                public IntPtr m_ptr;
            }
            
            /// <summary>
            /// Which option is being set
            /// </summary>
            public Networking.ESteamNetworkingConfigValue m_eValue;
            
            /// <summary>
            /// Which field below did you fill in?
            /// </summary>
            public Networking.ESteamNetworkingConfigDataType m_eDataType;
            
            public Networking.SteamNetworkingConfigValue_t.SteamNetworkingConfigValue_t_union_m_val m_val;
        }
        
        /// <summary>
        /// Utility class for printing a SteamNetworkingPOPID.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingPOPIDRender
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)]
            public string buf;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ISteamNetworkingConnectionSignaling : IEquatable<ISteamNetworkingConnectionSignaling>
        {
            private readonly IntPtr _handle;
            
            public ISteamNetworkingConnectionSignaling(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ISteamNetworkingConnectionSignaling other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ISteamNetworkingConnectionSignaling other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ISteamNetworkingConnectionSignaling left, ISteamNetworkingConnectionSignaling right) => left.Equals(right);
            
            public static bool operator !=(ISteamNetworkingConnectionSignaling left, ISteamNetworkingConnectionSignaling right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ISteamNetworkingSignalingRecvContext : IEquatable<ISteamNetworkingSignalingRecvContext>
        {
            private readonly IntPtr _handle;
            
            public ISteamNetworkingSignalingRecvContext(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ISteamNetworkingSignalingRecvContext other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ISteamNetworkingSignalingRecvContext other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ISteamNetworkingSignalingRecvContext left, ISteamNetworkingSignalingRecvContext right) => left.Equals(right);
            
            public static bool operator !=(ISteamNetworkingSignalingRecvContext left, ISteamNetworkingSignalingRecvContext right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ISteamNetworkingFakeUDPPort : IEquatable<ISteamNetworkingFakeUDPPort>
        {
            private readonly IntPtr _handle;
            
            public ISteamNetworkingFakeUDPPort(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(ISteamNetworkingFakeUDPPort other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is ISteamNetworkingFakeUDPPort other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(ISteamNetworkingFakeUDPPort left, ISteamNetworkingFakeUDPPort right) => left.Equals(right);
            
            public static bool operator !=(ISteamNetworkingFakeUDPPort left, ISteamNetworkingFakeUDPPort right) => !left.Equals(right);
        }
        
        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Lower level networking API.
        /// </summary>
        /// <remarks>
        /// - Connection-oriented API (like TCP, not UDP).  When sending and receiving
        /// messages, a connection handle is used.  (For a UDP-style interface, where
        /// the peer is identified by their address with each send/recv call, see
        /// ISteamNetworkingMessages.)  The typical pattern is for a "server" to "listen"
        /// on a "listen socket."  A "client" will "connect" to the server, and the
        /// server will "accept" the connection.  If you have a symmetric situation
        /// where either peer may initiate the connection and server/client roles are
        /// not clearly defined, check out k_ESteamNetworkingConfig_SymmetricConnect.
        /// - But unlike TCP, it's message-oriented, not stream-oriented.
        /// - Mix of reliable and unreliable messages
        /// - Fragmentation and reassembly
        /// - Supports connectivity over plain UDP
        /// - Also supports SDR ("Steam Datagram Relay") connections, which are
        /// addressed by the identity of the peer.  There is a "P2P" use case and
        /// a "hosted dedicated server" use case.Note that neither of the terms "connection" nor "socket" necessarily correspond
        /// one-to-one with an underlying UDP socket.  An attempt has been made to
        /// keep the semantics as similar to the standard socket model when appropriate,
        /// but some deviations do exist.See also: ISteamNetworkingMessages, the UDP-style interface.  This API might be
        /// easier to use, especially when porting existing UDP code.
        /// </remarks>
        public interface ISteamNetworkingSockets
        {
            /// <summary>
            /// Creates a "server" socket that listens for clients to connect to by 
            /// calling ConnectByIPAddress, over ordinary UDP (IPv4 or IPv6)
            /// </summary>
            /// <remarks>
            /// You must select a specific local port to listen on and set it
            /// the port field of the local address.Usually you will set the IP portion of the address to zero (SteamNetworkingIPAddr::Clear()).
            /// This means that you will not bind to any particular local interface (i.e. the same
            /// as INADDR_ANY in plain socket code).  Furthermore, if possible the socket will be bound
            /// in "dual stack" mode, which means that it can accept both IPv4 and IPv6 client connections.
            /// If you really do wish to bind a particular interface, then set the local address to the
            /// appropriate IPv4 or IPv6 IP.If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.When a client attempts to connect, a SteamNetConnectionStatusChangedCallback_t
            /// will be posted.  The connection will be in the connecting state.
            /// </remarks>
            uint CreateListenSocketIP(ref Networking.SteamNetworkingIPAddr localAddress, int nOptions, in Networking.SteamNetworkingConfigValue_t pOptions);
            
            /// <summary>
            /// Creates a connection and begins talking to a "server" over UDP at the
            /// given IPv4 or IPv6 address.  The remote host must be listening with a
            /// matching call to CreateListenSocketIP on the specified port.
            /// </summary>
            /// <remarks>
            /// A SteamNetConnectionStatusChangedCallback_t callback will be triggered when we start
            /// connecting, and then another one on either timeout or successful connection.If the server does not have any identity configured, then their network address
            /// will be the only identity in use.  Or, the network host may provide a platform-specific
            /// identity with or without a valid certificate to authenticate that identity.  (These
            /// details will be contained in the SteamNetConnectionStatusChangedCallback_t.)  It's
            /// up to your application to decide whether to allow the connection.By default, all connections will get basic encryption sufficient to prevent
            /// casual eavesdropping.  But note that without certificates (or a shared secret
            /// distributed through some other out-of-band mechanism), you don't have any
            /// way of knowing who is actually on the other end, and thus are vulnerable to
            /// man-in-the-middle attacks.If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint ConnectByIPAddress(ref Networking.SteamNetworkingIPAddr address, int nOptions, in Networking.SteamNetworkingConfigValue_t pOptions);
            
            /// <summary>
            /// Like CreateListenSocketIP, but clients will connect using ConnectP2P.
            /// </summary>
            /// <remarks>
            /// nLocalVirtualPort specifies how clients can connect to this socket using
            /// ConnectP2P.  It's very common for applications to only have one listening socket;
            /// in that case, use zero.  If you need to open multiple listen sockets and have clients
            /// be able to connect to one or the other, then nLocalVirtualPort should be a small
            /// integer (
            /// &lt;
            /// 1000) unique to each listen socket you create.If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()
            /// when your app initializes.If you are listening on a dedicated servers in known data center,
            /// then you can listen using this function instead of CreateHostedDedicatedServerListenSocket,
            /// to allow clients to connect without a ticket.  Any user that owns
            /// the app and is signed into Steam will be able to attempt to connect to
            /// your server.  Also, a connection attempt may require the client to
            /// be connected to Steam, which is one more moving part that may fail.  When
            /// tickets are used, then once a ticket is obtained, a client can connect to
            /// your server even if they got disconnected from Steam or Steam is offline.If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint CreateListenSocketP2P(int nLocalVirtualPort, int nOptions, in Networking.SteamNetworkingConfigValue_t pOptions);
            
            /// <summary>
            /// Begin connecting to a peer that is identified using a platform-specific identifier.
            /// This uses the default rendezvous service, which depends on the platform and library
            /// configuration.  (E.g. on Steam, it goes through the steam backend.)
            /// </summary>
            /// <remarks>
            /// If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.To use your own signaling service, see:
            /// - ConnectP2PCustomSignaling
            /// - k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling
            /// </remarks>
            uint ConnectP2P(ref Networking.SteamNetworkingIdentity identityRemote, int nRemoteVirtualPort, int nOptions, in Networking.SteamNetworkingConfigValue_t pOptions);
            
            /// <summary>
            /// Accept an incoming connection that has been received on a listen socket.
            /// </summary>
            /// <remarks>
            /// When a connection attempt is received (perhaps after a few basic handshake
            /// packets have been exchanged to prevent trivial spoofing), a connection interface
            /// object is created in the k_ESteamNetworkingConnectionState_Connecting state
            /// and a SteamNetConnectionStatusChangedCallback_t is posted.  At this point, your
            /// application MUST either accept or close the connection.  (It may not ignore it.)
            /// Accepting the connection will transition it either into the connected state,
            /// or the finding route state, depending on the connection type.You should take action within a second or two, because accepting the connection is
            /// what actually sends the reply notifying the client that they are connected.  If you
            /// delay taking action, from the client's perspective it is the same as the network
            /// being unresponsive, and the client may timeout the connection attempt.  In other
            /// words, the client cannot distinguish between a delay caused by network problems
            /// and a delay caused by the application.This means that if your application goes for more than a few seconds without
            /// processing callbacks (for example, while loading a map), then there is a chance
            /// that a client may attempt to connect in that interval and fail due to timeout.If the application does not respond to the connection attempt in a timely manner,
            /// and we stop receiving communication from the client, the connection attempt will
            /// be timed out locally, transitioning the connection to the
            /// k_ESteamNetworkingConnectionState_ProblemDetectedLocally state.  The client may also
            /// close the connection before it is accepted, and a transition to the
            /// k_ESteamNetworkingConnectionState_ClosedByPeer is also possible depending the exact
            /// sequence of events.Returns k_EResultInvalidParam if the handle is invalid.
            /// Returns k_EResultInvalidState if the connection is not in the appropriate state.
            /// (Remember that the connection state could change in between the time that the
            /// notification being posted to the queue and when it is received by the application.)A note about connection configuration options.  If you need to set any configuration
            /// options that are common to all connections accepted through a particular listen
            /// socket, consider setting the options on the listen socket, since such options are
            /// inherited automatically.  If you really do need to set options that are connection
            /// specific, it is safe to set them on the connection before accepting the connection.
            /// </remarks>
            Networking.EResult AcceptConnection(uint hConn);
            
            /// <summary>
            /// Disconnects from the remote host and invalidates the connection handle.
            /// Any unread data on the connection is discarded.
            /// </summary>
            /// <remarks>
            /// nReason is an application defined code that will be received on the other
            /// end and recorded (when possible) in backend analytics.  The value should
            /// come from a restricted range.  (See ESteamNetConnectionEnd.)  If you don't need
            /// to communicate any information to the remote host, and do not want analytics to
            /// be able to distinguish "normal" connection terminations from "exceptional" ones,
            /// You may pass zero, in which case the generic value of
            /// k_ESteamNetConnectionEnd_App_Generic will be used.pszDebug is an optional human-readable diagnostic string that will be received
            /// by the remote host and recorded (when possible) in backend analytics.If you wish to put the socket into a "linger" state, where an attempt is made to
            /// flush any remaining sent data, use bEnableLinger=true.  Otherwise reliable data
            /// is not flushed.If the connection has already ended and you are just freeing up the
            /// connection interface, the reason code, debug string, and linger flag are
            /// ignored.
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool CloseConnection(uint hPeer, int nReason, [MarshalAs(UnmanagedType.LPStr)] string pszDebug, [MarshalAs(UnmanagedType.U1)] bool bEnableLinger);
            
            /// <summary>
            /// Destroy a listen socket.  All the connections that were accepting on the listen
            /// socket are closed ungracefully.
            /// </summary>
            [return:MarshalAs(UnmanagedType.U1)]
            bool CloseListenSocket(uint hSocket);
            
            /// <summary>
            /// Set connection user data.  the data is returned in the following places
            /// - You can query it using GetConnectionUserData.
            /// - The SteamNetworkingmessage_t structure.
            /// - The SteamNetConnectionInfo_t structure.
            /// (Which is a member of SteamNetConnectionStatusChangedCallback_t -- but see WARNINGS below!!!!)
            /// </summary>
            /// <remarks>
            /// Do you need to set this atomically when the connection is created?
            /// See k_ESteamNetworkingConfig_ConnectionUserData.WARNING: Be *very careful* when using the value provided in callbacks structs.
            /// Callbacks are queued, and the value that you will receive in your
            /// callback is the userdata that was effective at the time the callback
            /// was queued.  There are subtle race conditions that can hapen if you
            /// don't understand this!If any incoming messages for this connection are queued, the userdata
            /// field is updated, so that when when you receive messages (e.g. with
            /// ReceiveMessagesOnConnection), they will always have the very latest
            /// userdata.  So the tricky race conditions that can happen with callbacks
            /// do not apply to retrieving messages.Returns false if the handle is invalid.
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool SetConnectionUserData(uint hPeer, long nUserData);
            
            /// <summary>
            /// Fetch connection user data.  Returns -1 if handle is invalid
            /// or if you haven't set any userdata on the connection.
            /// </summary>
            long GetConnectionUserData(uint hPeer);
            
            /// <summary>
            /// Set a name for the connection, used mostly for debugging
            /// </summary>
            void SetConnectionName(uint hPeer, [MarshalAs(UnmanagedType.LPStr)] string pszName);
            
            /// <summary>
            /// Fetch connection name.  Returns false if handle is invalid
            /// </summary>
            [return:MarshalAs(UnmanagedType.U1)]
            bool GetConnectionName(uint hPeer, IntPtr pszName, int nMaxLen);
            
            /// <summary>
            /// Send a message to the remote host on the specified connection.
            /// </summary>
            /// <remarks>
            /// nSendFlags determines the delivery guarantees that will be provided,
            /// when data should be buffered, etc.  E.g. k_nSteamNetworkingSend_UnreliableNote that the semantics we use for messages are not precisely
            /// the same as the semantics of a standard "stream" socket.
            /// (SOCK_STREAM)  For an ordinary stream socket, the boundaries
            /// between chunks are not considered relevant, and the sizes of
            /// the chunks of data written will not necessarily match up to
            /// the sizes of the chunks that are returned by the reads on
            /// the other end.  The remote host might read a partial chunk,
            /// or chunks might be coalesced.  For the message semantics 
            /// used here, however, the sizes WILL match.  Each send call 
            /// will match a successful read call on the remote host 
            /// one-for-one.  If you are porting existing stream-oriented 
            /// code to the semantics of reliable messages, your code should 
            /// work the same, since reliable message semantics are more 
            /// strict than stream semantics.  The only caveat is related to 
            /// performance: there is per-message overhead to retain the 
            /// message sizes, and so if your code sends many small chunks 
            /// of data, performance will suffer. Any code based on stream 
            /// sockets that does not write excessively small chunks will 
            /// work without any changes.The pOutMessageNumber is an optional pointer to receive the
            /// message number assigned to the message, if sending was successful.Returns:
            /// - k_EResultInvalidParam: invalid connection handle, or the individual message is too big.
            /// (See k_cbMaxSteamNetworkingSocketsMessageSizeSend)
            /// - k_EResultInvalidState: connection is in an invalid state
            /// - k_EResultNoConnection: connection has ended
            /// - k_EResultIgnored: You used k_nSteamNetworkingSend_NoDelay, and the message was dropped because
            /// we were not ready to send it.
            /// - k_EResultLimitExceeded: there was already too much data queued to be sent.
            /// (See k_ESteamNetworkingConfig_SendBufferSize)
            /// </remarks>
            Networking.EResult SendMessageToConnection(uint hConn, IntPtr pData, uint cbData, int nSendFlags, ref long pOutMessageNumber);

            /// <summary>
            /// Send a message to the remote host on the specified connection.
            /// </summary>
            /// <remarks>
            /// nSendFlags determines the delivery guarantees that will be provided,
            /// when data should be buffered, etc.  E.g. k_nSteamNetworkingSend_UnreliableNote that the semantics we use for messages are not precisely
            /// the same as the semantics of a standard "stream" socket.
            /// (SOCK_STREAM)  For an ordinary stream socket, the boundaries
            /// between chunks are not considered relevant, and the sizes of
            /// the chunks of data written will not necessarily match up to
            /// the sizes of the chunks that are returned by the reads on
            /// the other end.  The remote host might read a partial chunk,
            /// or chunks might be coalesced.  For the message semantics 
            /// used here, however, the sizes WILL match.  Each send call 
            /// will match a successful read call on the remote host 
            /// one-for-one.  If you are porting existing stream-oriented 
            /// code to the semantics of reliable messages, your code should 
            /// work the same, since reliable message semantics are more 
            /// strict than stream semantics.  The only caveat is related to 
            /// performance: there is per-message overhead to retain the 
            /// message sizes, and so if your code sends many small chunks 
            /// of data, performance will suffer. Any code based on stream 
            /// sockets that does not write excessively small chunks will 
            /// work without any changes.The pOutMessageNumber is an optional pointer to receive the
            /// message number assigned to the message, if sending was successful.Returns:
            /// - k_EResultInvalidParam: invalid connection handle, or the individual message is too big.
            /// (See k_cbMaxSteamNetworkingSocketsMessageSizeSend)
            /// - k_EResultInvalidState: connection is in an invalid state
            /// - k_EResultNoConnection: connection has ended
            /// - k_EResultIgnored: You used k_nSteamNetworkingSend_NoDelay, and the message was dropped because
            /// we were not ready to send it.
            /// - k_EResultLimitExceeded: there was already too much data queued to be sent.
            /// (See k_ESteamNetworkingConfig_SendBufferSize)
            /// </remarks>
            Networking.EResult SendMessageToConnection(uint hConn, byte[] pData, uint cbData, int nSendFlags, ref long pOutMessageNumber);

            /// <summary>
            /// Send one or more messages without copying the message payload.
            /// This is the most efficient way to send messages. To use this
            /// function, you must first allocate a message object using
            /// ISteamNetworkingUtils::AllocateMessage.  (Do not declare one
            /// on the stack or allocate your own.)
            /// </summary>
            /// <remarks>
            /// You should fill in the message payload.  You can either let
            /// it allocate the buffer for you and then fill in the payload,
            /// or if you already have a buffer allocated, you can just point
            /// m_pData at your buffer and set the callback to the appropriate function
            /// to free it.  Note that if you use your own buffer, it MUST remain valid
            /// until the callback is executed.  And also note that your callback can be
            /// invoked at any time from any thread (perhaps even before SendMessages
            /// returns!), so it MUST be fast and threadsafe.You MUST also fill in:
            /// - m_conn - the handle of the connection to send the message to
            /// - m_nFlags - bitmask of k_nSteamNetworkingSend_xxx flags.All other fields are currently reserved and should not be modified.The library will take ownership of the message structures.  They may
            /// be modified or become invalid at any time, so you must not read them
            /// after passing them to this function.pOutMessageNumberOrResult is an optional array that will receive,
            /// for each message, the message number that was assigned to the message
            /// if sending was successful.  If sending failed, then a negative EResult
            /// value is placed into the array.  For example, the array will hold
            /// -k_EResultInvalidState if the connection was in an invalid state.
            /// See ISteamNetworkingSockets::SendMessageToConnection for possible
            /// failure codes.
            /// </remarks>
            void SendMessages(int nMessages, out IntPtr pMessages, ref long pOutMessageNumberOrResult);
            
            /// <summary>
            /// Flush any messages waiting on the Nagle timer and send them
            /// at the next transmission opportunity (often that means right now).
            /// </summary>
            /// <remarks>
            /// If Nagle is enabled (it's on by default) then when calling 
            /// SendMessageToConnection the message will be buffered, up to the Nagle time
            /// before being sent, to merge small messages into the same packet.
            /// (See k_ESteamNetworkingConfig_NagleTime)Returns:
            /// k_EResultInvalidParam: invalid connection handle
            /// k_EResultInvalidState: connection is in an invalid state
            /// k_EResultNoConnection: connection has ended
            /// k_EResultIgnored: We weren't (yet) connected, so this operation has no effect.
            /// </remarks>
            Networking.EResult FlushMessagesOnConnection(uint hConn);
            
            /// <summary>
            /// Fetch the next available message(s) from the connection, if any.
            /// Returns the number of messages returned into your array, up to nMaxMessages.
            /// If the connection handle is invalid, -1 is returned.
            /// </summary>
            /// <remarks>
            /// The order of the messages returned in the array is relevant.
            /// Reliable messages will be received in the order they were sent (and with the
            /// same sizes --- see SendMessageToConnection for on this subtle difference from a stream socket).Unreliable messages may be dropped, or delivered out of order with respect to
            /// each other or with respect to reliable messages.  The same unreliable message
            /// may be received multiple times.If any messages are returned, you MUST call SteamNetworkingMessage_t::Release() on each
            /// of them free up resources after you are done.  It is safe to keep the object alive for
            /// a little while (put it into some queue, etc), and you may call Release() from any thread.
            /// </remarks>
            int ReceiveMessagesOnConnection(uint hConn, out IntPtr ppOutMessages, int nMaxMessages);
            
            /// <summary>
            /// Returns basic information about the high-level state of the connection.
            /// </summary>
            [return:MarshalAs(UnmanagedType.U1)]
            bool GetConnectionInfo(uint hConn, ref Networking.SteamNetConnectionInfo_t pInfo);
            
            /// <summary>
            /// Returns a small set of information about the real-time state of the connection
            /// Returns false if the connection handle is invalid, or the connection has ended.
            /// </summary>
            [return:MarshalAs(UnmanagedType.U1)]
            bool GetQuickConnectionStatus(uint hConn, ref Networking.SteamNetworkingQuickConnectionStatus pStats);
            
            /// <summary>
            /// Returns detailed connection stats in text format.  Useful
            /// for dumping to a log, etc.
            /// </summary>
            /// <remarks>
            /// Returns:
            /// -1 failure (bad connection handle)
            /// 0 OK, your buffer was filled in and '
            /// \
            /// 0'-terminated
            /// &gt;0 Your buffer was either nullptr, or it was too small and the text got truncated.
            /// Try again with a buffer of at least N bytes.
            /// </remarks>
            int GetDetailedConnectionStatus(uint hConn, IntPtr pszBuf, int cbBuf);
            
            /// <summary>
            /// Returns local IP and port that a listen socket created using CreateListenSocketIP is bound to.
            /// </summary>
            /// <remarks>
            /// An IPv6 address of ::0 means "any IPv4 or IPv6"
            /// An IPv6 address of ::ffff:0000:0000 means "any IPv4"
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool GetListenSocketAddress(uint hSocket, ref Networking.SteamNetworkingIPAddr address);
            
            /// <summary>
            /// Create a pair of connections that are talking to each other, e.g. a loopback connection.
            /// This is very useful for testing, or so that your client/server code can work the same
            /// even when you are running a local "server".
            /// </summary>
            /// <remarks>
            /// The two connections will immediately be placed into the connected state, and no callbacks
            /// will be posted immediately.  After this, if you close either connection, the other connection
            /// will receive a callback, exactly as if they were communicating over the network.  You must
            /// close *both* sides in order to fully clean up the resources!By default, internal buffers are used, completely bypassing the network, the chopping up of
            /// messages into packets, encryption, copying the payload, etc.  This means that loopback
            /// packets, by default, will not simulate lag or loss.  Passing true for bUseNetworkLoopback will
            /// cause the socket pair to send packets through the local network loopback device (127.0.0.1)
            /// on ephemeral ports.  Fake lag and loss are supported in this case, and CPU time is expended
            /// to encrypt and decrypt.If you wish to assign a specific identity to either connection, you may pass a particular
            /// identity.  Otherwise, if you pass nullptr, the respective connection will assume a generic
            /// "localhost" identity.  If you use real network loopback, this might be translated to the
            /// actual bound loopback port.  Otherwise, the port will be zero.
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool CreateSocketPair(ref uint pOutConnection1, ref uint pOutConnection2, [MarshalAs(UnmanagedType.U1)] bool bUseNetworkLoopback, in Networking.SteamNetworkingIdentity pIdentity1, in Networking.SteamNetworkingIdentity pIdentity2);
            
            /// <summary>
            /// Get the identity assigned to this interface.
            /// E.g. on Steam, this is the user's SteamID, or for the gameserver interface, the SteamID assigned
            /// to the gameserver.  Returns false and sets the result to an invalid identity if we don't know
            /// our identity yet.  (E.g. GameServer has not logged in.  On Steam, the user will know their SteamID
            /// even if they are not signed into Steam.)
            /// </summary>
            [return:MarshalAs(UnmanagedType.U1)]
            bool GetIdentity(ref Networking.SteamNetworkingIdentity pIdentity);
            
            /// <summary>
            /// Indicate our desire to be ready participate in authenticated communications.
            /// If we are currently not ready, then steps will be taken to obtain the necessary
            /// certificates.   (This includes a certificate for us, as well as any CA certificates
            /// needed to authenticate peers.)
            /// </summary>
            /// <remarks>
            /// You can call this at program init time if you know that you are going to
            /// be making authenticated connections, so that we will be ready immediately when
            /// those connections are attempted.  (Note that essentially all connections require
            /// authentication, with the exception of ordinary UDP connections with authentication
            /// disabled using k_ESteamNetworkingConfig_IP_AllowWithoutAuth.)  If you don't call
            /// this function, we will wait until a feature is utilized that that necessitates
            /// these resources.You can also call this function to force a retry, if failure has occurred.
            /// Once we make an attempt and fail, we will not automatically retry.
            /// In this respect, the behavior of the system after trying and failing is the same
            /// as before the first attempt: attempting authenticated communication or calling
            /// this function will call the system to attempt to acquire the necessary resources.You can use GetAuthenticationStatus or listen for SteamNetAuthenticationStatus_t
            /// to monitor the status.Returns the current value that would be returned from GetAuthenticationStatus.
            /// </remarks>
            Networking.ESteamNetworkingAvailability InitAuthentication();
            
            /// <summary>
            /// Query our readiness to participate in authenticated communications.  A
            /// SteamNetAuthenticationStatus_t callback is posted any time this status changes,
            /// but you can use this function to query it at any time.
            /// </summary>
            /// <remarks>
            /// The value of SteamNetAuthenticationStatus_t::m_eAvail is returned.  If you only
            /// want this high level status, you can pass NULL for pDetails.  If you want further
            /// details, pass non-NULL to receive them.
            /// </remarks>
            Networking.ESteamNetworkingAvailability GetAuthenticationStatus(ref Networking.SteamNetAuthenticationStatus_t pDetails);
            
            /// <summary>
            /// Create a new poll group.
            /// </summary>
            /// <remarks>
            /// You should destroy the poll group when you are done using DestroyPollGroup
            /// </remarks>
            uint CreatePollGroup();
            
            /// <summary>
            /// Destroy a poll group created with CreatePollGroup().
            /// </summary>
            /// <remarks>
            /// If there are any connections in the poll group, they are removed from the group,
            /// and left in a state where they are not part of any poll group.
            /// Returns false if passed an invalid poll group handle.
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool DestroyPollGroup(uint hPollGroup);
            
            /// <summary>
            /// Assign a connection to a poll group.  Note that a connection may only belong to a
            /// single poll group.  Adding a connection to a poll group implicitly removes it from
            /// any other poll group it is in.
            /// </summary>
            /// <remarks>
            /// You can pass k_HSteamNetPollGroup_Invalid to remove a connection from its current
            /// poll group without adding it to a new poll group.If there are received messages currently pending on the connection, an attempt
            /// is made to add them to the queue of messages for the poll group in approximately
            /// the order that would have applied if the connection was already part of the poll
            /// group at the time that the messages were received.Returns false if the connection handle is invalid, or if the poll group handle
            /// is invalid (and not k_HSteamNetPollGroup_Invalid).
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool SetConnectionPollGroup(uint hConn, uint hPollGroup);
            
            /// <summary>
            /// Same as ReceiveMessagesOnConnection, but will return the next messages available
            /// on any connection in the poll group.  Examine SteamNetworkingMessage_t::m_conn
            /// to know which connection.  (SteamNetworkingMessage_t::m_nConnUserData might also
            /// be useful.)
            /// </summary>
            /// <remarks>
            /// Delivery order of messages among different connections will usually match the
            /// order that the last packet was received which completed the message.  But this
            /// is not a strong guarantee, especially for packets received right as a connection
            /// is being assigned to poll group.Delivery order of messages on the same connection is well defined and the
            /// same guarantees are present as mentioned in ReceiveMessagesOnConnection.
            /// (But the messages are not grouped by connection, so they will not necessarily
            /// appear consecutively in the list; they may be interleaved with messages for
            /// other connections.)
            /// </remarks>
            int ReceiveMessagesOnPollGroup(uint hPollGroup, out IntPtr ppOutMessages, int nMaxMessages);
            
            /// <summary>
            /// Call this when you receive a ticket from your backend / matchmaking system.  Puts the
            /// ticket into a persistent cache, and optionally returns the parsed ticket.
            /// </summary>
            /// <remarks>
            /// See stamdatagram_ticketgen.h for more details.
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool ReceivedRelayAuthTicket(IntPtr pvTicket, int cbTicket, Networking.SteamDatagramRelayAuthTicket pOutParsedTicket);
            
            /// <summary>
            /// Search cache for a ticket to talk to the server on the specified virtual port.
            /// If found, returns the number of seconds until the ticket expires, and optionally
            /// the complete cracked ticket.  Returns 0 if we don't have a ticket.
            /// </summary>
            /// <remarks>
            /// Typically this is useful just to confirm that you have a ticket, before you
            /// call ConnectToHostedDedicatedServer to connect to the server.
            /// </remarks>
            int FindRelayAuthTicketForServer(ref Networking.SteamNetworkingIdentity identityGameServer, int nRemoteVirtualPort, Networking.SteamDatagramRelayAuthTicket pOutParsedTicket);
            
            /// <summary>
            /// Client call to connect to a server hosted in a Valve data center, on the specified virtual
            /// port.  You must have placed a ticket for this server into the cache, or else this connect
            /// attempt will fail!  If you are not issuing your own tickets, then to connect to a dedicated
            /// server via SDR in auto-ticket mode, use ConnectP2P.  (The server must be configured to allow
            /// this type of connection by listening using CreateListenSocketP2P.)
            /// </summary>
            /// <remarks>
            /// You may wonder why tickets are stored in a cache, instead of simply being passed as an argument
            /// here.  The reason is to make reconnection to a gameserver robust, even if the client computer loses
            /// connection to Steam or the central backend, or the app is restarted or crashes, etc.If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()
            /// when your app initializesIf you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint ConnectToHostedDedicatedServer(ref Networking.SteamNetworkingIdentity identityTarget, int nRemoteVirtualPort, int nOptions, in Networking.SteamNetworkingConfigValue_t pOptions);
            
            /// <summary>
            /// Returns the value of the SDR_LISTEN_PORT environment variable.  This
            /// is the UDP server your server will be listening on.  This will
            /// configured automatically for you in production environments.
            /// </summary>
            /// <remarks>
            /// In development, you'll need to set it yourself.  See
            /// https://partner.steamgames.com/doc/api/ISteamNetworkingSockets
            /// for more information on how to configure dev environments.
            /// </remarks>
            ushort GetHostedDedicatedServerPort();
            
            /// <summary>
            /// Returns 0 if SDR_LISTEN_PORT is not set.  Otherwise, returns the data center the server
            /// is running in.  This will be k_SteamDatagramPOPID_dev in non-production environment.
            /// </summary>
            uint GetHostedDedicatedServerPOPID();
            
            /// <summary>
            /// Return info about the hosted server.  This contains the PoPID of the server,
            /// and opaque routing information that can be used by the relays to send traffic
            /// to your server.
            /// </summary>
            /// <remarks>
            /// You will need to send this information to your backend, and put it in tickets,
            /// so that the relays will know how to forward traffic from
            /// clients to your server.  See SteamDatagramRelayAuthTicket for more info.Also, note that the routing information is contained in SteamDatagramGameCoordinatorServerLogin,
            /// so if possible, it's preferred to use GetGameCoordinatorServerLogin to send this info
            /// to your game coordinator service, and also login securely at the same time.On a successful exit, k_EResultOK is returnedUnsuccessful exit:
            /// - Something other than k_EResultOK is returned.
            /// - k_EResultInvalidState: We are not configured to listen for SDR (SDR_LISTEN_SOCKET
            /// is not set.)
            /// - k_EResultPending: we do not (yet) have the authentication information needed.
            /// (See GetAuthenticationStatus.)  If you use environment variables to pre-fetch
            /// the network config, this data should always be available immediately.
            /// - A non-localized diagnostic debug message will be placed in m_data that describes
            /// the cause of the failure.NOTE: The returned blob is not encrypted.  Send it to your backend, but don't
            /// directly share it with clients.
            /// </remarks>
            Networking.EResult GetHostedDedicatedServerAddress(Networking.SteamDatagramHostedAddress pRouting);
            
            /// <summary>
            /// Create a listen socket on the specified virtual port.  The physical UDP port to use
            /// will be determined by the SDR_LISTEN_PORT environment variable.  If a UDP port is not
            /// configured, this call will fail.
            /// </summary>
            /// <remarks>
            /// This call MUST be made through the SteamGameServerNetworkingSockets() interface.This function should be used when you are using the ticket generator library
            /// to issue your own tickets.  Clients connecting to the server on this virtual
            /// port will need a ticket, and they must connect using ConnectToHostedDedicatedServer.If you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint CreateHostedDedicatedServerListenSocket(int nLocalVirtualPort, int nOptions, in Networking.SteamNetworkingConfigValue_t pOptions);
            
            /// <summary>
            /// Generate an authentication blob that can be used to securely login with
            /// your backend, using SteamDatagram_ParseHostedServerLogin.  (See
            /// steamdatagram_gamecoordinator.h)
            /// </summary>
            /// <remarks>
            /// Before calling the function:
            /// - Populate the app data in pLoginInfo (m_cbAppData and m_appData).  You can leave
            /// all other fields uninitialized.
            /// - *pcbSignedBlob contains the size of the buffer at pBlob.  (It should be
            /// at least k_cbMaxSteamDatagramGameCoordinatorServerLoginSerialized.)On a successful exit:
            /// - k_EResultOK is returned
            /// - All of the remaining fields of pLoginInfo will be filled out.
            /// - *pcbSignedBlob contains the size of the serialized blob that has been
            /// placed into pBlob.Unsuccessful exit:
            /// - Something other than k_EResultOK is returned.
            /// - k_EResultNotLoggedOn: you are not logged in (yet)
            /// - See GetHostedDedicatedServerAddress for more potential failure return values.
            /// - A non-localized diagnostic debug message will be placed in pBlob that describes
            /// the cause of the failure.This works by signing the contents of the SteamDatagramGameCoordinatorServerLogin
            /// with the cert that is issued to this server.  In dev environments, it's OK if you do
            /// not have a cert.  (You will need to enable insecure dev login in SteamDatagram_ParseHostedServerLogin.)
            /// Otherwise, you will need a signed cert.NOTE: The routing blob returned here is not encrypted.  Send it to your backend
            /// and don't share it directly with clients.
            /// </remarks>
            Networking.EResult GetGameCoordinatorServerLogin(Networking.SteamDatagramGameCoordinatorServerLogin pLoginInfo, ref int pcbSignedBlob, IntPtr pBlob);
            
            /// <summary>
            /// Create a P2P "client" connection that does signaling over a custom
            /// rendezvous/signaling channel.
            /// </summary>
            /// <remarks>
            /// pSignaling points to a new object that you create just for this connection.
            /// It must stay valid until Release() is called.  Once you pass the
            /// object to this function, it assumes ownership.  Release() will be called
            /// from within the function call if the call fails.  Furthermore, until Release()
            /// is called, you should be prepared for methods to be invoked on your
            /// object from any thread!  You need to make sure your object is threadsafe!
            /// Furthermore, you should make sure that dispatching the methods is done
            /// as quickly as possible.This function will immediately construct a connection in the "connecting"
            /// state.  Soon after (perhaps before this function returns, perhaps in another thread),
            /// the connection will begin sending signaling messages by calling
            /// ISteamNetworkingConnectionSignaling::SendSignal.When the remote peer accepts the connection (See
            /// ISteamNetworkingSignalingRecvContext::OnConnectRequest),
            /// it will begin sending signaling messages.  When these messages are received,
            /// you can pass them to the connection using ReceivedP2PCustomSignal.If you know the identity of the peer that you expect to be on the other end,
            /// you can pass their identity to improve debug output or just detect bugs.
            /// If you don't know their identity yet, you can pass NULL, and their
            /// identity will be established in the connection handshake.If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()
            /// when your app initializesIf you need to set any initial config options, pass them here.  See
            /// SteamNetworkingConfigValue_t for more about why this is preferable to
            /// setting the options "immediately" after creation.
            /// </remarks>
            uint ConnectP2PCustomSignaling(Networking.ISteamNetworkingConnectionSignaling pSignaling, in Networking.SteamNetworkingIdentity pPeerIdentity, int nRemoteVirtualPort, int nOptions, in Networking.SteamNetworkingConfigValue_t pOptions);
            
            /// <summary>
            /// Called when custom signaling has received a message.  When your
            /// signaling channel receives a message, it should save off whatever
            /// routing information was in the envelope into the context object,
            /// and then pass the payload to this function.
            /// </summary>
            /// <remarks>
            /// A few different things can happen next, depending on the message:- If the signal is associated with existing connection, it is dealt
            /// with immediately.  If any replies need to be sent, they will be
            /// dispatched using the ISteamNetworkingConnectionSignaling
            /// associated with the connection.
            /// - If the message represents a connection request (and the request
            /// is not redundant for an existing connection), a new connection
            /// will be created, and ReceivedConnectRequest will be called on your
            /// context object to determine how to proceed.
            /// - Otherwise, the message is for a connection that does not
            /// exist (anymore).  In this case, we *may* call SendRejectionReply
            /// on your context object.In any case, we will not save off pContext or access it after this
            /// function returns.Returns true if the message was parsed and dispatched without anything
            /// unusual or suspicious happening.  Returns false if there was some problem
            /// with the message that prevented ordinary handling.  (Debug output will
            /// usually have more information.)If you expect to be using relayed connections, then you probably want
            /// to call ISteamNetworkingUtils::InitRelayNetworkAccess() when your app initializes
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool ReceivedP2PCustomSignal(IntPtr pMsg, int cbMsg, Networking.ISteamNetworkingSignalingRecvContext pContext);
            
            /// <summary>
            /// Get blob that describes a certificate request.  You can send this to your game coordinator.
            /// Upon entry, *pcbBlob should contain the size of the buffer.  On successful exit, it will
            /// return the number of bytes that were populated.  You can pass pBlob=NULL to query for the required
            /// size.  (512 bytes is a conservative estimate.)
            /// </summary>
            /// <remarks>
            /// Pass this blob to your game coordinator and call SteamDatagram_CreateCert.
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool GetCertificateRequest(ref int pcbBlob, IntPtr pBlob, ref string errMsg);
            
            /// <summary>
            /// Set the certificate.  The certificate blob should be the output of
            /// SteamDatagram_CreateCert.
            /// </summary>
            [return:MarshalAs(UnmanagedType.U1)]
            bool SetCertificate(IntPtr pCertificate, int cbCertificate, ref string errMsg);
            
            /// <summary>
            /// Reset the identity associated with this instance.
            /// Any open connections are closed.  Any previous certificates, etc are discarded.
            /// You can pass a specific identity that you want to use, or you can pass NULL,
            /// in which case the identity will be invalid until you set it using SetCertificate
            /// </summary>
            /// <remarks>
            /// NOTE: This function is not actually supported on Steam!  It is included
            /// for use on other platforms where the active user can sign out and
            /// a new user can sign in.
            /// </remarks>
            void ResetIdentity(in Networking.SteamNetworkingIdentity pIdentity);
            
            /// <summary>
            /// Invoke all callback functions queued for this interface.
            /// See k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, etc
            /// </summary>
            /// <remarks>
            /// You don't need to call this if you are using Steam's callback dispatch
            /// mechanism (SteamAPI_RunCallbacks and SteamGameserver_RunCallbacks).
            /// </remarks>
            void RunCallbacks();
            
            /// <summary>
            /// Begin asynchronous process of allocating a fake IPv4 address that other
            /// peers can use to contact us via P2P.  IP addresses returned by this
            /// function are globally unique for a given appid.
            /// </summary>
            /// <remarks>
            /// nNumPorts is the numbers of ports you wish to reserve.  This is useful
            /// for the same reason that listening on multiple UDP ports is useful for
            /// different types of traffic.  Because these allocations come from a global
            /// namespace, there is a relatively strict limit on the maximum number of
            /// ports you may request.  (At the time of this writing, the limit is 4.)
            /// The Port assignments are *not* guaranteed to have any particular order
            /// or relationship!  Do *not* assume they are contiguous, even though that
            /// may often occur in practice.Returns false if a request was already in progress, true if a new request
            /// was started.  A SteamNetworkingFakeIP_t will be posted when the request
            /// completes.You can call this before you are logged in.  For gameservers, doing so is
            /// *required*, and all places where your public IP appears (such as the server
            /// browser) will be replaced by the FakeIP, and the fake port at index 0.
            /// A failure will not be posted (using SteamNetworkingFakeIP_t) unless we get
            /// logged in, and then the request fails.  Furthermore, it is assumed that
            /// FakeIP allocation is essential for your application to function, and so
            /// failure will not be reported until *several* retries have been attempted,
            /// possibly lasting several minutes.  It is highly recommended to treat failure
            /// as fatal.To communicate using a connection-oriented (TCP-style) API:
            /// - Server creates a listen socket using CreateListenSocketP2PFakeIP
            /// - Client connects using ConnectByIPAddress, passing in the FakeIP address.
            /// - The connection will behave mostly like a P2P connection.  The identities
            /// that appear in SteamNetConnectionInfo_t will be the FakeIP identity until
            /// we know the real identity.  Then it will be the real identity.  If the
            /// SteamNetConnectionInfo_t::m_addrRemote is valid, it will be a real IPv4
            /// address of a NAT-punched connection.  Otherwise, it will not be valid.To communicate using an ad-hoc sendto/recv from (UDP-style) API,
            /// use CreateFakeUDPPort.
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool BeginAsyncRequestFakeIP(int nNumPorts);
            
            /// <summary>
            /// Return info about the FakeIP and port(s) that we have been assigned,
            /// if any.  idxFirstPort is currently reserved and must be zero.
            /// Make sure and check SteamNetworkingFakeIPResult_t::m_eResult
            /// </summary>
            void GetFakeIP(int idxFirstPort, Networking.SteamNetworkingFakeIPResult_t pInfo);
            
            /// <summary>
            /// Create a listen socket that will listen for P2P connections sent
            /// to our FakeIP.  A peer can initiate connections to this listen
            /// socket by calling ConnectByIPAddress.
            /// </summary>
            /// <remarks>
            /// idxFakePort refers to the *index* of the fake port requested,
            /// not the actual port number.  For example, pass 0 to refer to the
            /// first port in the reservation.  You must call this only after calling
            /// BeginAsyncRequestFakeIP.  However, you do not need to wait for the
            /// request to complete before creating the listen socket.
            /// </remarks>
            uint CreateListenSocketP2PFakeIP(int idxFakePort, int nOptions, in Networking.SteamNetworkingConfigValue_t pOptions);
            
            /// <summary>
            /// If the connection was initiated using the "FakeIP" system, then we
            /// we can get an IP address for the remote host.  If the remote host had
            /// a global FakeIP at the time the connection was established, this
            /// function will return that global IP.  Otherwise, a FakeIP that is
            /// unique locally will be allocated from the local FakeIP address space,
            /// and that will be returned.
            /// </summary>
            /// <remarks>
            /// The allocation of local FakeIPs attempts to assign addresses in
            /// a consistent manner.  If multiple connections are made to the
            /// same remote host, they *probably* will return the same FakeIP.
            /// However, since the namespace is limited, this cannot be guaranteed.On failure, returns:
            /// - k_EResultInvalidParam: invalid connection handle
            /// - k_EResultIPNotFound: This connection wasn't made using FakeIP system
            /// </remarks>
            Networking.EResult GetRemoteFakeIPForConnection(uint hConn, ref Networking.SteamNetworkingIPAddr pOutAddr);
            
            /// <summary>
            /// Get an interface that can be used like a UDP port to send/receive
            /// datagrams to a FakeIP address.  This is intended to make it easy
            /// to port existing UDP-based code to take advantage of SDR.
            /// </summary>
            /// <remarks>
            /// idxFakeServerPort refers to the *index* of the port allocated using
            /// BeginAsyncRequestFakeIP and is used to create "server" ports.  You may
            /// call this before the allocation has completed.  However, any attempts
            /// to send packets will fail until the allocation has succeeded.  When
            /// the peer receives packets sent from this interface, the from address
            /// of the packet will be the globally-unique FakeIP.  If you call this
            /// function multiple times and pass the same (nonnegative) fake port index,
            /// the same object will be returned, and this object is not reference counted.To create a "client" port (e.g. the equivalent of an ephemeral UDP port)
            /// pass -1.  In this case, a distinct object will be returned for each call.
            /// When the peer receives packets sent from this interface, the peer will
            /// assign a FakeIP from its own locally-controlled namespace.
            /// </remarks>
            Networking.ISteamNetworkingFakeUDPPort CreateFakeUDPPort(int idxFakeServerPort);
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void PFNPreMinidumpCallback(IntPtr context);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetConnectionStatusChanged(ref Networking.SteamNetConnectionStatusChangedCallback_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetAuthenticationStatusChanged(ref Networking.SteamNetAuthenticationStatus_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamRelayNetworkStatusChanged(Networking.SteamRelayNetworkStatus_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingMessagesSessionRequest(Networking.SteamNetworkingMessagesSessionRequest_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingMessagesSessionFailed(Networking.SteamNetworkingMessagesSessionFailed_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingFakeIPResult(Networking.SteamNetworkingFakeIPResult_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FSteamNetworkingSocketsDebugOutput(Networking.ESteamNetworkingSocketsDebugOutputType nType, [MarshalAs(UnmanagedType.LPStr)] string pszMsg);
        
        public const uint k_uAppIdInvalid = 0;
        
        public const uint k_uDepotIdInvalid = 0;
        
        public const ulong k_uAPICallInvalid = 0;
        
        public const ulong k_ulPartyBeaconIdInvalid = 0;
        
        public const uint k_HAuthTicketInvalid = 0;
        
        public const uint k_unSteamAccountIDMask = 0xFFFFFFFF;
        
        public const uint k_unSteamAccountInstanceMask = 1048575;
        
        /// <summary>
        /// fixed instance for all individual users
        /// </summary>
        public const uint k_unSteamUserDefaultInstance = 1;
        
        public const int k_cchGameExtraInfoMax = 64;
        
        public const uint k_HSteamNetConnection_Invalid = 0;
        
        public const uint k_HSteamListenSocket_Invalid = 0;
        
        public const uint k_HSteamNetPollGroup_Invalid = 0;
        
        /// <summary>
        /// Max length of diagnostic error message
        /// </summary>
        public const int k_cchMaxSteamNetworkingErrMsg = 1024;
        
        /// <summary>
        /// Max length, in bytes (including null terminator) of the reason string
        /// when a connection is closed.
        /// </summary>
        public const int k_cchSteamNetworkingMaxConnectionCloseReason = 128;
        
        /// <summary>
        /// Max length, in bytes (include null terminator) of debug description
        /// of a connection.
        /// </summary>
        public const int k_cchSteamNetworkingMaxConnectionDescription = 128;
        
        /// <summary>
        /// We don't have a certificate for the remote host.
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Unauthenticated = 1;
        
        /// <summary>
        /// Information is being sent out over a wire unencrypted (by this library)
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Unencrypted = 2;
        
        /// <summary>
        /// Internal loopback buffers.  Won't be true for localhost.  (You can check the address to determine that.)  This implies k_nSteamNetworkConnectionInfoFlags_FastLAN
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers = 4;
        
        /// <summary>
        /// The connection is "fast" and "reliable".  Either internal/localhost (check the address to find out), or the peer is on the same LAN.  (Probably.  It's based on the address and the ping time, this is actually hard to determine unambiguously).
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Fast = 8;
        
        /// <summary>
        /// The connection is relayed somehow (SDR or TURN).
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Relayed = 16;
        
        /// <summary>
        /// We're taking advantage of dual-wifi multi-path
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_DualWifi = 32;
        
        /// <summary>
        /// Max size of a single message that we can SEND.
        /// Note: We might be wiling to receive larger messages,
        /// and our peer might, too.
        /// </summary>
        public const int k_cbMaxSteamNetworkingSocketsMessageSizeSend = 512 * 1024;
        
        /// <summary>
        /// Send the message unreliably. Can be lost.  Messages *can* be larger than a
        /// single MTU (UDP packet), but there is no retransmission, so if any piece
        /// of the message is lost, the entire message will be dropped.
        /// </summary>
        /// <remarks>
        /// The sending API does have some knowledge of the underlying connection, so
        /// if there is no NAT-traversal accomplished or there is a recognized adjustment
        /// happening on the connection, the packet will be batched until the connection
        /// is open again.Migration note: This is not exactly the same as k_EP2PSendUnreliable!  You
        /// probably want k_ESteamNetworkingSendType_UnreliableNoNagle
        /// </remarks>
        public const int k_nSteamNetworkingSend_Unreliable = 0;
        
        /// <summary>
        /// Disable Nagle's algorithm.
        /// By default, Nagle's algorithm is applied to all outbound messages.  This means
        /// that the message will NOT be sent immediately, in case further messages are
        /// sent soon after you send this, which can be grouped together.  Any time there
        /// is enough buffered data to fill a packet, the packets will be pushed out immediately,
        /// but partially-full packets not be sent until the Nagle timer expires.  See
        /// ISteamNetworkingSockets::FlushMessagesOnConnection, ISteamNetworkingMessages::FlushMessagesToUser
        /// </summary>
        /// <remarks>
        /// NOTE: Don't just send every message without Nagle because you want packets to get there
        /// quicker.  Make sure you understand the problem that Nagle is solving before disabling it.
        /// If you are sending small messages, often many at the same time, then it is very likely that
        /// it will be more efficient to leave Nagle enabled.  A typical proper use of this flag is
        /// when you are sending what you know will be the last message sent for a while (e.g. the last
        /// in the server simulation tick to a particular client), and you use this flag to flush all
        /// messages.
        /// </remarks>
        public const int k_nSteamNetworkingSend_NoNagle = 1;
        
        /// <summary>
        /// Send a message unreliably, bypassing Nagle's algorithm for this message and any messages
        /// currently pending on the Nagle timer.  This is equivalent to using k_ESteamNetworkingSend_Unreliable
        /// and then immediately flushing the messages using ISteamNetworkingSockets::FlushMessagesOnConnection
        /// or ISteamNetworkingMessages::FlushMessagesToUser.  (But using this flag is more efficient since you
        /// only make one API call.)
        /// </summary>
        public const int k_nSteamNetworkingSend_UnreliableNoNagle = k_nSteamNetworkingSend_Unreliable | k_nSteamNetworkingSend_NoNagle;
        
        /// <summary>
        /// If the message cannot be sent very soon (because the connection is still doing some initial
        /// handshaking, route negotiations, etc), then just drop it.  This is only applicable for unreliable
        /// messages.  Using this flag on reliable messages is invalid.
        /// </summary>
        public const int k_nSteamNetworkingSend_NoDelay = 4;
        
        /// <summary>
        /// Send an unreliable message, but if it cannot be sent relatively quickly, just drop it instead of queuing it.
        /// This is useful for messages that are not useful if they are excessively delayed, such as voice data.
        /// NOTE: The Nagle algorithm is not used, and if the message is not dropped, any messages waiting on the
        /// Nagle timer are immediately flushed.
        /// </summary>
        /// <remarks>
        /// A message will be dropped under the following circumstances:
        /// - the connection is not fully connected.  (E.g. the "Connecting" or "FindingRoute" states)
        /// - there is a sufficiently large number of messages queued up already such that the current message
        /// will not be placed on the wire in the next ~200ms or so.If a message is dropped for these reasons, k_EResultIgnored will be returned.
        /// </remarks>
        public const int k_nSteamNetworkingSend_UnreliableNoDelay = k_nSteamNetworkingSend_Unreliable | k_nSteamNetworkingSend_NoDelay | k_nSteamNetworkingSend_NoNagle;
        
        /// <summary>
        /// Reliable message send. Can send up to k_cbMaxSteamNetworkingSocketsMessageSizeSend bytes in a single message. 
        /// Does fragmentation/re-assembly of messages under the hood, as well as a sliding window for
        /// efficient sends of large chunks of data.
        /// </summary>
        /// <remarks>
        /// The Nagle algorithm is used.  See notes on k_ESteamNetworkingSendType_Unreliable for more details.
        /// See k_ESteamNetworkingSendType_ReliableNoNagle, ISteamNetworkingSockets::FlushMessagesOnConnection,
        /// ISteamNetworkingMessages::FlushMessagesToUserMigration note: This is NOT the same as k_EP2PSendReliable, it's more like k_EP2PSendReliableWithBuffering
        /// </remarks>
        public const int k_nSteamNetworkingSend_Reliable = 8;
        
        /// <summary>
        /// Send a message reliably, but bypass Nagle's algorithm.
        /// </summary>
        /// <remarks>
        /// Migration note: This is equivalent to k_EP2PSendReliable
        /// </remarks>
        public const int k_nSteamNetworkingSend_ReliableNoNagle = k_nSteamNetworkingSend_Reliable | k_nSteamNetworkingSend_NoNagle;
        
        /// <summary>
        /// By default, message sending is queued, and the work of encryption and talking to
        /// the operating system sockets, etc is done on a service thread.  This is usually a
        /// a performance win when messages are sent from the "main thread".  However, if this
        /// flag is set, and data is ready to be sent immediately (either from this message
        /// or earlier queued data), then that work will be done in the current thread, before
        /// the current call returns.  If data is not ready to be sent (due to rate limiting
        /// or Nagle), then this flag has no effect.
        /// </summary>
        /// <remarks>
        /// This is an advanced flag used to control performance at a very low level.  For
        /// most applications running on modern hardware with more than one CPU core, doing
        /// the work of sending on a service thread will yield the best performance.  Only
        /// use this flag if you have a really good reason and understand what you are doing.
        /// Otherwise you will probably just make performance worse.
        /// </remarks>
        public const int k_nSteamNetworkingSend_UseCurrentThread = 16;
        
        /// <summary>
        /// When sending a message using ISteamNetworkingMessages, automatically re-establish
        /// a broken session, without returning k_EResultNoConnection.  Without this flag,
        /// if you attempt to send a message, and the session was proactively closed by the
        /// peer, or an error occurred that disrupted communications, then you must close the
        /// session using ISteamNetworkingMessages::CloseSessionWithUser before attempting to
        /// send another message.  (Or you can simply add this flag and retry.)  In this way,
        /// the disruption cannot go unnoticed, and a more clear order of events can be
        /// ascertained. This is especially important when reliable messages are used, since
        /// if the connection is disrupted, some of those messages will not have been delivered,
        /// and it is in general not possible to know which.  Although a
        /// SteamNetworkingMessagesSessionFailed_t callback will be posted when an error occurs
        /// to notify you that a failure has happened, callbacks are asynchronous, so it is not
        /// possible to tell exactly when it happened.  And because the primary purpose of
        /// ISteamNetworkingMessages is to be like UDP, there is no notification when a peer closes
        /// the session.
        /// </summary>
        /// <remarks>
        /// If you are not using any reliable messages (e.g. you are using ISteamNetworkingMessages
        /// exactly as a transport replacement for UDP-style datagrams only), you may not need to
        /// know when an underlying connection fails, and so you may not need this notification.
        /// </remarks>
        public const int k_nSteamNetworkingSend_AutoRestartBrokenSession = 32;
        
        /// <summary>
        /// Max possible length of a ping location, in string format.  This is
        /// an extremely conservative worst case value which leaves room for future
        /// syntax enhancements.  Most strings in practice are a lot shorter.
        /// If you are storing many of these, you will very likely benefit from
        /// using dynamic memory.
        /// </summary>
        public const int k_cchMaxSteamNetworkingPingLocationString = 1024;
        
        /// <summary>
        /// Special values that are returned by some functions that return a ping.
        /// </summary>
        public const int k_nSteamNetworkingPing_Failed = -1;
        
        public const int k_nSteamNetworkingPing_Unknown = -2;
        
        /// <summary>
        /// Special value - use user defaults
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default = -1;
        
        /// <summary>
        /// Do not do any ICE work at all or share any IP addresses with peer
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable = 0;
        
        /// <summary>
        /// Relayed connection via TURN server.
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay = 1;
        
        /// <summary>
        /// host addresses that appear to be link-local or RFC1918 addresses
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private = 2;
        
        /// <summary>
        /// STUN reflexive addresses, or host address that isn't a "private" address
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public = 4;
        
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All = 0x7fffffff;
        
        /// <summary>
        /// The POPID "dev" is used in non-production environments for testing.
        /// </summary>
        public const uint k_SteamDatagramPOPID_dev = ((uint)'d' << 16) | ((uint)'e' << 8) | (uint)'v';
        
        /// <summary>
        /// Unpack integer to string representation, including terminating '
        /// \
        /// 0'
        /// </summary>
        /// <remarks>
        /// See also SteamNetworkingPOPIDRender
        /// </remarks>
        [DllImport(Library, EntryPoint = "GetSteamNetworkingLocationPOPStringFromID", CallingConvention = CallingConvention.Cdecl)]
        public static extern void GetSteamNetworkingLocationPOPStringFromID(uint id, ref sbyte[] szCode);
        
        [DllImport(Library, EntryPoint = "SteamNetworkingSockets_LibV11", CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Networking.ISteamNetworkingSockets SteamNetworkingSockets_LibV11();
        
        /// <summary>
        /// Initialize the library.  Optionally, you can set an initial identity for the default
        /// interface that is returned by SteamNetworkingSockets().
        /// </summary>
        /// <remarks>
        /// On failure, false is returned, and a non-localized diagnostic message is returned.
        /// </remarks>
        [DllImport(Library, EntryPoint = "GameNetworkingSockets_Init", CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.U1)]
        public static extern bool GameNetworkingSockets_Init(in Networking.SteamNetworkingIdentity pIdentity, ref string errMsg);
        
        /// <summary>
        /// Close all connections and listen sockets and free all resources
        /// </summary>
        [DllImport(Library, EntryPoint = "GameNetworkingSockets_Kill", CallingConvention = CallingConvention.Cdecl)]
        public static extern void GameNetworkingSockets_Kill();
        
        /// <summary>
        /// Custom memory allocation methods.  If you call this, you MUST call it exactly once,
        /// before calling any other API function.  *Most* allocations will pass through these,
        /// especially all allocations that are per-connection.  A few allocations
        /// might still go to the default CRT malloc and operator new.
        /// To use this, you must compile the library with STEAMNETWORKINGSOCKETS_ENABLE_MEM_OVERRIDE
        /// </summary>
        [DllImport(Library, EntryPoint = "SteamNetworkingSockets_SetCustomMemoryAllocator", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingSockets_SetCustomMemoryAllocator(Networking.pfn_malloc_delegate pfn_malloc, Networking.pfn_free_delegate pfn_free, Networking.pfn_realloc_delegate pfn_realloc);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr pfn_malloc_delegate(Networking.pfn_malloc_delegate pfn_malloc, Networking.pfn_free_delegate pfn_free, Networking.pfn_realloc_delegate pfn_realloc);
        
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void pfn_free_delegate(IntPtr p);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr pfn_realloc_delegate(IntPtr p, ulong s);
        
        
        /// <summary>
        /// Statistics about the global lock.
        /// </summary>
        [DllImport(Library, EntryPoint = "SteamNetworkingSockets_SetLockWaitWarningThreshold", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingSockets_SetLockWaitWarningThreshold(long usecThreshold);
        
        [DllImport(Library, EntryPoint = "SteamNetworkingSockets_SetLockAcquiredCallback", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingSockets_SetLockAcquiredCallback(Networking.callback_delegate callback);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void callback_delegatee(Networking.callback_delegate callback);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void callback_delegate([MarshalAs(UnmanagedType.LPStr)] string tags, long usecWaited);

        public const string Library = "GameNetworkingSockets";

        [DllImport(Library, EntryPoint = "SteamNetworkingSockets_SetLockHeldCallback", CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingSockets_SetLockHeldCallback(Networking.callback_delegate callback);
        
    }
}
