//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Steam
{
    using System.Runtime.InteropServices;
    
    public static partial class Networking
    {
        public enum ESteamIPType : int
        {
            Esteamiptypeipv4 = unchecked((int)0),
            
            Esteamiptypeipv6 = unchecked((int)1),
        }
        
        public const Networking.ESteamIPType Esteamiptypeipv4 = ESteamIPType.Esteamiptypeipv4;
        
        public const Networking.ESteamIPType Esteamiptypeipv6 = ESteamIPType.Esteamiptypeipv6;
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamIPAddress_t
        {
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamIPAddress_tunion
            {
                /// <summary>
                /// Host order
                /// </summary>
                [FieldOffset(0)]
                public uint m_unIPv4;
                
                /// <summary>
                /// Network order! Same as inaddr_in6.  (0011:2233:4455:6677:8899:aabb:ccdd:eeff)
                /// </summary>
                [FieldOffset(0)]
                public fixed byte m_rgubIPv6[16];
                
                /// <summary>
                /// big endian
                /// </summary>
                [FieldOffset(0)]
                public fixed ulong m_ipv6Qword[2];
            }
            
            public Networking.ESteamIPType m_eType;
        }
        
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct intp : IEquatable<intp>
        {
            public intp(long value) => this.Value = value;
            
            public readonly long Value;
            
            public bool Equals(intp other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is intp other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator long(intp from) => from.Value;
            
            public static implicit operator intp(long from) => new intp(from);
            
            public static bool operator ==(intp left, intp right) => left.Equals(right);
            
            public static bool operator !=(intp left, intp right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct uintp : IEquatable<uintp>
        {
            public uintp(ulong value) => this.Value = value;
            
            public readonly ulong Value;
            
            public bool Equals(uintp other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is uintp other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong(uintp from) => from.Value;
            
            public static implicit operator uintp(ulong from) => new uintp(from);
            
            public static bool operator ==(uintp left, uintp right) => left.Equals(right);
            
            public static bool operator !=(uintp left, uintp right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct AppId_t : IEquatable<AppId_t>
        {
            public AppId_t(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(AppId_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is AppId_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(AppId_t from) => from.Value;
            
            public static implicit operator AppId_t(uint from) => new AppId_t(from);
            
            public static bool operator ==(AppId_t left, AppId_t right) => left.Equals(right);
            
            public static bool operator !=(AppId_t left, AppId_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// AppIds and DepotIDs also presently share the same namespace
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct DepotId_t : IEquatable<DepotId_t>
        {
            public DepotId_t(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(DepotId_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is DepotId_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(DepotId_t from) => from.Value;
            
            public static implicit operator DepotId_t(uint from) => new DepotId_t(from);
            
            public static bool operator ==(DepotId_t left, DepotId_t right) => left.Equals(right);
            
            public static bool operator !=(DepotId_t left, DepotId_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// RTime32.  Seconds elapsed since Jan 1 1970, i.e. unix timestamp.
        /// It's the same as time_t, but it is always 32-bit and unsigned.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct RTime32 : IEquatable<RTime32>
        {
            public RTime32(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(RTime32 other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is RTime32 other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(RTime32 from) => from.Value;
            
            public static implicit operator RTime32(uint from) => new RTime32(from);
            
            public static bool operator ==(RTime32 left, RTime32 right) => left.Equals(right);
            
            public static bool operator !=(RTime32 left, RTime32 right) => !left.Equals(right);
        }
        
        /// <summary>
        /// handle to a Steam API call
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamAPICall_t : IEquatable<SteamAPICall_t>
        {
            public SteamAPICall_t(ulong value) => this.Value = value;
            
            public readonly ulong Value;
            
            public bool Equals(SteamAPICall_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is SteamAPICall_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong(SteamAPICall_t from) => from.Value;
            
            public static implicit operator SteamAPICall_t(ulong from) => new SteamAPICall_t(from);
            
            public static bool operator ==(SteamAPICall_t left, SteamAPICall_t right) => left.Equals(right);
            
            public static bool operator !=(SteamAPICall_t left, SteamAPICall_t right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct AccountID_t : IEquatable<AccountID_t>
        {
            public AccountID_t(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(AccountID_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is AccountID_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(AccountID_t from) => from.Value;
            
            public static implicit operator AccountID_t(uint from) => new AccountID_t(from);
            
            public static bool operator ==(AccountID_t left, AccountID_t right) => left.Equals(right);
            
            public static bool operator !=(AccountID_t left, AccountID_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Party Beacon ID
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct PartyBeaconID_t : IEquatable<PartyBeaconID_t>
        {
            public PartyBeaconID_t(ulong value) => this.Value = value;
            
            public readonly ulong Value;
            
            public bool Equals(PartyBeaconID_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is PartyBeaconID_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong(PartyBeaconID_t from) => from.Value;
            
            public static implicit operator PartyBeaconID_t(ulong from) => new PartyBeaconID_t(from);
            
            public static bool operator ==(PartyBeaconID_t left, PartyBeaconID_t right) => left.Equals(right);
            
            public static bool operator !=(PartyBeaconID_t left, PartyBeaconID_t right) => !left.Equals(right);
        }
        
    }
}
