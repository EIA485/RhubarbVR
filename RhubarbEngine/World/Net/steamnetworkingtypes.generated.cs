//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Steam
{
    using System.Runtime.InteropServices;
    
    public static partial class Networking
    {
        /// <summary>
        /// Different methods of describing the identity of a network host
        /// </summary>
        public enum ESteamNetworkingIdentityType : int
        {
            /// <summary>
            /// Dummy/empty/invalid.
            /// Please note that if we parse a string that we don't recognize
            /// but that appears reasonable, we will NOT use this type.  Instead
            /// we'll use k_ESteamNetworkingIdentityType_UnknownType.
            /// </summary>
            EsteamnetworkingidentitytypeInvalid = unchecked((int)0),
            
            /// <summary>
            /// 64-bit CSteamID
            /// </summary>
            EsteamnetworkingidentitytypeSteamid = unchecked((int)16),
            
            /// <summary>
            /// Use their IP address (and port) as their "identity".
            /// These types of identities are always unauthenticated.
            /// They are useful for porting plain sockets code, and other
            /// situations where you don't care about authentication.  In this
            /// case, the local identity will be "localhost",
            /// and the remote address will be their network address.
            /// </summary>
            /// <remarks>
            /// We use the same type for either IPv4 or IPv6, and
            /// the address is always store as IPv6.  We use IPv4
            /// mapped addresses to handle IPv4.
            /// </remarks>
            EsteamnetworkingidentitytypeIpaddress = unchecked((int)1),
            
            /// <summary>
            /// Generic string/binary blobs.  It's up to your app to interpret this.
            /// This library can tell you if the remote host presented a certificate
            /// signed by somebody you have chosen to trust, with this identity on it.
            /// It's up to you to ultimately decide what this identity means.
            /// </summary>
            EsteamnetworkingidentitytypeGenericstring = unchecked((int)2),
            
            /// <summary>
            /// Generic string/binary blobs.  It's up to your app to interpret this.
            /// This library can tell you if the remote host presented a certificate
            /// signed by somebody you have chosen to trust, with this identity on it.
            /// It's up to you to ultimately decide what this identity means.
            /// </summary>
            EsteamnetworkingidentitytypeGenericbytes = unchecked((int)3),
            
            /// <summary>
            /// This identity type is used when we parse a string that looks like is a
            /// valid identity, just of a kind that we don't recognize.  In this case, we
            /// can often still communicate with the peer!  Allowing such identities
            /// for types we do not recognize useful is very useful for forward
            /// compatibility.
            /// </summary>
            EsteamnetworkingidentitytypeUnknowntype = unchecked((int)4),
            
            /// <summary>
            /// Make sure this enum is stored in an int.
            /// </summary>
            EsteamnetworkingidentitytypeForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Dummy/empty/invalid.
        /// Please note that if we parse a string that we don't recognize
        /// but that appears reasonable, we will NOT use this type.  Instead
        /// we'll use k_ESteamNetworkingIdentityType_UnknownType.
        /// </summary>
        public const Networking.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeInvalid = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeInvalid;
        
        /// <summary>
        /// 64-bit CSteamID
        /// </summary>
        public const Networking.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeSteamid = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeSteamid;
        
        /// <summary>
        /// Use their IP address (and port) as their "identity".
        /// These types of identities are always unauthenticated.
        /// They are useful for porting plain sockets code, and other
        /// situations where you don't care about authentication.  In this
        /// case, the local identity will be "localhost",
        /// and the remote address will be their network address.
        /// </summary>
        /// <remarks>
        /// We use the same type for either IPv4 or IPv6, and
        /// the address is always store as IPv6.  We use IPv4
        /// mapped addresses to handle IPv4.
        /// </remarks>
        public const Networking.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeIpaddress = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeIpaddress;
        
        /// <summary>
        /// Generic string/binary blobs.  It's up to your app to interpret this.
        /// This library can tell you if the remote host presented a certificate
        /// signed by somebody you have chosen to trust, with this identity on it.
        /// It's up to you to ultimately decide what this identity means.
        /// </summary>
        public const Networking.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeGenericstring = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeGenericstring;
        
        /// <summary>
        /// Generic string/binary blobs.  It's up to your app to interpret this.
        /// This library can tell you if the remote host presented a certificate
        /// signed by somebody you have chosen to trust, with this identity on it.
        /// It's up to you to ultimately decide what this identity means.
        /// </summary>
        public const Networking.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeGenericbytes = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeGenericbytes;
        
        /// <summary>
        /// This identity type is used when we parse a string that looks like is a
        /// valid identity, just of a kind that we don't recognize.  In this case, we
        /// can often still communicate with the peer!  Allowing such identities
        /// for types we do not recognize useful is very useful for forward
        /// compatibility.
        /// </summary>
        public const Networking.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeUnknowntype = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeUnknowntype;
        
        /// <summary>
        /// Make sure this enum is stored in an int.
        /// </summary>
        public const Networking.ESteamNetworkingIdentityType EsteamnetworkingidentitytypeForce32bit = ESteamNetworkingIdentityType.EsteamnetworkingidentitytypeForce32bit;
        
        /// <summary>
        /// "Fake IPs" are assigned to hosts, to make it easier to interface with
        /// older code that assumed all hosts will have an IPv4 address
        /// </summary>
        public enum ESteamNetworkingFakeIPType : int
        {
            /// <summary>
            /// Error, argument was not even an IP address, etc.
            /// </summary>
            EsteamnetworkingfakeiptypeInvalid,
            
            /// <summary>
            /// Argument was a valid IP, but was not from the reserved "fake" range
            /// </summary>
            EsteamnetworkingfakeiptypeNotfake,
            
            /// <summary>
            /// Globally unique (for a given app) IPv4 address.  Address space managed by Steam
            /// </summary>
            EsteamnetworkingfakeiptypeGlobalipv4,
            
            /// <summary>
            /// Locally unique IPv4 address.  Address space managed by the local process.  For internal use only; should not be shared!
            /// </summary>
            EsteamnetworkingfakeiptypeLocalipv4,
            
            EsteamnetworkingfakeiptypeForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Error, argument was not even an IP address, etc.
        /// </summary>
        public const Networking.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeInvalid = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeInvalid;
        
        /// <summary>
        /// Argument was a valid IP, but was not from the reserved "fake" range
        /// </summary>
        public const Networking.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeNotfake = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeNotfake;
        
        /// <summary>
        /// Globally unique (for a given app) IPv4 address.  Address space managed by Steam
        /// </summary>
        public const Networking.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeGlobalipv4 = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeGlobalipv4;
        
        /// <summary>
        /// Locally unique IPv4 address.  Address space managed by the local process.  For internal use only; should not be shared!
        /// </summary>
        public const Networking.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeLocalipv4 = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeLocalipv4;
        
        public const Networking.ESteamNetworkingFakeIPType EsteamnetworkingfakeiptypeForce32bit = ESteamNetworkingFakeIPType.EsteamnetworkingfakeiptypeForce32bit;
        
        /// <summary>
        /// High level connection status
        /// </summary>
        public enum ESteamNetworkingConnectionState : int
        {
            /// <summary>
            /// Dummy value used to indicate an error condition in the API.
            /// Specified connection doesn't exist or has already been closed.
            /// </summary>
            EsteamnetworkingconnectionstateNone = unchecked((int)0),
            
            /// <summary>
            /// We are trying to establish whether peers can talk to each other,
            /// whether they WANT to talk to each other, perform basic auth,
            /// and exchange crypt keys.
            /// </summary>
            /// <remarks>
            /// - For connections on the "client" side (initiated locally):
            /// We're in the process of trying to establish a connection.
            /// Depending on the connection type, we might not know who they are.
            /// Note that it is not possible to tell if we are waiting on the
            /// network to complete handshake packets, or for the application layer
            /// to accept the connection.- For connections on the "server" side (accepted through listen socket):
            /// We have completed some basic handshake and the client has presented
            /// some proof of identity.  The connection is ready to be accepted
            /// using AcceptConnection().In either case, any unreliable packets sent now are almost certain
            /// to be dropped.  Attempts to receive packets are guaranteed to fail.
            /// You may send messages if the send mode allows for them to be queued.
            /// but if you close the connection before the connection is actually
            /// established, any queued messages will be discarded immediately.
            /// (We will not attempt to flush the queue and confirm delivery to the
            /// remote host, which ordinarily happens when a connection is closed.)
            /// </remarks>
            EsteamnetworkingconnectionstateConnecting = unchecked((int)1),
            
            /// <summary>
            /// Some connection types use a back channel or trusted 3rd party
            /// for earliest communication.  If the server accepts the connection,
            /// then these connections switch into the rendezvous state.  During this
            /// state, we still have not yet established an end-to-end route (through
            /// the relay network), and so if you send any messages unreliable, they
            /// are going to be discarded.
            /// </summary>
            EsteamnetworkingconnectionstateFindingroute = unchecked((int)2),
            
            /// <summary>
            /// We've received communications from our peer (and we know
            /// who they are) and are all good.  If you close the connection now,
            /// we will make our best effort to flush out any reliable sent data that
            /// has not been acknowledged by the peer.  (But note that this happens
            /// from within the application process, so unlike a TCP connection, you are
            /// not totally handing it off to the operating system to deal with it.)
            /// </summary>
            EsteamnetworkingconnectionstateConnected = unchecked((int)3),
            
            /// <summary>
            /// Connection has been closed by our peer, but not closed locally.
            /// The connection still exists from an API perspective.  You must close the
            /// handle to free up resources.  If there are any messages in the inbound queue,
            /// you may retrieve them.  Otherwise, nothing may be done with the connection
            /// except to close it.
            /// </summary>
            /// <remarks>
            /// This stats is similar to CLOSE_WAIT in the TCP state machine.
            /// </remarks>
            EsteamnetworkingconnectionstateClosedbypeer = unchecked((int)4),
            
            /// <summary>
            /// A disruption in the connection has been detected locally.  (E.g. timeout,
            /// local internet connection disrupted, etc.)
            /// </summary>
            /// <remarks>
            /// The connection still exists from an API perspective.  You must close the
            /// handle to free up resources.Attempts to send further messages will fail.  Any remaining received messages
            /// in the queue are available.
            /// </remarks>
            EsteamnetworkingconnectionstateProblemdetectedlocally = unchecked((int)5),
            
            /// <summary>
            /// We've disconnected on our side, and from an API perspective the connection is closed.
            /// No more data may be sent or received.  All reliable data has been flushed, or else
            /// we've given up and discarded it.  We do not yet know for sure that the peer knows
            /// the connection has been closed, however, so we're just hanging around so that if we do
            /// get a packet from them, we can send them the appropriate packets so that they can
            /// know why the connection was closed (and not have to rely on a timeout, which makes
            /// it appear as if something is wrong).
            /// </summary>
            EsteamnetworkingconnectionstateFinwait = unchecked((int)-1),
            
            /// <summary>
            /// We've disconnected on our side, and from an API perspective the connection is closed.
            /// No more data may be sent or received.  From a network perspective, however, on the wire,
            /// we have not yet given any indication to the peer that the connection is closed.
            /// We are in the process of flushing out the last bit of reliable data.  Once that is done,
            /// we will inform the peer that the connection has been closed, and transition to the
            /// FinWait state.
            /// </summary>
            /// <remarks>
            /// Note that no indication is given to the remote host that we have closed the connection,
            /// until the data has been flushed.  If the remote host attempts to send us data, we will
            /// do whatever is necessary to keep the connection alive until it can be closed properly.
            /// But in fact the data will be discarded, since there is no way for the application to
            /// read it back.  Typically this is not a problem, as application protocols that utilize
            /// the lingering functionality are designed for the remote host to wait for the response
            /// before sending any more data.
            /// </remarks>
            EsteamnetworkingconnectionstateLinger = unchecked((int)-2),
            
            /// <summary>
            /// Connection is completely inactive and ready to be destroyed
            /// </summary>
            EsteamnetworkingconnectionstateDead = unchecked((int)-3),
            
            /// <summary>
            /// Connection is completely inactive and ready to be destroyed
            /// </summary>
            EsteamnetworkingconnectionstateForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Dummy value used to indicate an error condition in the API.
        /// Specified connection doesn't exist or has already been closed.
        /// </summary>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateNone = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateNone;
        
        /// <summary>
        /// We are trying to establish whether peers can talk to each other,
        /// whether they WANT to talk to each other, perform basic auth,
        /// and exchange crypt keys.
        /// </summary>
        /// <remarks>
        /// - For connections on the "client" side (initiated locally):
        /// We're in the process of trying to establish a connection.
        /// Depending on the connection type, we might not know who they are.
        /// Note that it is not possible to tell if we are waiting on the
        /// network to complete handshake packets, or for the application layer
        /// to accept the connection.- For connections on the "server" side (accepted through listen socket):
        /// We have completed some basic handshake and the client has presented
        /// some proof of identity.  The connection is ready to be accepted
        /// using AcceptConnection().In either case, any unreliable packets sent now are almost certain
        /// to be dropped.  Attempts to receive packets are guaranteed to fail.
        /// You may send messages if the send mode allows for them to be queued.
        /// but if you close the connection before the connection is actually
        /// established, any queued messages will be discarded immediately.
        /// (We will not attempt to flush the queue and confirm delivery to the
        /// remote host, which ordinarily happens when a connection is closed.)
        /// </remarks>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateConnecting = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateConnecting;
        
        /// <summary>
        /// Some connection types use a back channel or trusted 3rd party
        /// for earliest communication.  If the server accepts the connection,
        /// then these connections switch into the rendezvous state.  During this
        /// state, we still have not yet established an end-to-end route (through
        /// the relay network), and so if you send any messages unreliable, they
        /// are going to be discarded.
        /// </summary>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateFindingroute = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateFindingroute;
        
        /// <summary>
        /// We've received communications from our peer (and we know
        /// who they are) and are all good.  If you close the connection now,
        /// we will make our best effort to flush out any reliable sent data that
        /// has not been acknowledged by the peer.  (But note that this happens
        /// from within the application process, so unlike a TCP connection, you are
        /// not totally handing it off to the operating system to deal with it.)
        /// </summary>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateConnected = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateConnected;
        
        /// <summary>
        /// Connection has been closed by our peer, but not closed locally.
        /// The connection still exists from an API perspective.  You must close the
        /// handle to free up resources.  If there are any messages in the inbound queue,
        /// you may retrieve them.  Otherwise, nothing may be done with the connection
        /// except to close it.
        /// </summary>
        /// <remarks>
        /// This stats is similar to CLOSE_WAIT in the TCP state machine.
        /// </remarks>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateClosedbypeer = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateClosedbypeer;
        
        /// <summary>
        /// A disruption in the connection has been detected locally.  (E.g. timeout,
        /// local internet connection disrupted, etc.)
        /// </summary>
        /// <remarks>
        /// The connection still exists from an API perspective.  You must close the
        /// handle to free up resources.Attempts to send further messages will fail.  Any remaining received messages
        /// in the queue are available.
        /// </remarks>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateProblemdetectedlocally = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateProblemdetectedlocally;
        
        /// <summary>
        /// We've disconnected on our side, and from an API perspective the connection is closed.
        /// No more data may be sent or received.  All reliable data has been flushed, or else
        /// we've given up and discarded it.  We do not yet know for sure that the peer knows
        /// the connection has been closed, however, so we're just hanging around so that if we do
        /// get a packet from them, we can send them the appropriate packets so that they can
        /// know why the connection was closed (and not have to rely on a timeout, which makes
        /// it appear as if something is wrong).
        /// </summary>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateFinwait = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateFinwait;
        
        /// <summary>
        /// We've disconnected on our side, and from an API perspective the connection is closed.
        /// No more data may be sent or received.  From a network perspective, however, on the wire,
        /// we have not yet given any indication to the peer that the connection is closed.
        /// We are in the process of flushing out the last bit of reliable data.  Once that is done,
        /// we will inform the peer that the connection has been closed, and transition to the
        /// FinWait state.
        /// </summary>
        /// <remarks>
        /// Note that no indication is given to the remote host that we have closed the connection,
        /// until the data has been flushed.  If the remote host attempts to send us data, we will
        /// do whatever is necessary to keep the connection alive until it can be closed properly.
        /// But in fact the data will be discarded, since there is no way for the application to
        /// read it back.  Typically this is not a problem, as application protocols that utilize
        /// the lingering functionality are designed for the remote host to wait for the response
        /// before sending any more data.
        /// </remarks>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateLinger = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateLinger;
        
        /// <summary>
        /// Connection is completely inactive and ready to be destroyed
        /// </summary>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateDead = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateDead;
        
        /// <summary>
        /// Connection is completely inactive and ready to be destroyed
        /// </summary>
        public const Networking.ESteamNetworkingConnectionState EsteamnetworkingconnectionstateForce32bit = ESteamNetworkingConnectionState.EsteamnetworkingconnectionstateForce32bit;
        
        /// <summary>
        /// Describe the status of a particular network resource
        /// </summary>
        public enum ESteamNetworkingAvailability : int
        {
            /// <summary>
            /// A dependent resource is missing, so this service is unavailable.  (E.g. we cannot talk to routers because Internet is down or we don't have the network config.)
            /// </summary>
            EsteamnetworkingavailabilityCannottry = unchecked((int)-102),
            
            /// <summary>
            /// We have tried for enough time that we would expect to have been successful by now.  We have never been successful
            /// </summary>
            EsteamnetworkingavailabilityFailed = unchecked((int)-101),
            
            /// <summary>
            /// We tried and were successful at one time, but now it looks like we have a problem
            /// </summary>
            EsteamnetworkingavailabilityPreviously = unchecked((int)-100),
            
            /// <summary>
            /// We previously failed and are currently retrying
            /// </summary>
            EsteamnetworkingavailabilityRetrying = unchecked((int)-10),
            
            /// <summary>
            /// We don't know because we haven't ever checked/tried
            /// </summary>
            EsteamnetworkingavailabilityNevertried = unchecked((int)1),
            
            /// <summary>
            /// We're waiting on a dependent resource to be acquired.  (E.g. we cannot obtain a cert until we are logged into Steam.  We cannot measure latency to relays until we have the network config.)
            /// </summary>
            EsteamnetworkingavailabilityWaiting = unchecked((int)2),
            
            /// <summary>
            /// We're actively trying now, but are not yet successful.
            /// </summary>
            EsteamnetworkingavailabilityAttempting = unchecked((int)3),
            
            /// <summary>
            /// Resource is online/available
            /// </summary>
            EsteamnetworkingavailabilityCurrent = unchecked((int)100),
            
            /// <summary>
            /// Internal dummy/sentinel, or value is not applicable in this context
            /// </summary>
            EsteamnetworkingavailabilityUnknown = unchecked((int)0),
            
            EsteamnetworkingavailabilityForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// A dependent resource is missing, so this service is unavailable.  (E.g. we cannot talk to routers because Internet is down or we don't have the network config.)
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityCannottry = ESteamNetworkingAvailability.EsteamnetworkingavailabilityCannottry;
        
        /// <summary>
        /// We have tried for enough time that we would expect to have been successful by now.  We have never been successful
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityFailed = ESteamNetworkingAvailability.EsteamnetworkingavailabilityFailed;
        
        /// <summary>
        /// We tried and were successful at one time, but now it looks like we have a problem
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityPreviously = ESteamNetworkingAvailability.EsteamnetworkingavailabilityPreviously;
        
        /// <summary>
        /// We previously failed and are currently retrying
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityRetrying = ESteamNetworkingAvailability.EsteamnetworkingavailabilityRetrying;
        
        /// <summary>
        /// We don't know because we haven't ever checked/tried
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityNevertried = ESteamNetworkingAvailability.EsteamnetworkingavailabilityNevertried;
        
        /// <summary>
        /// We're waiting on a dependent resource to be acquired.  (E.g. we cannot obtain a cert until we are logged into Steam.  We cannot measure latency to relays until we have the network config.)
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityWaiting = ESteamNetworkingAvailability.EsteamnetworkingavailabilityWaiting;
        
        /// <summary>
        /// We're actively trying now, but are not yet successful.
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityAttempting = ESteamNetworkingAvailability.EsteamnetworkingavailabilityAttempting;
        
        /// <summary>
        /// Resource is online/available
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityCurrent = ESteamNetworkingAvailability.EsteamnetworkingavailabilityCurrent;
        
        /// <summary>
        /// Internal dummy/sentinel, or value is not applicable in this context
        /// </summary>
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityUnknown = ESteamNetworkingAvailability.EsteamnetworkingavailabilityUnknown;
        
        public const Networking.ESteamNetworkingAvailability EsteamnetworkingavailabilityForce32bit = ESteamNetworkingAvailability.EsteamnetworkingavailabilityForce32bit;
        
        /// <summary>
        /// Enumerate various causes of connection termination.  These are designed to work similar
        /// to HTTP error codes: the numeric range gives you a rough classification as to the source
        /// of the problem.
        /// </summary>
        public enum ESteamNetConnectionEnd : int
        {
            /// <summary>
            /// Invalid/sentinel value
            /// </summary>
            EsteamnetconnectionendInvalid = unchecked((int)0),
            
            /// <summary>
            /// 1xxx: Application ended the connection in a "usual" manner.
            /// E.g.: user intentionally disconnected from the server,
            /// gameplay ended normally, etc
            /// </summary>
            EsteamnetconnectionendAppMin = unchecked((int)1000),
            
            /// <summary>
            /// 1xxx: Application ended the connection in a "usual" manner.
            /// E.g.: user intentionally disconnected from the server,
            /// gameplay ended normally, etc
            /// </summary>
            EsteamnetconnectionendAppGeneric = unchecked((int)1000),
            
            /// <summary>
            /// Use codes in this range for "normal" disconnection
            /// </summary>
            EsteamnetconnectionendAppMax = unchecked((int)1999),
            
            /// <summary>
            /// 2xxx: Application ended the connection in some sort of exceptional
            /// or unusual manner that might indicate a bug or configuration
            /// issue.
            /// </summary>
            EsteamnetconnectionendAppexceptionMin = unchecked((int)2000),
            
            /// <summary>
            /// 2xxx: Application ended the connection in some sort of exceptional
            /// or unusual manner that might indicate a bug or configuration
            /// issue.
            /// </summary>
            EsteamnetconnectionendAppexceptionGeneric = unchecked((int)2000),
            
            /// <summary>
            /// Use codes in this range for "unusual" disconnection
            /// </summary>
            EsteamnetconnectionendAppexceptionMax = unchecked((int)2999),
            
            /// <summary>
            /// 3xxx: Connection failed or ended because of problem with the
            /// local host or their connection to the Internet.
            /// </summary>
            EsteamnetconnectionendLocalMin = unchecked((int)3000),
            
            /// <summary>
            /// You cannot do what you want to do because you're running in offline mode.
            /// </summary>
            EsteamnetconnectionendLocalOfflinemode = unchecked((int)3001),
            
            /// <summary>
            /// We're having trouble contacting many (perhaps all) relays.
            /// Since it's unlikely that they all went offline at once, the best
            /// explanation is that we have a problem on our end.  Note that we don't
            /// bother distinguishing between "many" and "all", because in practice,
            /// it takes time to detect a connection problem, and by the time
            /// the connection has timed out, we might not have been able to
            /// actively probe all of the relay clusters, even if we were able to
            /// contact them at one time.  So this code just means that:
            /// </summary>
            /// <remarks>
            /// * We don't have any recent successful communication with any relay.
            /// * We have evidence of recent failures to communicate with multiple relays.
            /// </remarks>
            EsteamnetconnectionendLocalManyrelayconnectivity = unchecked((int)3002),
            
            /// <summary>
            /// A hosted server is having trouble talking to the relay
            /// that the client was using, so the problem is most likely
            /// on our end
            /// </summary>
            EsteamnetconnectionendLocalHostedserverprimaryrelay = unchecked((int)3003),
            
            /// <summary>
            /// We're not able to get the SDR network config.  This is
            /// *almost* always a local issue, since the network config
            /// comes from the CDN, which is pretty darn reliable.
            /// </summary>
            EsteamnetconnectionendLocalNetworkconfig = unchecked((int)3004),
            
            /// <summary>
            /// Steam rejected our request because we don't have rights
            /// to do this.
            /// </summary>
            EsteamnetconnectionendLocalRights = unchecked((int)3005),
            
            /// <summary>
            /// ICE P2P rendezvous failed because we were not able to
            /// determine our "public" address (e.g. reflexive address via STUN)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendLocalP2pIceNopublicaddresses = unchecked((int)3006),
            
            /// <summary>
            /// ICE P2P rendezvous failed because we were not able to
            /// determine our "public" address (e.g. reflexive address via STUN)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendLocalMax = unchecked((int)3999),
            
            /// <summary>
            /// 4xxx: Connection failed or ended, and it appears that the
            /// cause does NOT have to do with the local host or their
            /// connection to the Internet.  It could be caused by the
            /// remote host, or it could be somewhere in between.
            /// </summary>
            EsteamnetconnectionendRemoteMin = unchecked((int)4000),
            
            /// <summary>
            /// The connection was lost, and as far as we can tell our connection
            /// to relevant services (relays) has not been disrupted.  This doesn't
            /// mean that the problem is "their fault", it just means that it doesn't
            /// appear that we are having network issues on our end.
            /// </summary>
            EsteamnetconnectionendRemoteTimeout = unchecked((int)4001),
            
            /// <summary>
            /// Something was invalid with the cert or crypt handshake
            /// info you gave me, I don't understand or like your key types,
            /// etc.
            /// </summary>
            EsteamnetconnectionendRemoteBadcrypt = unchecked((int)4002),
            
            /// <summary>
            /// You presented me with a cert that was I was able to parse
            /// and *technically* we could use encrypted communication.
            /// But there was a problem that prevents me from checking your identity
            /// or ensuring that somebody int he middle can't observe our communication.
            /// E.g.: - the CA key was missing (and I don't accept unsigned certs)
            /// - The CA key isn't one that I trust,
            /// - The cert doesn't was appropriately restricted by app, user, time, data center, etc.
            /// - The cert wasn't issued to you.
            /// - etc
            /// </summary>
            EsteamnetconnectionendRemoteBadcert = unchecked((int)4003),
            
            /// <summary>
            /// Something wrong with the protocol version you are using.
            /// (Probably the code you are running is too old.)
            /// </summary>
            EsteamnetconnectionendRemoteBadprotocolversion = unchecked((int)4006),
            
            /// <summary>
            /// NAT punch failed failed because we never received any public
            /// addresses from the remote host.  (But we did receive some
            /// signals form them.)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendRemoteP2pIceNopublicaddresses = unchecked((int)4007),
            
            /// <summary>
            /// NAT punch failed failed because we never received any public
            /// addresses from the remote host.  (But we did receive some
            /// signals form them.)
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendRemoteMax = unchecked((int)4999),
            
            /// <summary>
            /// 5xxx: Connection failed for some other reason.
            /// </summary>
            EsteamnetconnectionendMiscMin = unchecked((int)5000),
            
            /// <summary>
            /// A failure that isn't necessarily the result of a software bug,
            /// but that should happen rarely enough that it isn't worth specifically
            /// writing UI or making a localized message for.
            /// The debug string should contain further details.
            /// </summary>
            EsteamnetconnectionendMiscGeneric = unchecked((int)5001),
            
            /// <summary>
            /// Generic failure that is most likely a software bug.
            /// </summary>
            EsteamnetconnectionendMiscInternalerror = unchecked((int)5002),
            
            /// <summary>
            /// The connection to the remote host timed out, but we
            /// don't know if the problem is on our end, in the middle,
            /// or on their end.
            /// </summary>
            EsteamnetconnectionendMiscTimeout = unchecked((int)5003),
            
            /// <summary>
            /// There's some trouble talking to Steam.
            /// </summary>
            EsteamnetconnectionendMiscSteamconnectivity = unchecked((int)5005),
            
            /// <summary>
            /// A server in a dedicated hosting situation has no relay sessions
            /// active with which to talk back to a client.  (It's the client's
            /// job to open and maintain those sessions.)
            /// </summary>
            EsteamnetconnectionendMiscNorelaysessionstoclient = unchecked((int)5006),
            
            /// <summary>
            /// P2P rendezvous failed in a way that we don't have more specific
            /// information
            /// </summary>
            EsteamnetconnectionendMiscP2pRendezvous = unchecked((int)5008),
            
            /// <summary>
            /// NAT punch failed, probably due to NAT/firewall configuration.
            /// </summary>
            /// <remarks>
            /// If relay fallback is available (it always is on Steam), then
            /// this is only used internally and will not be returned as a high
            /// level failure.
            /// </remarks>
            EsteamnetconnectionendMiscP2pNatFirewall = unchecked((int)5009),
            
            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendMiscPeersentnoconnection = unchecked((int)5010),
            
            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendMiscMax = unchecked((int)5999),
            
            /// <summary>
            /// Our peer replied that it has no record of the connection.
            /// This should not happen ordinarily, but can happen in a few
            /// exception cases:
            /// </summary>
            /// <remarks>
            /// - This is an old connection, and the peer has already cleaned
            /// up and forgotten about it.  (Perhaps it timed out and they
            /// closed it and were not able to communicate this to us.)
            /// - A bug or internal protocol error has caused us to try to
            /// talk to the peer about the connection before we received
            /// confirmation that the peer has accepted the connection.
            /// - The peer thinks that we have closed the connection for some
            /// reason (perhaps a bug), and believes that is it is
            /// acknowledging our closure.
            /// </remarks>
            EsteamnetconnectionendForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Invalid/sentinel value
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendInvalid = ESteamNetConnectionEnd.EsteamnetconnectionendInvalid;
        
        /// <summary>
        /// 1xxx: Application ended the connection in a "usual" manner.
        /// E.g.: user intentionally disconnected from the server,
        /// gameplay ended normally, etc
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendAppMin = ESteamNetConnectionEnd.EsteamnetconnectionendAppMin;
        
        /// <summary>
        /// 1xxx: Application ended the connection in a "usual" manner.
        /// E.g.: user intentionally disconnected from the server,
        /// gameplay ended normally, etc
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendAppGeneric = ESteamNetConnectionEnd.EsteamnetconnectionendAppGeneric;
        
        /// <summary>
        /// Use codes in this range for "normal" disconnection
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendAppMax = ESteamNetConnectionEnd.EsteamnetconnectionendAppMax;
        
        /// <summary>
        /// 2xxx: Application ended the connection in some sort of exceptional
        /// or unusual manner that might indicate a bug or configuration
        /// issue.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendAppexceptionMin = ESteamNetConnectionEnd.EsteamnetconnectionendAppexceptionMin;
        
        /// <summary>
        /// 2xxx: Application ended the connection in some sort of exceptional
        /// or unusual manner that might indicate a bug or configuration
        /// issue.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendAppexceptionGeneric = ESteamNetConnectionEnd.EsteamnetconnectionendAppexceptionGeneric;
        
        /// <summary>
        /// Use codes in this range for "unusual" disconnection
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendAppexceptionMax = ESteamNetConnectionEnd.EsteamnetconnectionendAppexceptionMax;
        
        /// <summary>
        /// 3xxx: Connection failed or ended because of problem with the
        /// local host or their connection to the Internet.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendLocalMin = ESteamNetConnectionEnd.EsteamnetconnectionendLocalMin;
        
        /// <summary>
        /// You cannot do what you want to do because you're running in offline mode.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendLocalOfflinemode = ESteamNetConnectionEnd.EsteamnetconnectionendLocalOfflinemode;
        
        /// <summary>
        /// We're having trouble contacting many (perhaps all) relays.
        /// Since it's unlikely that they all went offline at once, the best
        /// explanation is that we have a problem on our end.  Note that we don't
        /// bother distinguishing between "many" and "all", because in practice,
        /// it takes time to detect a connection problem, and by the time
        /// the connection has timed out, we might not have been able to
        /// actively probe all of the relay clusters, even if we were able to
        /// contact them at one time.  So this code just means that:
        /// </summary>
        /// <remarks>
        /// * We don't have any recent successful communication with any relay.
        /// * We have evidence of recent failures to communicate with multiple relays.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendLocalManyrelayconnectivity = ESteamNetConnectionEnd.EsteamnetconnectionendLocalManyrelayconnectivity;
        
        /// <summary>
        /// A hosted server is having trouble talking to the relay
        /// that the client was using, so the problem is most likely
        /// on our end
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendLocalHostedserverprimaryrelay = ESteamNetConnectionEnd.EsteamnetconnectionendLocalHostedserverprimaryrelay;
        
        /// <summary>
        /// We're not able to get the SDR network config.  This is
        /// *almost* always a local issue, since the network config
        /// comes from the CDN, which is pretty darn reliable.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendLocalNetworkconfig = ESteamNetConnectionEnd.EsteamnetconnectionendLocalNetworkconfig;
        
        /// <summary>
        /// Steam rejected our request because we don't have rights
        /// to do this.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendLocalRights = ESteamNetConnectionEnd.EsteamnetconnectionendLocalRights;
        
        /// <summary>
        /// ICE P2P rendezvous failed because we were not able to
        /// determine our "public" address (e.g. reflexive address via STUN)
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendLocalP2pIceNopublicaddresses = ESteamNetConnectionEnd.EsteamnetconnectionendLocalP2pIceNopublicaddresses;
        
        /// <summary>
        /// ICE P2P rendezvous failed because we were not able to
        /// determine our "public" address (e.g. reflexive address via STUN)
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendLocalMax = ESteamNetConnectionEnd.EsteamnetconnectionendLocalMax;
        
        /// <summary>
        /// 4xxx: Connection failed or ended, and it appears that the
        /// cause does NOT have to do with the local host or their
        /// connection to the Internet.  It could be caused by the
        /// remote host, or it could be somewhere in between.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendRemoteMin = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteMin;
        
        /// <summary>
        /// The connection was lost, and as far as we can tell our connection
        /// to relevant services (relays) has not been disrupted.  This doesn't
        /// mean that the problem is "their fault", it just means that it doesn't
        /// appear that we are having network issues on our end.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendRemoteTimeout = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteTimeout;
        
        /// <summary>
        /// Something was invalid with the cert or crypt handshake
        /// info you gave me, I don't understand or like your key types,
        /// etc.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendRemoteBadcrypt = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteBadcrypt;
        
        /// <summary>
        /// You presented me with a cert that was I was able to parse
        /// and *technically* we could use encrypted communication.
        /// But there was a problem that prevents me from checking your identity
        /// or ensuring that somebody int he middle can't observe our communication.
        /// E.g.: - the CA key was missing (and I don't accept unsigned certs)
        /// - The CA key isn't one that I trust,
        /// - The cert doesn't was appropriately restricted by app, user, time, data center, etc.
        /// - The cert wasn't issued to you.
        /// - etc
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendRemoteBadcert = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteBadcert;
        
        /// <summary>
        /// Something wrong with the protocol version you are using.
        /// (Probably the code you are running is too old.)
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendRemoteBadprotocolversion = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteBadprotocolversion;
        
        /// <summary>
        /// NAT punch failed failed because we never received any public
        /// addresses from the remote host.  (But we did receive some
        /// signals form them.)
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendRemoteP2pIceNopublicaddresses = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteP2pIceNopublicaddresses;
        
        /// <summary>
        /// NAT punch failed failed because we never received any public
        /// addresses from the remote host.  (But we did receive some
        /// signals form them.)
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendRemoteMax = ESteamNetConnectionEnd.EsteamnetconnectionendRemoteMax;
        
        /// <summary>
        /// 5xxx: Connection failed for some other reason.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscMin = ESteamNetConnectionEnd.EsteamnetconnectionendMiscMin;
        
        /// <summary>
        /// A failure that isn't necessarily the result of a software bug,
        /// but that should happen rarely enough that it isn't worth specifically
        /// writing UI or making a localized message for.
        /// The debug string should contain further details.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscGeneric = ESteamNetConnectionEnd.EsteamnetconnectionendMiscGeneric;
        
        /// <summary>
        /// Generic failure that is most likely a software bug.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscInternalerror = ESteamNetConnectionEnd.EsteamnetconnectionendMiscInternalerror;
        
        /// <summary>
        /// The connection to the remote host timed out, but we
        /// don't know if the problem is on our end, in the middle,
        /// or on their end.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscTimeout = ESteamNetConnectionEnd.EsteamnetconnectionendMiscTimeout;
        
        /// <summary>
        /// There's some trouble talking to Steam.
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscSteamconnectivity = ESteamNetConnectionEnd.EsteamnetconnectionendMiscSteamconnectivity;
        
        /// <summary>
        /// A server in a dedicated hosting situation has no relay sessions
        /// active with which to talk back to a client.  (It's the client's
        /// job to open and maintain those sessions.)
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscNorelaysessionstoclient = ESteamNetConnectionEnd.EsteamnetconnectionendMiscNorelaysessionstoclient;
        
        /// <summary>
        /// P2P rendezvous failed in a way that we don't have more specific
        /// information
        /// </summary>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscP2pRendezvous = ESteamNetConnectionEnd.EsteamnetconnectionendMiscP2pRendezvous;
        
        /// <summary>
        /// NAT punch failed, probably due to NAT/firewall configuration.
        /// </summary>
        /// <remarks>
        /// If relay fallback is available (it always is on Steam), then
        /// this is only used internally and will not be returned as a high
        /// level failure.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscP2pNatFirewall = ESteamNetConnectionEnd.EsteamnetconnectionendMiscP2pNatFirewall;
        
        /// <summary>
        /// Our peer replied that it has no record of the connection.
        /// This should not happen ordinarily, but can happen in a few
        /// exception cases:
        /// </summary>
        /// <remarks>
        /// - This is an old connection, and the peer has already cleaned
        /// up and forgotten about it.  (Perhaps it timed out and they
        /// closed it and were not able to communicate this to us.)
        /// - A bug or internal protocol error has caused us to try to
        /// talk to the peer about the connection before we received
        /// confirmation that the peer has accepted the connection.
        /// - The peer thinks that we have closed the connection for some
        /// reason (perhaps a bug), and believes that is it is
        /// acknowledging our closure.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscPeersentnoconnection = ESteamNetConnectionEnd.EsteamnetconnectionendMiscPeersentnoconnection;
        
        /// <summary>
        /// Our peer replied that it has no record of the connection.
        /// This should not happen ordinarily, but can happen in a few
        /// exception cases:
        /// </summary>
        /// <remarks>
        /// - This is an old connection, and the peer has already cleaned
        /// up and forgotten about it.  (Perhaps it timed out and they
        /// closed it and were not able to communicate this to us.)
        /// - A bug or internal protocol error has caused us to try to
        /// talk to the peer about the connection before we received
        /// confirmation that the peer has accepted the connection.
        /// - The peer thinks that we have closed the connection for some
        /// reason (perhaps a bug), and believes that is it is
        /// acknowledging our closure.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendMiscMax = ESteamNetConnectionEnd.EsteamnetconnectionendMiscMax;
        
        /// <summary>
        /// Our peer replied that it has no record of the connection.
        /// This should not happen ordinarily, but can happen in a few
        /// exception cases:
        /// </summary>
        /// <remarks>
        /// - This is an old connection, and the peer has already cleaned
        /// up and forgotten about it.  (Perhaps it timed out and they
        /// closed it and were not able to communicate this to us.)
        /// - A bug or internal protocol error has caused us to try to
        /// talk to the peer about the connection before we received
        /// confirmation that the peer has accepted the connection.
        /// - The peer thinks that we have closed the connection for some
        /// reason (perhaps a bug), and believes that is it is
        /// acknowledging our closure.
        /// </remarks>
        public const Networking.ESteamNetConnectionEnd EsteamnetconnectionendForce32bit = ESteamNetConnectionEnd.EsteamnetconnectionendForce32bit;
        
        /// <summary>
        /// Configuration values can be applied to different types of objects.
        /// </summary>
        public enum ESteamNetworkingConfigScope : int
        {
            /// <summary>
            /// Get/set global option, or defaults.  Even options that apply to more specific scopes
            /// have global scope, and you may be able to just change the global defaults.  If you
            /// need different settings per connection (for example), then you will need to set those
            /// options at the more specific scope.
            /// </summary>
            EsteamnetworkingconfigGlobal = unchecked((int)1),
            
            /// <summary>
            /// Some options are specific to a particular interface.  Note that all connection
            /// and listen socket settings can also be set at the interface level, and they will
            /// apply to objects created through those interfaces.
            /// </summary>
            EsteamnetworkingconfigSocketsinterface = unchecked((int)2),
            
            /// <summary>
            /// Options for a listen socket.  Listen socket options can be set at the interface layer,
            /// if  you have multiple listen sockets and they all use the same options.
            /// You can also set connection options on a listen socket, and they set the defaults
            /// for all connections accepted through this listen socket.  (They will be used if you don't
            /// set a connection option.)
            /// </summary>
            EsteamnetworkingconfigListensocket = unchecked((int)3),
            
            /// <summary>
            /// Options for a specific connection.
            /// </summary>
            EsteamnetworkingconfigConnection = unchecked((int)4),
            
            /// <summary>
            /// Options for a specific connection.
            /// </summary>
            EsteamnetworkingconfigscopeForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// Get/set global option, or defaults.  Even options that apply to more specific scopes
        /// have global scope, and you may be able to just change the global defaults.  If you
        /// need different settings per connection (for example), then you will need to set those
        /// options at the more specific scope.
        /// </summary>
        public const Networking.ESteamNetworkingConfigScope EsteamnetworkingconfigGlobal = ESteamNetworkingConfigScope.EsteamnetworkingconfigGlobal;
        
        /// <summary>
        /// Some options are specific to a particular interface.  Note that all connection
        /// and listen socket settings can also be set at the interface level, and they will
        /// apply to objects created through those interfaces.
        /// </summary>
        public const Networking.ESteamNetworkingConfigScope EsteamnetworkingconfigSocketsinterface = ESteamNetworkingConfigScope.EsteamnetworkingconfigSocketsinterface;
        
        /// <summary>
        /// Options for a listen socket.  Listen socket options can be set at the interface layer,
        /// if  you have multiple listen sockets and they all use the same options.
        /// You can also set connection options on a listen socket, and they set the defaults
        /// for all connections accepted through this listen socket.  (They will be used if you don't
        /// set a connection option.)
        /// </summary>
        public const Networking.ESteamNetworkingConfigScope EsteamnetworkingconfigListensocket = ESteamNetworkingConfigScope.EsteamnetworkingconfigListensocket;
        
        /// <summary>
        /// Options for a specific connection.
        /// </summary>
        public const Networking.ESteamNetworkingConfigScope EsteamnetworkingconfigConnection = ESteamNetworkingConfigScope.EsteamnetworkingconfigConnection;
        
        /// <summary>
        /// Options for a specific connection.
        /// </summary>
        public const Networking.ESteamNetworkingConfigScope EsteamnetworkingconfigscopeForce32bit = ESteamNetworkingConfigScope.EsteamnetworkingconfigscopeForce32bit;
        
        /// <summary>
        /// Different configuration values have different data types
        /// </summary>
        public enum ESteamNetworkingConfigDataType : int
        {
            EsteamnetworkingconfigInt32 = unchecked((int)1),
            
            EsteamnetworkingconfigInt64 = unchecked((int)2),
            
            EsteamnetworkingconfigFloat = unchecked((int)3),
            
            EsteamnetworkingconfigString = unchecked((int)4),
            
            EsteamnetworkingconfigPtr = unchecked((int)5),
            
            EsteamnetworkingconfigdatatypeForce32bit = unchecked((int)0x7fffffff),
        }
        
        public const Networking.ESteamNetworkingConfigDataType EsteamnetworkingconfigInt32 = ESteamNetworkingConfigDataType.EsteamnetworkingconfigInt32;
        
        public const Networking.ESteamNetworkingConfigDataType EsteamnetworkingconfigInt64 = ESteamNetworkingConfigDataType.EsteamnetworkingconfigInt64;
        
        public const Networking.ESteamNetworkingConfigDataType EsteamnetworkingconfigFloat = ESteamNetworkingConfigDataType.EsteamnetworkingconfigFloat;
        
        public const Networking.ESteamNetworkingConfigDataType EsteamnetworkingconfigString = ESteamNetworkingConfigDataType.EsteamnetworkingconfigString;
        
        public const Networking.ESteamNetworkingConfigDataType EsteamnetworkingconfigPtr = ESteamNetworkingConfigDataType.EsteamnetworkingconfigPtr;
        
        public const Networking.ESteamNetworkingConfigDataType EsteamnetworkingconfigdatatypeForce32bit = ESteamNetworkingConfigDataType.EsteamnetworkingconfigdatatypeForce32bit;
        
        /// <summary>
        /// Configuration options
        /// </summary>
        public enum ESteamNetworkingConfigValue : int
        {
            EsteamnetworkingconfigInvalid = unchecked((int)0),
            
            /// <summary>
            /// [connection int32] Timeout value (in ms) to use when first connecting
            /// </summary>
            EsteamnetworkingconfigTimeoutinitial = unchecked((int)24),
            
            /// <summary>
            /// [connection int32] Timeout value (in ms) to use after connection is established
            /// </summary>
            EsteamnetworkingconfigTimeoutconnected = unchecked((int)25),
            
            /// <summary>
            /// [connection int32] Upper limit of buffered pending bytes to be sent,
            /// if this is reached SendMessage will return k_EResultLimitExceeded
            /// Default is 512k (524288 bytes)
            /// </summary>
            EsteamnetworkingconfigSendbuffersize = unchecked((int)9),
            
            /// <summary>
            /// [connection int64] Get/set userdata as a configuration option.
            /// The default value is -1.   You may want to set the user data as
            /// a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData
            /// in two specific instances:
            /// </summary>
            /// <remarks>
            /// - You wish to set the userdata atomically when creating
            /// an outbound connection, so that the userdata is filled in properly
            /// for any callbacks that happen.  However, note that this trick
            /// only works for connections initiated locally!  For incoming
            /// connections, multiple state transitions may happen and
            /// callbacks be queued, before you are able to service the first
            /// callback!  Be careful!- You can set the default userdata for all newly created connections
            /// by setting this value at a higher level (e.g. on the listen
            /// socket or at the global level.)  Then this default
            /// value will be inherited when the connection is created.
            /// This is useful in case -1 is a valid userdata value, and you
            /// wish to use something else as the default value so you can
            /// tell if it has been set or not.HOWEVER: once a connection is created, the effective value is
            /// then bound to the connection.  Unlike other connection options,
            /// if you change it again at a higher level, the new value will not
            /// be inherited by connections.Using the userdata field in callback structs is not advised because
            /// of tricky race conditions.  Instead, you might try one of these methods:- Use a separate map with the HSteamNetConnection as the key.
            /// - Fetch the userdata from the connection in your callback
            /// using ISteamNetworkingSockets::GetConnectionUserData, to
            /// ensure you have the current value.
            /// </remarks>
            EsteamnetworkingconfigConnectionuserdata = unchecked((int)40),
            
            /// <summary>
            /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
            /// This value will control the min/max allowed sending rate that 
            /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
            /// </summary>
            EsteamnetworkingconfigSendratemin = unchecked((int)10),
            
            /// <summary>
            /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
            /// This value will control the min/max allowed sending rate that 
            /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
            /// </summary>
            EsteamnetworkingconfigSendratemax = unchecked((int)11),
            
            /// <summary>
            /// [connection int32] Nagle time, in microseconds.  When SendMessage is called, if
            /// the outgoing message is less than the size of the MTU, it will be
            /// queued for a delay equal to the Nagle timer value.  This is to ensure
            /// that if the application sends several small messages rapidly, they are
            /// coalesced into a single packet.
            /// See historical RFC 896.  Value is in microseconds. 
            /// Default is 5000us (5ms).
            /// </summary>
            EsteamnetworkingconfigNagletime = unchecked((int)12),
            
            /// <summary>
            /// [connection int32] Don't automatically fail IP connections that don't have
            /// strong auth.  On clients, this means we will attempt the connection even if
            /// we don't know our identity or can't get a cert.  On the server, it means that
            /// we won't automatically reject a connection due to a failure to authenticate.
            /// (You can examine the incoming connection and decide whether to accept it.)
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, and you should not let users modify it in
            /// production.
            /// </remarks>
            EsteamnetworkingconfigIpAllowwithoutauth = unchecked((int)23),
            
            /// <summary>
            /// [connection int32] Do not send UDP packets with a payload of
            /// larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize
            /// is automatically adjusted
            /// </summary>
            EsteamnetworkingconfigMtuPacketsize = unchecked((int)32),
            
            /// <summary>
            /// [connection int32] (read only) Maximum message size you can send that
            /// will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize
            /// </summary>
            EsteamnetworkingconfigMtuDatasize = unchecked((int)33),
            
            /// <summary>
            /// [connection int32] Allow unencrypted (and unauthenticated) communication.
            /// 0: Not allowed (the default)
            /// 1: Allowed, but prefer encrypted
            /// 2: Allowed, and preferred
            /// 3: Required.  (Fail the connection if the peer requires encryption.)
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, since its purpose is to disable encryption.
            /// You should not let users modify it in production.  (But note that it requires
            /// the peer to also modify their value in order for encryption to be disabled.)
            /// </remarks>
            EsteamnetworkingconfigUnencrypted = unchecked((int)34),
            
            /// <summary>
            /// [connection int32] Set this to 1 on outbound connections and listen sockets,
            /// to enable "symmetric connect mode", which is useful in the following
            /// common peer-to-peer use case:
            /// </summary>
            /// <remarks>
            /// - The two peers are "equal" to each other.  (Neither is clearly the "client"
            /// or "server".)
            /// - Either peer may initiate the connection, and indeed they may do this
            /// at the same time
            /// - The peers only desire a single connection to each other, and if both
            /// peers initiate connections simultaneously, a protocol is needed for them
            /// to resolve the conflict, so that we end up with a single connection.This use case is both common, and involves subtle race conditions and tricky
            /// pitfalls, which is why the API has support for dealing with it.If an incoming connection arrives on a listen socket or via custom signaling,
            /// and the application has not attempted to make a matching outbound connection
            /// in symmetric mode, then the incoming connection can be accepted as usual.
            /// A "matching" connection means that the relevant endpoint information matches.
            /// (At the time this comment is being written, this is only supported for P2P
            /// connections, which means that the peer identities must match, and the virtual
            /// port must match.  At a later time, symmetric mode may be supported for other
            /// connection types.)If connections are initiated by both peers simultaneously, race conditions
            /// can arise, but fortunately, most of them are handled internally and do not
            /// require any special awareness from the application.  However, there
            /// is one important case that application code must be aware of:
            /// If application code attempts an outbound connection using a ConnectXxx
            /// function in symmetric mode, and a matching incoming connection is already
            /// waiting on a listen socket, then instead of forming a new connection,
            /// the ConnectXxx call will accept the existing incoming connection, and return
            /// a connection handle to this accepted connection.
            /// IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t
            /// has probably *already* been posted to the queue for the incoming connection!
            /// (Once callbacks are posted to the queue, they are not modified.)  It doesn't
            /// matter if the callback has not been consumed by the app.  Thus, application
            /// code that makes use of symmetric connections must be aware that, when processing a
            /// SteamNetConnectionStatusChangedCallback_t for an incoming connection, the
            /// m_hConn may refer to a new connection that the app has has not
            /// seen before (the usual case), but it may also refer to a connection that
            /// has already been accepted implicitly through a call to Connect()!  In this
            /// case, AcceptConnection() will return k_EResultDuplicateRequest.Only one symmetric connection to a given peer (on a given virtual port)
            /// may exist at any given time.  If client code attempts to create a connection,
            /// and a (live) connection already exists on the local host, then either the
            /// existing connection will be accepted as described above, or the attempt
            /// to create a new connection will fail.  Furthermore, linger mode functionality
            /// is not supported on symmetric connections.A more complicated race condition can arise if both peers initiate a connection
            /// at roughly the same time.  In this situation, each peer will receive an incoming
            /// connection from the other peer, when the application code has already initiated
            /// an outgoing connection to that peer.  The peers must resolve this conflict and
            /// decide who is going to act as the "server" and who will act as the "client".
            /// Typically the application does not need to be aware of this case as it is handled
            /// internally.  On both sides, the will observe their outbound connection being
            /// "accepted", although one of them one have been converted internally to act
            /// as the "server".In general, symmetric mode should be all-or-nothing: do not mix symmetric
            /// connections with a non-symmetric connection that it might possible "match"
            /// with.  If you use symmetric mode on any connections, then both peers should
            /// use it on all connections, and the corresponding listen socket, if any.  The
            /// behaviour when symmetric and ordinary connections are mixed is not defined by
            /// this API, and you should not rely on it.  (This advice only applies when connections
            /// might possibly "match".  For example, it's OK to use all symmetric mode
            /// connections on one virtual port, and all ordinary, non-symmetric connections
            /// on a different virtual port, as there is no potential for ambiguity.)When using the feature, you should set it in the following situations on
            /// applicable objects:- When creating an outbound connection using ConnectXxx function
            /// - When creating a listen socket.  (Note that this will automatically cause
            /// any accepted connections to inherit the flag.)
            /// - When using custom signaling, before accepting an incoming connection.Setting the flag on listen socket and accepted connections will enable the
            /// API to automatically deal with duplicate incoming connections, even if the
            /// local host has not made any outbound requests.  (In general, such duplicate
            /// requests from a peer are ignored internally and will not be visible to the
            /// application code.  The previous connection must be closed or resolved first.)
            /// </remarks>
            EsteamnetworkingconfigSymmetricconnect = unchecked((int)37),
            
            /// <summary>
            /// [connection int32] For connection types that use "virtual ports", this can be used
            /// to assign a local virtual port.  For incoming connections, this will always be the
            /// virtual port of the listen socket (or the port requested by the remote host if custom
            /// signaling is used and the connection is accepted), and cannot be changed.  For
            /// connections initiated locally, the local virtual port will default to the same as the
            /// requested remote virtual port, if you do not specify a different option when creating
            /// the connection.  The local port is only relevant for symmetric connections, when
            /// determining if two connections "match."  In this case, if you need the local and remote
            /// port to differ, you can set this value.
            /// </summary>
            /// <remarks>
            /// You can also read back this value on listen sockets.This value should not be read or written in any other context.
            /// </remarks>
            EsteamnetworkingconfigLocalvirtualport = unchecked((int)38),
            
            /// <summary>
            /// [connection int32] True to enable diagnostics reporting through
            /// generic platform UI.  (Only available on Steam.)
            /// </summary>
            EsteamnetworkingconfigEnablediagnosticsui = unchecked((int)46),
            
            /// <summary>
            /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
            /// This is a global option only, since it is applied at a low level
            /// where we don't have much context
            /// </summary>
            EsteamnetworkingconfigFakepacketlossSend = unchecked((int)2),
            
            /// <summary>
            /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
            /// This is a global option only, since it is applied at a low level
            /// where we don't have much context
            /// </summary>
            EsteamnetworkingconfigFakepacketlossRecv = unchecked((int)3),
            
            /// <summary>
            /// [global int32].  Delay all outbound/inbound packets by N ms
            /// </summary>
            EsteamnetworkingconfigFakepacketlagSend = unchecked((int)4),
            
            /// <summary>
            /// [global int32].  Delay all outbound/inbound packets by N ms
            /// </summary>
            EsteamnetworkingconfigFakepacketlagRecv = unchecked((int)5),
            
            /// <summary>
            /// [global float] 0-100 Percentage of packets we will add additional delay
            /// to (causing them to be reordered)
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderSend = unchecked((int)6),
            
            /// <summary>
            /// [global float] 0-100 Percentage of packets we will add additional delay
            /// to (causing them to be reordered)
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderRecv = unchecked((int)7),
            
            /// <summary>
            /// [global int32] Extra delay, in ms, to apply to reordered packets.
            /// </summary>
            EsteamnetworkingconfigFakepacketreorderTime = unchecked((int)8),
            
            /// <summary>
            /// [global float 0--100] Globally duplicate some percentage of packets we send
            /// </summary>
            EsteamnetworkingconfigFakepacketdupSend = unchecked((int)26),
            
            /// <summary>
            /// [global float 0--100] Globally duplicate some percentage of packets we send
            /// </summary>
            EsteamnetworkingconfigFakepacketdupRecv = unchecked((int)27),
            
            /// <summary>
            /// [global int32] Amount of delay, in ms, to delay duplicated packets.
            /// (We chose a random delay between 0 and this value)
            /// </summary>
            EsteamnetworkingconfigFakepacketdupTimemax = unchecked((int)28),
            
            /// <summary>
            /// [global int32] Trace every UDP packet, similar to Wireshark or tcpdump.
            /// Value is max number of bytes to dump.  -1 disables tracing.
            /// 0 only traces the info but no actual data bytes
            /// </summary>
            EsteamnetworkingconfigPackettracemaxbytes = unchecked((int)41),
            
            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitSendRate = unchecked((int)42),
            
            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitSendBurst = unchecked((int)43),
            
            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitRecvRate = unchecked((int)44),
            
            /// <summary>
            /// [global int32] Global UDP token bucket rate limits.
            /// "Rate" refers to the steady state rate. (Bytes/sec, the
            /// rate that tokens are put into the bucket.)  "Burst"
            /// refers to the max amount that could be sent in a single
            /// burst.  (In bytes, the max capacity of the bucket.)
            /// Rate=0 disables the limiter entirely, which is the default.
            /// Burst=0 disables burst.  (This is not realistic.  A
            /// burst of at least 4K is recommended; the default is higher.)
            /// </summary>
            EsteamnetworkingconfigFakeratelimitRecvBurst = unchecked((int)45),
            
            /// <summary>
            /// [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked
            /// when the state of a connection changes.
            /// </summary>
            /// <remarks>
            /// IMPORTANT: callbacks are dispatched to the handler that is in effect at the time
            /// the event occurs, which might be in another thread.  For example, immediately after
            /// creating a listen socket, you may receive an incoming connection.  And then immediately
            /// after this, the remote host may close the connection.  All of this could happen
            /// before the function to create the listen socket has returned.  For this reason,
            /// callbacks usually must be in effect at the time of object creation.  This means
            /// you should set them when you are creating the listen socket or connection, or have
            /// them in effect so they will be inherited at the time of object creation.For example:exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );
            /// SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );
            /// SteamNetworkingIPAddr localAddress; localAddress.Clear();
            /// HSteamListenSocket hListenSock = SteamNetworkingSockets()-&gt;CreateListenSocketIP( localAddress, 1, 
            /// &amp;opt
            /// );When accepting an incoming connection, there is no atomic way to switch the
            /// callback.  However, if the connection is DOA, AcceptConnection() will fail, and
            /// you can fetch the state of the connection at that time.If all connections and listen sockets can use the same callback, the simplest
            /// method is to set it globally before you create any listen sockets or connections.
            /// </remarks>
            EsteamnetworkingconfigCallbackConnectionstatuschanged = unchecked((int)201),
            
            /// <summary>
            /// [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked
            /// when our auth state changes.  If you use this, install the callback before creating
            /// any connections or listen sockets, and don't change it.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged
            /// </summary>
            EsteamnetworkingconfigCallbackAuthstatuschanged = unchecked((int)202),
            
            /// <summary>
            /// [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked
            /// when our auth state changes.  If you use this, install the callback before creating
            /// any connections or listen sockets, and don't change it.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged
            /// </summary>
            EsteamnetworkingconfigCallbackRelaynetworkstatuschanged = unchecked((int)203),
            
            /// <summary>
            /// [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked
            /// when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest
            /// </summary>
            EsteamnetworkingconfigCallbackMessagessessionrequest = unchecked((int)204),
            
            /// <summary>
            /// [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked
            /// when a session you have initiated, or accepted either fails to connect, or loses
            /// connection in some unexpected way.
            /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed
            /// </summary>
            EsteamnetworkingconfigCallbackMessagessessionfailed = unchecked((int)205),
            
            /// <summary>
            /// [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will
            /// be invoked when we need to create a signaling object for a connection
            /// initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,
            /// ISteamNetworkingMessages.
            /// </summary>
            EsteamnetworkingconfigCallbackCreateconnectionsignaling = unchecked((int)206),
            
            /// <summary>
            /// [global FnSteamNetworkingFakeIPResult] Callback that's invoked when
            /// a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,
            /// ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult
            /// </summary>
            EsteamnetworkingconfigCallbackFakeipresult = unchecked((int)207),
            
            /// <summary>
            /// [connection string] Comma-separated list of STUN servers that can be used
            /// for NAT piercing.  If you set this to an empty string, NAT piercing will
            /// not be attempted.  Also if "public" candidates are not allowed for
            /// P2P_Transport_ICE_Enable, then this is ignored.
            /// </summary>
            EsteamnetworkingconfigP2pStunServerlist = unchecked((int)103),
            
            /// <summary>
            /// [connection int32] What types of ICE candidates to share with the peer.
            /// See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values
            /// </summary>
            EsteamnetworkingconfigP2pTransportIceEnable = unchecked((int)104),
            
            /// <summary>
            /// [connection int32] When selecting P2P transport, add various
            /// penalties to the scores for selected transports.  (Route selection
            /// scores are on a scale of milliseconds.  The score begins with the
            /// route ping time and is then adjusted.)
            /// </summary>
            EsteamnetworkingconfigP2pTransportIcePenalty = unchecked((int)105),
            
            /// <summary>
            /// [connection int32] When selecting P2P transport, add various
            /// penalties to the scores for selected transports.  (Route selection
            /// scores are on a scale of milliseconds.  The score begins with the
            /// route ping time and is then adjusted.)
            /// </summary>
            EsteamnetworkingconfigP2pTransportSdrPenalty = unchecked((int)106),
            
            /// <summary>
            /// [int32 global] If the first N pings to a port all fail, mark that port as unavailable for
            /// a while, and try a different one.  Some ISPs and routers may drop the first
            /// packet, so setting this to 1 may greatly disrupt communications.
            /// </summary>
            EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfailinitial = unchecked((int)19),
            
            /// <summary>
            /// [int32 global] If N consecutive pings to a port fail, after having received successful 
            /// communication, mark that port as unavailable for a while, and try a 
            /// different one.
            /// </summary>
            EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfail = unchecked((int)20),
            
            /// <summary>
            /// [int32 global] Minimum number of lifetime pings we need to send, before we think our estimate
            /// is solid.  The first ping to each cluster is very often delayed because of NAT,
            /// routers not having the best route, etc.  Until we've sent a sufficient number
            /// of pings, our estimate is often inaccurate.  Keep pinging until we get this
            /// many pings.
            /// </summary>
            EsteamnetworkingconfigSdrclientMinpingsbeforepingaccurate = unchecked((int)21),
            
            /// <summary>
            /// [int32 global] Set all steam datagram traffic to originate from the same
            /// local port. By default, we open up a new UDP socket (on a different local
            /// port) for each relay.  This is slightly less optimal, but it works around
            /// some routers that don't implement NAT properly.  If you have intermittent
            /// problems talking to relays that might be NAT related, try toggling
            /// this flag
            /// </summary>
            EsteamnetworkingconfigSdrclientSinglesocket = unchecked((int)22),
            
            /// <summary>
            /// [global string] Code of relay cluster to force use.  If not empty, we will
            /// only use relays in that cluster.  E.g. 'iad'
            /// </summary>
            EsteamnetworkingconfigSdrclientForcerelaycluster = unchecked((int)29),
            
            /// <summary>
            /// [connection string] For debugging, generate our own (unsigned) ticket, using
            /// the specified  gameserver address.  Router must be configured to accept unsigned
            /// tickets.
            /// </summary>
            EsteamnetworkingconfigSdrclientDebugticketaddress = unchecked((int)30),
            
            /// <summary>
            /// [global string] For debugging.  Override list of relays from the config with
            /// this set (maybe just one).  Comma-separated list.
            /// </summary>
            EsteamnetworkingconfigSdrclientForceproxyaddr = unchecked((int)31),
            
            /// <summary>
            /// [global string] For debugging.  Force ping times to clusters to be the specified
            /// values.  A comma separated list of 
            /// &lt;cluster
            /// &gt;=
            /// &lt;ms
            /// &gt; values.  E.g. "sto=32,iad=100"
            /// </summary>
            /// <remarks>
            /// This is a dev configuration value, you probably should not let users modify it
            /// in production.
            /// </remarks>
            EsteamnetworkingconfigSdrclientFakeclusterping = unchecked((int)36),
            
            /// <summary>
            /// [connection int32] RTT calculations for inline pings and replies
            /// </summary>
            EsteamnetworkingconfigLoglevelAckrtt = unchecked((int)13),
            
            /// <summary>
            /// [connection int32] log SNP packets send/recv
            /// </summary>
            EsteamnetworkingconfigLoglevelPacketdecode = unchecked((int)14),
            
            /// <summary>
            /// [connection int32] log each message send/recv
            /// </summary>
            EsteamnetworkingconfigLoglevelMessage = unchecked((int)15),
            
            /// <summary>
            /// [connection int32] dropped packets
            /// </summary>
            EsteamnetworkingconfigLoglevelPacketgaps = unchecked((int)16),
            
            /// <summary>
            /// [connection int32] P2P rendezvous messages
            /// </summary>
            EsteamnetworkingconfigLoglevelP2prendezvous = unchecked((int)17),
            
            /// <summary>
            /// [global int32] Ping relays
            /// </summary>
            EsteamnetworkingconfigLoglevelSdrrelaypings = unchecked((int)18),
            
            /// <summary>
            /// Deleted, do not use
            /// </summary>
            EsteamnetworkingconfigDeletedEnumeratedevvars = unchecked((int)35),
            
            /// <summary>
            /// Deleted, do not use
            /// </summary>
            EsteamnetworkingconfigvalueForce32bit = unchecked((int)0x7fffffff),
        }
        
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigInvalid = ESteamNetworkingConfigValue.EsteamnetworkingconfigInvalid;
        
        /// <summary>
        /// [connection int32] Timeout value (in ms) to use when first connecting
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigTimeoutinitial = ESteamNetworkingConfigValue.EsteamnetworkingconfigTimeoutinitial;
        
        /// <summary>
        /// [connection int32] Timeout value (in ms) to use after connection is established
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigTimeoutconnected = ESteamNetworkingConfigValue.EsteamnetworkingconfigTimeoutconnected;
        
        /// <summary>
        /// [connection int32] Upper limit of buffered pending bytes to be sent,
        /// if this is reached SendMessage will return k_EResultLimitExceeded
        /// Default is 512k (524288 bytes)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSendbuffersize = ESteamNetworkingConfigValue.EsteamnetworkingconfigSendbuffersize;
        
        /// <summary>
        /// [connection int64] Get/set userdata as a configuration option.
        /// The default value is -1.   You may want to set the user data as
        /// a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData
        /// in two specific instances:
        /// </summary>
        /// <remarks>
        /// - You wish to set the userdata atomically when creating
        /// an outbound connection, so that the userdata is filled in properly
        /// for any callbacks that happen.  However, note that this trick
        /// only works for connections initiated locally!  For incoming
        /// connections, multiple state transitions may happen and
        /// callbacks be queued, before you are able to service the first
        /// callback!  Be careful!- You can set the default userdata for all newly created connections
        /// by setting this value at a higher level (e.g. on the listen
        /// socket or at the global level.)  Then this default
        /// value will be inherited when the connection is created.
        /// This is useful in case -1 is a valid userdata value, and you
        /// wish to use something else as the default value so you can
        /// tell if it has been set or not.HOWEVER: once a connection is created, the effective value is
        /// then bound to the connection.  Unlike other connection options,
        /// if you change it again at a higher level, the new value will not
        /// be inherited by connections.Using the userdata field in callback structs is not advised because
        /// of tricky race conditions.  Instead, you might try one of these methods:- Use a separate map with the HSteamNetConnection as the key.
        /// - Fetch the userdata from the connection in your callback
        /// using ISteamNetworkingSockets::GetConnectionUserData, to
        /// ensure you have the current value.
        /// </remarks>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigConnectionuserdata = ESteamNetworkingConfigValue.EsteamnetworkingconfigConnectionuserdata;
        
        /// <summary>
        /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
        /// This value will control the min/max allowed sending rate that 
        /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSendratemin = ESteamNetworkingConfigValue.EsteamnetworkingconfigSendratemin;
        
        /// <summary>
        /// [connection int32] Minimum/maximum send rate clamp, 0 is no limit.
        /// This value will control the min/max allowed sending rate that 
        /// bandwidth estimation is allowed to reach.  Default is 0 (no-limit)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSendratemax = ESteamNetworkingConfigValue.EsteamnetworkingconfigSendratemax;
        
        /// <summary>
        /// [connection int32] Nagle time, in microseconds.  When SendMessage is called, if
        /// the outgoing message is less than the size of the MTU, it will be
        /// queued for a delay equal to the Nagle timer value.  This is to ensure
        /// that if the application sends several small messages rapidly, they are
        /// coalesced into a single packet.
        /// See historical RFC 896.  Value is in microseconds. 
        /// Default is 5000us (5ms).
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigNagletime = ESteamNetworkingConfigValue.EsteamnetworkingconfigNagletime;
        
        /// <summary>
        /// [connection int32] Don't automatically fail IP connections that don't have
        /// strong auth.  On clients, this means we will attempt the connection even if
        /// we don't know our identity or can't get a cert.  On the server, it means that
        /// we won't automatically reject a connection due to a failure to authenticate.
        /// (You can examine the incoming connection and decide whether to accept it.)
        /// </summary>
        /// <remarks>
        /// This is a dev configuration value, and you should not let users modify it in
        /// production.
        /// </remarks>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigIpAllowwithoutauth = ESteamNetworkingConfigValue.EsteamnetworkingconfigIpAllowwithoutauth;
        
        /// <summary>
        /// [connection int32] Do not send UDP packets with a payload of
        /// larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize
        /// is automatically adjusted
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigMtuPacketsize = ESteamNetworkingConfigValue.EsteamnetworkingconfigMtuPacketsize;
        
        /// <summary>
        /// [connection int32] (read only) Maximum message size you can send that
        /// will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigMtuDatasize = ESteamNetworkingConfigValue.EsteamnetworkingconfigMtuDatasize;
        
        /// <summary>
        /// [connection int32] Allow unencrypted (and unauthenticated) communication.
        /// 0: Not allowed (the default)
        /// 1: Allowed, but prefer encrypted
        /// 2: Allowed, and preferred
        /// 3: Required.  (Fail the connection if the peer requires encryption.)
        /// </summary>
        /// <remarks>
        /// This is a dev configuration value, since its purpose is to disable encryption.
        /// You should not let users modify it in production.  (But note that it requires
        /// the peer to also modify their value in order for encryption to be disabled.)
        /// </remarks>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigUnencrypted = ESteamNetworkingConfigValue.EsteamnetworkingconfigUnencrypted;
        
        /// <summary>
        /// [connection int32] Set this to 1 on outbound connections and listen sockets,
        /// to enable "symmetric connect mode", which is useful in the following
        /// common peer-to-peer use case:
        /// </summary>
        /// <remarks>
        /// - The two peers are "equal" to each other.  (Neither is clearly the "client"
        /// or "server".)
        /// - Either peer may initiate the connection, and indeed they may do this
        /// at the same time
        /// - The peers only desire a single connection to each other, and if both
        /// peers initiate connections simultaneously, a protocol is needed for them
        /// to resolve the conflict, so that we end up with a single connection.This use case is both common, and involves subtle race conditions and tricky
        /// pitfalls, which is why the API has support for dealing with it.If an incoming connection arrives on a listen socket or via custom signaling,
        /// and the application has not attempted to make a matching outbound connection
        /// in symmetric mode, then the incoming connection can be accepted as usual.
        /// A "matching" connection means that the relevant endpoint information matches.
        /// (At the time this comment is being written, this is only supported for P2P
        /// connections, which means that the peer identities must match, and the virtual
        /// port must match.  At a later time, symmetric mode may be supported for other
        /// connection types.)If connections are initiated by both peers simultaneously, race conditions
        /// can arise, but fortunately, most of them are handled internally and do not
        /// require any special awareness from the application.  However, there
        /// is one important case that application code must be aware of:
        /// If application code attempts an outbound connection using a ConnectXxx
        /// function in symmetric mode, and a matching incoming connection is already
        /// waiting on a listen socket, then instead of forming a new connection,
        /// the ConnectXxx call will accept the existing incoming connection, and return
        /// a connection handle to this accepted connection.
        /// IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t
        /// has probably *already* been posted to the queue for the incoming connection!
        /// (Once callbacks are posted to the queue, they are not modified.)  It doesn't
        /// matter if the callback has not been consumed by the app.  Thus, application
        /// code that makes use of symmetric connections must be aware that, when processing a
        /// SteamNetConnectionStatusChangedCallback_t for an incoming connection, the
        /// m_hConn may refer to a new connection that the app has has not
        /// seen before (the usual case), but it may also refer to a connection that
        /// has already been accepted implicitly through a call to Connect()!  In this
        /// case, AcceptConnection() will return k_EResultDuplicateRequest.Only one symmetric connection to a given peer (on a given virtual port)
        /// may exist at any given time.  If client code attempts to create a connection,
        /// and a (live) connection already exists on the local host, then either the
        /// existing connection will be accepted as described above, or the attempt
        /// to create a new connection will fail.  Furthermore, linger mode functionality
        /// is not supported on symmetric connections.A more complicated race condition can arise if both peers initiate a connection
        /// at roughly the same time.  In this situation, each peer will receive an incoming
        /// connection from the other peer, when the application code has already initiated
        /// an outgoing connection to that peer.  The peers must resolve this conflict and
        /// decide who is going to act as the "server" and who will act as the "client".
        /// Typically the application does not need to be aware of this case as it is handled
        /// internally.  On both sides, the will observe their outbound connection being
        /// "accepted", although one of them one have been converted internally to act
        /// as the "server".In general, symmetric mode should be all-or-nothing: do not mix symmetric
        /// connections with a non-symmetric connection that it might possible "match"
        /// with.  If you use symmetric mode on any connections, then both peers should
        /// use it on all connections, and the corresponding listen socket, if any.  The
        /// behaviour when symmetric and ordinary connections are mixed is not defined by
        /// this API, and you should not rely on it.  (This advice only applies when connections
        /// might possibly "match".  For example, it's OK to use all symmetric mode
        /// connections on one virtual port, and all ordinary, non-symmetric connections
        /// on a different virtual port, as there is no potential for ambiguity.)When using the feature, you should set it in the following situations on
        /// applicable objects:- When creating an outbound connection using ConnectXxx function
        /// - When creating a listen socket.  (Note that this will automatically cause
        /// any accepted connections to inherit the flag.)
        /// - When using custom signaling, before accepting an incoming connection.Setting the flag on listen socket and accepted connections will enable the
        /// API to automatically deal with duplicate incoming connections, even if the
        /// local host has not made any outbound requests.  (In general, such duplicate
        /// requests from a peer are ignored internally and will not be visible to the
        /// application code.  The previous connection must be closed or resolved first.)
        /// </remarks>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSymmetricconnect = ESteamNetworkingConfigValue.EsteamnetworkingconfigSymmetricconnect;
        
        /// <summary>
        /// [connection int32] For connection types that use "virtual ports", this can be used
        /// to assign a local virtual port.  For incoming connections, this will always be the
        /// virtual port of the listen socket (or the port requested by the remote host if custom
        /// signaling is used and the connection is accepted), and cannot be changed.  For
        /// connections initiated locally, the local virtual port will default to the same as the
        /// requested remote virtual port, if you do not specify a different option when creating
        /// the connection.  The local port is only relevant for symmetric connections, when
        /// determining if two connections "match."  In this case, if you need the local and remote
        /// port to differ, you can set this value.
        /// </summary>
        /// <remarks>
        /// You can also read back this value on listen sockets.This value should not be read or written in any other context.
        /// </remarks>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigLocalvirtualport = ESteamNetworkingConfigValue.EsteamnetworkingconfigLocalvirtualport;
        
        /// <summary>
        /// [connection int32] True to enable diagnostics reporting through
        /// generic platform UI.  (Only available on Steam.)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigEnablediagnosticsui = ESteamNetworkingConfigValue.EsteamnetworkingconfigEnablediagnosticsui;
        
        /// <summary>
        /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
        /// This is a global option only, since it is applied at a low level
        /// where we don't have much context
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketlossSend = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketlossSend;
        
        /// <summary>
        /// [global float, 0--100] Randomly discard N pct of packets instead of sending/recv
        /// This is a global option only, since it is applied at a low level
        /// where we don't have much context
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketlossRecv = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketlossRecv;
        
        /// <summary>
        /// [global int32].  Delay all outbound/inbound packets by N ms
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketlagSend = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketlagSend;
        
        /// <summary>
        /// [global int32].  Delay all outbound/inbound packets by N ms
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketlagRecv = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketlagRecv;
        
        /// <summary>
        /// [global float] 0-100 Percentage of packets we will add additional delay
        /// to (causing them to be reordered)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketreorderSend = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketreorderSend;
        
        /// <summary>
        /// [global float] 0-100 Percentage of packets we will add additional delay
        /// to (causing them to be reordered)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketreorderRecv = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketreorderRecv;
        
        /// <summary>
        /// [global int32] Extra delay, in ms, to apply to reordered packets.
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketreorderTime = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketreorderTime;
        
        /// <summary>
        /// [global float 0--100] Globally duplicate some percentage of packets we send
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketdupSend = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketdupSend;
        
        /// <summary>
        /// [global float 0--100] Globally duplicate some percentage of packets we send
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketdupRecv = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketdupRecv;
        
        /// <summary>
        /// [global int32] Amount of delay, in ms, to delay duplicated packets.
        /// (We chose a random delay between 0 and this value)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakepacketdupTimemax = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakepacketdupTimemax;
        
        /// <summary>
        /// [global int32] Trace every UDP packet, similar to Wireshark or tcpdump.
        /// Value is max number of bytes to dump.  -1 disables tracing.
        /// 0 only traces the info but no actual data bytes
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigPackettracemaxbytes = ESteamNetworkingConfigValue.EsteamnetworkingconfigPackettracemaxbytes;
        
        /// <summary>
        /// [global int32] Global UDP token bucket rate limits.
        /// "Rate" refers to the steady state rate. (Bytes/sec, the
        /// rate that tokens are put into the bucket.)  "Burst"
        /// refers to the max amount that could be sent in a single
        /// burst.  (In bytes, the max capacity of the bucket.)
        /// Rate=0 disables the limiter entirely, which is the default.
        /// Burst=0 disables burst.  (This is not realistic.  A
        /// burst of at least 4K is recommended; the default is higher.)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakeratelimitSendRate = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakeratelimitSendRate;
        
        /// <summary>
        /// [global int32] Global UDP token bucket rate limits.
        /// "Rate" refers to the steady state rate. (Bytes/sec, the
        /// rate that tokens are put into the bucket.)  "Burst"
        /// refers to the max amount that could be sent in a single
        /// burst.  (In bytes, the max capacity of the bucket.)
        /// Rate=0 disables the limiter entirely, which is the default.
        /// Burst=0 disables burst.  (This is not realistic.  A
        /// burst of at least 4K is recommended; the default is higher.)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakeratelimitSendBurst = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakeratelimitSendBurst;
        
        /// <summary>
        /// [global int32] Global UDP token bucket rate limits.
        /// "Rate" refers to the steady state rate. (Bytes/sec, the
        /// rate that tokens are put into the bucket.)  "Burst"
        /// refers to the max amount that could be sent in a single
        /// burst.  (In bytes, the max capacity of the bucket.)
        /// Rate=0 disables the limiter entirely, which is the default.
        /// Burst=0 disables burst.  (This is not realistic.  A
        /// burst of at least 4K is recommended; the default is higher.)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakeratelimitRecvRate = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakeratelimitRecvRate;
        
        /// <summary>
        /// [global int32] Global UDP token bucket rate limits.
        /// "Rate" refers to the steady state rate. (Bytes/sec, the
        /// rate that tokens are put into the bucket.)  "Burst"
        /// refers to the max amount that could be sent in a single
        /// burst.  (In bytes, the max capacity of the bucket.)
        /// Rate=0 disables the limiter entirely, which is the default.
        /// Burst=0 disables burst.  (This is not realistic.  A
        /// burst of at least 4K is recommended; the default is higher.)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigFakeratelimitRecvBurst = ESteamNetworkingConfigValue.EsteamnetworkingconfigFakeratelimitRecvBurst;
        
        /// <summary>
        /// [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked
        /// when the state of a connection changes.
        /// </summary>
        /// <remarks>
        /// IMPORTANT: callbacks are dispatched to the handler that is in effect at the time
        /// the event occurs, which might be in another thread.  For example, immediately after
        /// creating a listen socket, you may receive an incoming connection.  And then immediately
        /// after this, the remote host may close the connection.  All of this could happen
        /// before the function to create the listen socket has returned.  For this reason,
        /// callbacks usually must be in effect at the time of object creation.  This means
        /// you should set them when you are creating the listen socket or connection, or have
        /// them in effect so they will be inherited at the time of object creation.For example:exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );
        /// SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );
        /// SteamNetworkingIPAddr localAddress; localAddress.Clear();
        /// HSteamListenSocket hListenSock = SteamNetworkingSockets()-&gt;CreateListenSocketIP( localAddress, 1, 
        /// &amp;opt
        /// );When accepting an incoming connection, there is no atomic way to switch the
        /// callback.  However, if the connection is DOA, AcceptConnection() will fail, and
        /// you can fetch the state of the connection at that time.If all connections and listen sockets can use the same callback, the simplest
        /// method is to set it globally before you create any listen sockets or connections.
        /// </remarks>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackConnectionstatuschanged = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackConnectionstatuschanged;
        
        /// <summary>
        /// [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked
        /// when our auth state changes.  If you use this, install the callback before creating
        /// any connections or listen sockets, and don't change it.
        /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackAuthstatuschanged = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackAuthstatuschanged;
        
        /// <summary>
        /// [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked
        /// when our auth state changes.  If you use this, install the callback before creating
        /// any connections or listen sockets, and don't change it.
        /// See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackRelaynetworkstatuschanged = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackRelaynetworkstatuschanged;
        
        /// <summary>
        /// [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked
        /// when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.
        /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackMessagessessionrequest = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackMessagessessionrequest;
        
        /// <summary>
        /// [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked
        /// when a session you have initiated, or accepted either fails to connect, or loses
        /// connection in some unexpected way.
        /// See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackMessagessessionfailed = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackMessagessessionfailed;
        
        /// <summary>
        /// [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will
        /// be invoked when we need to create a signaling object for a connection
        /// initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,
        /// ISteamNetworkingMessages.
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackCreateconnectionsignaling = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackCreateconnectionsignaling;
        
        /// <summary>
        /// [global FnSteamNetworkingFakeIPResult] Callback that's invoked when
        /// a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,
        /// ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigCallbackFakeipresult = ESteamNetworkingConfigValue.EsteamnetworkingconfigCallbackFakeipresult;
        
        /// <summary>
        /// [connection string] Comma-separated list of STUN servers that can be used
        /// for NAT piercing.  If you set this to an empty string, NAT piercing will
        /// not be attempted.  Also if "public" candidates are not allowed for
        /// P2P_Transport_ICE_Enable, then this is ignored.
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigP2pStunServerlist = ESteamNetworkingConfigValue.EsteamnetworkingconfigP2pStunServerlist;
        
        /// <summary>
        /// [connection int32] What types of ICE candidates to share with the peer.
        /// See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigP2pTransportIceEnable = ESteamNetworkingConfigValue.EsteamnetworkingconfigP2pTransportIceEnable;
        
        /// <summary>
        /// [connection int32] When selecting P2P transport, add various
        /// penalties to the scores for selected transports.  (Route selection
        /// scores are on a scale of milliseconds.  The score begins with the
        /// route ping time and is then adjusted.)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigP2pTransportIcePenalty = ESteamNetworkingConfigValue.EsteamnetworkingconfigP2pTransportIcePenalty;
        
        /// <summary>
        /// [connection int32] When selecting P2P transport, add various
        /// penalties to the scores for selected transports.  (Route selection
        /// scores are on a scale of milliseconds.  The score begins with the
        /// route ping time and is then adjusted.)
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigP2pTransportSdrPenalty = ESteamNetworkingConfigValue.EsteamnetworkingconfigP2pTransportSdrPenalty;
        
        /// <summary>
        /// [int32 global] If the first N pings to a port all fail, mark that port as unavailable for
        /// a while, and try a different one.  Some ISPs and routers may drop the first
        /// packet, so setting this to 1 may greatly disrupt communications.
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfailinitial = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfailinitial;
        
        /// <summary>
        /// [int32 global] If N consecutive pings to a port fail, after having received successful 
        /// communication, mark that port as unavailable for a while, and try a 
        /// different one.
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfail = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientConsecutitivepingtimeoutsfail;
        
        /// <summary>
        /// [int32 global] Minimum number of lifetime pings we need to send, before we think our estimate
        /// is solid.  The first ping to each cluster is very often delayed because of NAT,
        /// routers not having the best route, etc.  Until we've sent a sufficient number
        /// of pings, our estimate is often inaccurate.  Keep pinging until we get this
        /// many pings.
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientMinpingsbeforepingaccurate = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientMinpingsbeforepingaccurate;
        
        /// <summary>
        /// [int32 global] Set all steam datagram traffic to originate from the same
        /// local port. By default, we open up a new UDP socket (on a different local
        /// port) for each relay.  This is slightly less optimal, but it works around
        /// some routers that don't implement NAT properly.  If you have intermittent
        /// problems talking to relays that might be NAT related, try toggling
        /// this flag
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientSinglesocket = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientSinglesocket;
        
        /// <summary>
        /// [global string] Code of relay cluster to force use.  If not empty, we will
        /// only use relays in that cluster.  E.g. 'iad'
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientForcerelaycluster = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientForcerelaycluster;
        
        /// <summary>
        /// [connection string] For debugging, generate our own (unsigned) ticket, using
        /// the specified  gameserver address.  Router must be configured to accept unsigned
        /// tickets.
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientDebugticketaddress = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientDebugticketaddress;
        
        /// <summary>
        /// [global string] For debugging.  Override list of relays from the config with
        /// this set (maybe just one).  Comma-separated list.
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientForceproxyaddr = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientForceproxyaddr;
        
        /// <summary>
        /// [global string] For debugging.  Force ping times to clusters to be the specified
        /// values.  A comma separated list of 
        /// &lt;cluster
        /// &gt;=
        /// &lt;ms
        /// &gt; values.  E.g. "sto=32,iad=100"
        /// </summary>
        /// <remarks>
        /// This is a dev configuration value, you probably should not let users modify it
        /// in production.
        /// </remarks>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigSdrclientFakeclusterping = ESteamNetworkingConfigValue.EsteamnetworkingconfigSdrclientFakeclusterping;
        
        /// <summary>
        /// [connection int32] RTT calculations for inline pings and replies
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelAckrtt = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelAckrtt;
        
        /// <summary>
        /// [connection int32] log SNP packets send/recv
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelPacketdecode = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelPacketdecode;
        
        /// <summary>
        /// [connection int32] log each message send/recv
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelMessage = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelMessage;
        
        /// <summary>
        /// [connection int32] dropped packets
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelPacketgaps = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelPacketgaps;
        
        /// <summary>
        /// [connection int32] P2P rendezvous messages
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelP2prendezvous = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelP2prendezvous;
        
        /// <summary>
        /// [global int32] Ping relays
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigLoglevelSdrrelaypings = ESteamNetworkingConfigValue.EsteamnetworkingconfigLoglevelSdrrelaypings;
        
        /// <summary>
        /// Deleted, do not use
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigDeletedEnumeratedevvars = ESteamNetworkingConfigValue.EsteamnetworkingconfigDeletedEnumeratedevvars;
        
        /// <summary>
        /// Deleted, do not use
        /// </summary>
        public const Networking.ESteamNetworkingConfigValue EsteamnetworkingconfigvalueForce32bit = ESteamNetworkingConfigValue.EsteamnetworkingconfigvalueForce32bit;
        
        /// <summary>
        /// Return value of ISteamNetworkintgUtils::GetConfigValue
        /// </summary>
        public enum ESteamNetworkingGetConfigValueResult : int
        {
            /// <summary>
            /// No such configuration value
            /// </summary>
            EsteamnetworkinggetconfigvalueBadvalue = unchecked((int)-1),
            
            /// <summary>
            /// Bad connection handle, etc
            /// </summary>
            EsteamnetworkinggetconfigvalueBadscopeobj = unchecked((int)-2),
            
            /// <summary>
            /// Couldn't fit the result in your buffer
            /// </summary>
            EsteamnetworkinggetconfigvalueBuffertoosmall = unchecked((int)-3),
            
            EsteamnetworkinggetconfigvalueOk = unchecked((int)1),
            
            /// <summary>
            /// A value was not set at this level, but the effective (inherited) value was returned.
            /// </summary>
            EsteamnetworkinggetconfigvalueOkinherited = unchecked((int)2),
            
            EsteamnetworkinggetconfigvalueresultForce32bit = unchecked((int)0x7fffffff),
        }
        
        /// <summary>
        /// No such configuration value
        /// </summary>
        public const Networking.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueBadvalue = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueBadvalue;
        
        /// <summary>
        /// Bad connection handle, etc
        /// </summary>
        public const Networking.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueBadscopeobj = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueBadscopeobj;
        
        /// <summary>
        /// Couldn't fit the result in your buffer
        /// </summary>
        public const Networking.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueBuffertoosmall = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueBuffertoosmall;
        
        public const Networking.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueOk = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueOk;
        
        /// <summary>
        /// A value was not set at this level, but the effective (inherited) value was returned.
        /// </summary>
        public const Networking.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueOkinherited = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueOkinherited;
        
        public const Networking.ESteamNetworkingGetConfigValueResult EsteamnetworkinggetconfigvalueresultForce32bit = ESteamNetworkingGetConfigValueResult.EsteamnetworkinggetconfigvalueresultForce32bit;
        
        /// <summary>
        /// Detail level for diagnostic output callback.
        /// See ISteamNetworkingUtils::SetDebugOutputFunction
        /// </summary>
        public enum ESteamNetworkingSocketsDebugOutputType : int
        {
            EsteamnetworkingsocketsdebugoutputtypeNone = unchecked((int)0),
            
            /// <summary>
            /// You used the API incorrectly, or an internal error happened
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeBug = unchecked((int)1),
            
            /// <summary>
            /// Run-time error condition that isn't the result of a bug.  (E.g. we are offline, cannot bind a port, etc)
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeError = unchecked((int)2),
            
            /// <summary>
            /// Nothing is wrong, but this is an important notification
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeImportant = unchecked((int)3),
            
            EsteamnetworkingsocketsdebugoutputtypeWarning = unchecked((int)4),
            
            /// <summary>
            /// Recommended amount
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeMsg = unchecked((int)5),
            
            /// <summary>
            /// Quite a bit
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeVerbose = unchecked((int)6),
            
            /// <summary>
            /// Practically everything
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeDebug = unchecked((int)7),
            
            /// <summary>
            /// Wall of text, detailed packet contents breakdown, etc
            /// </summary>
            EsteamnetworkingsocketsdebugoutputtypeEverything = unchecked((int)8),
            
            EsteamnetworkingsocketsdebugoutputtypeForce32bit = unchecked((int)0x7fffffff),
        }
        
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeNone = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeNone;
        
        /// <summary>
        /// You used the API incorrectly, or an internal error happened
        /// </summary>
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeBug = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeBug;
        
        /// <summary>
        /// Run-time error condition that isn't the result of a bug.  (E.g. we are offline, cannot bind a port, etc)
        /// </summary>
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeError = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeError;
        
        /// <summary>
        /// Nothing is wrong, but this is an important notification
        /// </summary>
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeImportant = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeImportant;
        
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeWarning = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeWarning;
        
        /// <summary>
        /// Recommended amount
        /// </summary>
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeMsg = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeMsg;
        
        /// <summary>
        /// Quite a bit
        /// </summary>
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeVerbose = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeVerbose;
        
        /// <summary>
        /// Practically everything
        /// </summary>
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeDebug = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeDebug;
        
        /// <summary>
        /// Wall of text, detailed packet contents breakdown, etc
        /// </summary>
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeEverything = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeEverything;
        
        public const Networking.ESteamNetworkingSocketsDebugOutputType EsteamnetworkingsocketsdebugoutputtypeForce32bit = ESteamNetworkingSocketsDebugOutputType.EsteamnetworkingsocketsdebugoutputtypeForce32bit;
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramHostedAddress : IEquatable<SteamDatagramHostedAddress>
        {
            private readonly IntPtr _handle;
            
            public SteamDatagramHostedAddress(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamDatagramHostedAddress other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamDatagramHostedAddress other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamDatagramHostedAddress left, SteamDatagramHostedAddress right) => left.Equals(right);
            
            public static bool operator !=(SteamDatagramHostedAddress left, SteamDatagramHostedAddress right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramGameCoordinatorServerLogin : IEquatable<SteamDatagramGameCoordinatorServerLogin>
        {
            private readonly IntPtr _handle;
            
            public SteamDatagramGameCoordinatorServerLogin(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamDatagramGameCoordinatorServerLogin other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamDatagramGameCoordinatorServerLogin other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamDatagramGameCoordinatorServerLogin left, SteamDatagramGameCoordinatorServerLogin right) => left.Equals(right);
            
            public static bool operator !=(SteamDatagramGameCoordinatorServerLogin left, SteamDatagramGameCoordinatorServerLogin right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Handle used to identify a connection to a remote host.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct HSteamNetConnection : IEquatable<HSteamNetConnection>
        {
            public HSteamNetConnection(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(HSteamNetConnection other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is HSteamNetConnection other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(HSteamNetConnection from) => from.Value;
            
            public static implicit operator HSteamNetConnection(uint from) => new HSteamNetConnection(from);
            
            public static bool operator ==(HSteamNetConnection left, HSteamNetConnection right) => left.Equals(right);
            
            public static bool operator !=(HSteamNetConnection left, HSteamNetConnection right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Describe the state of a connection.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetConnectionInfo_t
        {
            /// <summary>
            /// Who is on the other end?  Depending on the connection type and phase of the connection, we might not know
            /// </summary>
            public Networking.SteamNetworkingIdentity m_identityRemote;
            
            /// <summary>
            /// Arbitrary user data set by the local application code
            /// </summary>
            public long m_nUserData;
            
            /// <summary>
            /// Handle to listen socket this was connected on, or k_HSteamListenSocket_Invalid if we initiated the connection
            /// </summary>
            public Networking.HSteamListenSocket m_hListenSocket;
            
            /// <summary>
            /// Remote address.  Might be all 0's if we don't know it, or if this is N/A.
            /// (E.g. Basically everything except direct UDP connection.)
            /// </summary>
            public Networking.SteamNetworkingIPAddr m_addrRemote;
            
            public ushort m__pad1;
            
            /// <summary>
            /// What data center is the remote host in?  (0 if we don't know.)
            /// </summary>
            public Networking.SteamNetworkingPOPID m_idPOPRemote;
            
            /// <summary>
            /// What relay are we using to communicate with the remote host?
            /// (0 if not applicable.)
            /// </summary>
            public Networking.SteamNetworkingPOPID m_idPOPRelay;
            
            /// <summary>
            /// High level state of the connection
            /// </summary>
            public Networking.ESteamNetworkingConnectionState m_eState;
            
            /// <summary>
            /// Basic cause of the connection termination or problem.
            /// See ESteamNetConnectionEnd for the values used
            /// </summary>
            public int m_eEndReason;
            
            /// <summary>
            /// Human-readable, but non-localized explanation for connection
            /// termination or problem.  This is intended for debugging /
            /// diagnostic purposes only, not to display to users.  It might
            /// have some details specific to the issue.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string m_szEndDebug;
            
            /// <summary>
            /// Debug description.  This includes the internal connection ID,
            /// connection type (and peer information), and any name
            /// given to the connection by the app.  This string is used in various
            /// internal logging messages.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string m_szConnectionDescription;
            
            /// <summary>
            /// Misc flags.  Bitmask of k_nSteamNetworkConnectionInfoFlags_Xxxx
            /// </summary>
            public int m_nFlags;
            
            /// <summary>
            /// Internal stuff, room to change API easily
            /// </summary>
            public fixed uint reserved[63];
        }
        
        /// <summary>
        /// An abstract way to represent the identity of a network host.  All identities can
        /// be represented as simple string.  Furthermore, this string representation is actually
        /// used on the wire in several places, even though it is less efficient, in order to
        /// facilitate forward compatibility.  (Old client code can handle an identity type that
        /// it doesn't understand.)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIdentity
        {
            /// <summary>
            /// Max sizes
            /// </summary>
            public enum SteamNetworkingIdentityAnonymousEnum : int
            {
                /// <summary>
                /// Max length of the buffer needed to hold any identity, formatted in string format by ToString
                /// </summary>
                Cchmaxstring = unchecked((int)128),
                
                /// <summary>
                /// Max length of the string for generic string identities.  Including terminating '
                /// \
                /// 0'
                /// </summary>
                Cchmaxgenericstring = unchecked((int)32),
                
                Cbmaxgenericbytes = unchecked((int)32),
            }
            
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamNetworkingIdentityUnion
            {
                [FieldOffset(0)]
                public ulong m_steamID64;
                
                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
                public string m_szGenericString;
                
                [FieldOffset(0)]
                public fixed byte m_genericBytes[32];
                
                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
                public string m_szUnknownRawString;
                
                [FieldOffset(0)]
                public Networking.SteamNetworkingIPAddr m_ip;
                
                /// <summary>
                /// Pad structure to leave easy room for future expansion
                /// </summary>
                [FieldOffset(0)]
                public fixed int m_reserved[32];
            }
            
            /// <summary>
            /// Type of identity.
            /// </summary>
            public Networking.ESteamNetworkingIdentityType m_eType;
            
            /// <summary>
            /// Internal representation.  Don't access this directly, use the accessors!
            /// </summary>
            /// <remarks>
            /// Number of bytes that are relevant below.  This MUST ALWAYS be
            /// set.  (Use the accessors!)  This is important to enable old code to work
            /// with new identity types.
            /// </remarks>
            public int m_cbSize;
        }
        
        /// <summary>
        /// Store an IP and port.  IPv6 is always used; IPv4 is represented using
        /// "IPv4-mapped" addresses: IPv4 aa.bb.cc.dd =&gt; IPv6 ::ffff:aabb:ccdd
        /// (RFC 4291 section 2.5.5.2.)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIPAddr
        {
            /// <summary>
            /// Max length of the buffer needed to hold IP formatted using ToString, including '
            /// \
            /// 0'
            /// ([0123:4567:89ab:cdef:0123:4567:89ab:cdef]:12345)
            /// </summary>
            public enum SteamNetworkingIPAddrAnonymousEnum : int
            {
                Cchmaxstring = unchecked((int)48),
            }
            
            /// <summary>
            /// RFC4038, section 4.2
            /// </summary>
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public unsafe partial struct IPv4MappedAddress
            {
                public ulong m_8zeros;
                
                public ushort m_0000;
                
                public ushort m_ffff;
                
                /// <summary>
                /// NOTE: As bytes, i.e. network byte order
                /// </summary>
                public fixed byte m_ip[4];
            }
            
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public unsafe partial struct SteamNetworkingIPAddrunion
            {
                [FieldOffset(0)]
                public fixed byte m_ipv6[16];
                
                [FieldOffset(0)]
                public Networking.SteamNetworkingIPAddr.IPv4MappedAddress m_ipv4;
            }
            
            /// <summary>
            /// Host byte order
            /// </summary>
            public ushort m_port;
        }
        
        /// <summary>
        /// Handle used to identify a "listen socket".  Unlike traditional
        /// Berkeley sockets, a listen socket and a connection are two
        /// different abstractions.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct HSteamListenSocket : IEquatable<HSteamListenSocket>
        {
            public HSteamListenSocket(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(HSteamListenSocket other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is HSteamListenSocket other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(HSteamListenSocket from) => from.Value;
            
            public static implicit operator HSteamListenSocket(uint from) => new HSteamListenSocket(from);
            
            public static bool operator ==(HSteamListenSocket left, HSteamListenSocket right) => left.Equals(right);
            
            public static bool operator !=(HSteamListenSocket left, HSteamListenSocket right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Identifier used for a network location point of presence.  (E.g. a Valve data center.)
        /// Typically you won't need to directly manipulate these.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamNetworkingPOPID : IEquatable<SteamNetworkingPOPID>
        {
            public SteamNetworkingPOPID(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(SteamNetworkingPOPID other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is SteamNetworkingPOPID other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(SteamNetworkingPOPID from) => from.Value;
            
            public static implicit operator SteamNetworkingPOPID(uint from) => new SteamNetworkingPOPID(from);
            
            public static bool operator ==(SteamNetworkingPOPID left, SteamNetworkingPOPID right) => left.Equals(right);
            
            public static bool operator !=(SteamNetworkingPOPID left, SteamNetworkingPOPID right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Quick connection state, pared down to something you could call
        /// more frequently without it being too big of a perf hit.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetworkingQuickConnectionStatus
        {
            /// <summary>
            /// High level state of the connection
            /// </summary>
            public Networking.ESteamNetworkingConnectionState m_eState;
            
            /// <summary>
            /// Current ping (ms)
            /// </summary>
            public int m_nPing;
            
            /// <summary>
            /// Connection quality measured locally, 0...1.  (Percentage of packets delivered
            /// end-to-end in order).
            /// </summary>
            public float m_flConnectionQualityLocal;
            
            /// <summary>
            /// Packet delivery success rate as observed from remote host
            /// </summary>
            public float m_flConnectionQualityRemote;
            
            /// <summary>
            /// Current data rates from recent history.
            /// </summary>
            public float m_flOutPacketsPerSec;
            
            public float m_flOutBytesPerSec;
            
            public float m_flInPacketsPerSec;
            
            public float m_flInBytesPerSec;
            
            /// <summary>
            /// Estimate rate that we believe that we can send data to our peer.
            /// Note that this could be significantly higher than m_flOutBytesPerSec,
            /// meaning the capacity of the channel is higher than you are sending data.
            /// (That's OK!)
            /// </summary>
            public int m_nSendRateBytesPerSecond;
            
            /// <summary>
            /// Number of bytes pending to be sent.  This is data that you have recently
            /// requested to be sent but has not yet actually been put on the wire.  The
            /// reliable number ALSO includes data that was previously placed on the wire,
            /// but has now been scheduled for re-transmission.  Thus, it's possible to
            /// observe m_cbPendingReliable increasing between two checks, even if no
            /// calls were made to send reliable data between the checks.  Data that is
            /// awaiting the Nagle delay will appear in these numbers.
            /// </summary>
            public int m_cbPendingUnreliable;
            
            public int m_cbPendingReliable;
            
            /// <summary>
            /// Number of bytes of reliable data that has been placed the wire, but
            /// for which we have not yet received an acknowledgment, and thus we may
            /// have to re-transmit.
            /// </summary>
            public int m_cbSentUnackedReliable;
            
            /// <summary>
            /// If you asked us to send a message right now, how long would that message
            /// sit in the queue before we actually started putting packets on the wire?
            /// (And assuming Nagle does not cause any packets to be delayed.)
            /// </summary>
            /// <remarks>
            /// In general, data that is sent by the application is limited by the
            /// bandwidth of the channel.  If you send data faster than this, it must
            /// be queued and put on the wire at a metered rate.  Even sending a small amount
            /// of data (e.g. a few MTU, say ~3k) will require some of the data to be delayed
            /// a bit.In general, the estimated delay will be approximately equal to( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecondplus or minus one MTU.  It depends on how much time has elapsed since the last
            /// packet was put on the wire.  For example, the queue might have *just* been emptied,
            /// and the last packet placed on the wire, and we are exactly up against the send
            /// rate limit.  In that case we might need to wait for one packet's worth of time to
            /// elapse before we can send again.  On the other extreme, the queue might have data
            /// in it waiting for Nagle.  (This will always be less than one packet, because as soon
            /// as we have a complete packet we would send it.)  In that case, we might be ready
            /// to send data now, and this value will be 0.
            /// </remarks>
            public Networking.SteamNetworkingMicroseconds m_usecQueueTime;
            
            /// <summary>
            /// Internal stuff, room to change API easily
            /// </summary>
            public fixed uint reserved[16];
        }
        
        /// <summary>
        /// A local timestamp.  You can subtract two timestamps to get the number of elapsed
        /// microseconds.  This is guaranteed to increase over time during the lifetime
        /// of a process, but not globally across runs.  You don't need to worry about
        /// the value wrapping around.  Note that the underlying clock might not actually have
        /// microsecond resolution.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamNetworkingMicroseconds : IEquatable<SteamNetworkingMicroseconds>
        {
            public SteamNetworkingMicroseconds(long value) => this.Value = value;
            
            public readonly long Value;
            
            public bool Equals(SteamNetworkingMicroseconds other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is SteamNetworkingMicroseconds other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator long(SteamNetworkingMicroseconds from) => from.Value;
            
            public static implicit operator SteamNetworkingMicroseconds(long from) => new SteamNetworkingMicroseconds(from);
            
            public static bool operator ==(SteamNetworkingMicroseconds left, SteamNetworkingMicroseconds right) => left.Equals(right);
            
            public static bool operator !=(SteamNetworkingMicroseconds left, SteamNetworkingMicroseconds right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A message that has been received.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingMessage_t
        {
            /// <summary>
            /// Message payload
            /// </summary>
            public IntPtr m_pData;
            
            /// <summary>
            /// Size of the payload.
            /// </summary>
            public int m_cbSize;
            
            /// <summary>
            /// For messages received on connections: what connection did this come from?
            /// For outgoing messages: what connection to send it to?
            /// Not used when using the ISteamNetworkingMessages interface
            /// </summary>
            public Networking.HSteamNetConnection m_conn;
            
            /// <summary>
            /// For inbound messages: Who sent this to us?
            /// For outbound messages on connections: not used.
            /// For outbound messages on the ad-hoc ISteamNetworkingMessages interface: who should we send this to?
            /// </summary>
            public Networking.SteamNetworkingIdentity m_identityPeer;
            
            /// <summary>
            /// For messages received on connections, this is the user data
            /// associated with the connection.
            /// </summary>
            /// <remarks>
            /// This is *usually* the same as calling GetConnection() and then
            /// fetching the user data associated with that connection, but for
            /// the following subtle differences:- This user data will match the connection's user data at the time
            /// is captured at the time the message is returned by the API.
            /// If you subsequently change the userdata on the connection,
            /// this won't be updated.
            /// - This is an inline call, so it's *much* faster.
            /// - You might have closed the connection, so fetching the user data
            /// would not be possible.Not used when sending messages,
            /// </remarks>
            public long m_nConnUserData;
            
            /// <summary>
            /// Local timestamp when the message was received
            /// Not used for outbound messages.
            /// </summary>
            public Networking.SteamNetworkingMicroseconds m_usecTimeReceived;
            
            /// <summary>
            /// Message number assigned by the sender.
            /// This is not used for outbound messages
            /// </summary>
            public long m_nMessageNumber;
            
            /// <summary>
            /// Function used to free up m_pData.  This mechanism exists so that
            /// apps can create messages with buffers allocated from their own
            /// heap, and pass them into the library.  This function will
            /// usually be something like:
            /// </summary>
            /// <remarks>
            /// free( pMsg-&gt;m_pData );
            /// </remarks>
            public Networking.SteamNetworkingMessage_t.m_pfnFreeDatadelegate m_pfnFreeData;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void m_pfnFreeDatadelegate(ref Networking.SteamNetworkingMessage_t pMsg);
            
            /// <summary>
            /// Function to used to decrement the internal reference count and, if
            /// it's zero, release the message.  You should not set this function pointer,
            /// or need to access this directly!  Use the Release() function instead!
            /// </summary>
            public Networking.SteamNetworkingMessage_t.m_pfnReleasedelegate m_pfnRelease;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void m_pfnReleasedelegate(ref Networking.SteamNetworkingMessage_t pMsg);
            
            /// <summary>
            /// When using ISteamNetworkingMessages, the channel number the message was received on
            /// (Not used for messages sent or received on "connections")
            /// </summary>
            public int m_nChannel;
            
            /// <summary>
            /// Bitmask of k_nSteamNetworkingSend_xxx flags.
            /// For received messages, only the k_nSteamNetworkingSend_Reliable bit is valid.
            /// For outbound messages, all bits are relevant
            /// </summary>
            public int m_nFlags;
            
            /// <summary>
            /// Arbitrary user data that you can use when sending messages using
            /// ISteamNetworkingUtils::AllocateMessage and ISteamNetworkingSockets::SendMessage.
            /// (The callback you set in m_pfnFreeData might use this field.)
            /// </summary>
            /// <remarks>
            /// Not used for received messages.
            /// </remarks>
            public long m_nUserData;
        }
        
        /// <summary>
        /// Object that describes a "location" on the Internet with sufficient
        /// detail that we can reasonably estimate an upper bound on the ping between
        /// the two hosts, even if a direct route between the hosts is not possible,
        /// and the connection must be routed through the Steam Datagram Relay network.
        /// This does not contain any information that identifies the host.  Indeed,
        /// if two hosts are in the same building or otherwise have nearly identical
        /// networking characteristics, then it's valid to use the same location
        /// object for both of them.
        /// </summary>
        /// <remarks>
        /// NOTE: This object should only be used in the same process!  Do not serialize it,
        /// send it over the wire, or persist it in a file or database!  If you need
        /// to do that, convert it to a string representation using the methods in
        /// ISteamNetworkingUtils().
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct SteamNetworkPingLocation_t
        {
            public fixed byte m_data[512];
        }
        
        /// <summary>
        /// In a few places we need to set configuration options on listen sockets and connections, and
        /// have them take effect *before* the listen socket or connection really starts doing anything.
        /// Creating the object and then setting the options "immediately" after creation doesn't work
        /// completely, because network packets could be received between the time the object is created and
        /// when the options are applied.  To set options at creation time in a reliable way, they must be
        /// passed to the creation function.  This structure is used to pass those options.
        /// </summary>
        /// <remarks>
        /// For the meaning of these fields, see ISteamNetworkingUtils::SetConfigValue.  Basically
        /// when the object is created, we just iterate over the list of options and call
        /// ISteamNetworkingUtils::SetConfigValueStruct, where the scope arguments are supplied by the
        /// object being created.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingConfigValue_t
        {
            /// <summary>
            /// Option value
            /// </summary>
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct SteamNetworkingConfigValue_t_union_m_val
            {
                [FieldOffset(0)]
                public int m_int32;
                
                [FieldOffset(0)]
                public long m_int64;
                
                [FieldOffset(0)]
                public float m_float;
                
                /// <summary>
                /// Points to your '
                /// \
                /// 0'-terminated buffer
                /// </summary>
                [FieldOffset(0)]
                [MarshalAs(UnmanagedType.LPStr)]
                public string m_string;
                
                [FieldOffset(0)]
                public IntPtr m_ptr;
            }
            
            /// <summary>
            /// Which option is being set
            /// </summary>
            public Networking.ESteamNetworkingConfigValue m_eValue;
            
            /// <summary>
            /// Which field below did you fill in?
            /// </summary>
            public Networking.ESteamNetworkingConfigDataType m_eDataType;
            
            public Networking.SteamNetworkingConfigValue_t.SteamNetworkingConfigValue_t_union_m_val m_val;
        }
        
        /// <summary>
        /// Utility class for printing a SteamNetworkingPOPID.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingPOPIDRender
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)]
            public string buf;
        }
        
        /// <summary>
        /// Handle used to identify a poll group, used to query many
        /// connections at once efficiently.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct HSteamNetPollGroup : IEquatable<HSteamNetPollGroup>
        {
            public HSteamNetPollGroup(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(HSteamNetPollGroup other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is HSteamNetPollGroup other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(HSteamNetPollGroup from) => from.Value;
            
            public static implicit operator HSteamNetPollGroup(uint from) => new HSteamNetPollGroup(from);
            
            public static bool operator ==(HSteamNetPollGroup left, HSteamNetPollGroup right) => left.Equals(right);
            
            public static bool operator !=(HSteamNetPollGroup left, HSteamNetPollGroup right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Used to return English-language diagnostic error messages to caller.
        /// (For debugging or spewing to a console, etc.  Not intended for UI.)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamNetworkingErrMsg : IEquatable<SteamNetworkingErrMsg>
        {
            public SteamNetworkingErrMsg(string value) => this.Value = value;
            
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 1024)]
            public readonly string Value;
            
            public bool Equals(SteamNetworkingErrMsg other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is SteamNetworkingErrMsg other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator string(SteamNetworkingErrMsg from) => from.Value;
            
            public static implicit operator SteamNetworkingErrMsg(string from) => new SteamNetworkingErrMsg(from);
            
            public static bool operator ==(SteamNetworkingErrMsg left, SteamNetworkingErrMsg right) => left.Equals(right);
            
            public static bool operator !=(SteamNetworkingErrMsg left, SteamNetworkingErrMsg right) => !left.Equals(right);
        }
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FSteamNetworkingSocketsDebugOutput(Networking.ESteamNetworkingSocketsDebugOutputType nType, [MarshalAs(UnmanagedType.LPStr)] string pszMsg);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetConnectionStatusChanged(ref Networking.SteamNetConnectionStatusChangedCallback_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetAuthenticationStatusChanged(ref Networking.SteamNetAuthenticationStatus_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamRelayNetworkStatusChanged(ref Networking.SteamRelayNetworkStatus_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingMessagesSessionRequest(ref Networking.SteamNetworkingMessagesSessionRequest_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingMessagesSessionFailed(ref Networking.SteamNetworkingMessagesSessionFailed_t arg0);
        
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void FnSteamNetworkingFakeIPResult(Networking.SteamNetworkingFakeIPResult_t arg0);
        
        /// <summary>
        /// For code compatibility
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct ISteamNetworkingMessage : IEquatable<ISteamNetworkingMessage>
        {
            public ISteamNetworkingMessage(Networking.SteamNetworkingMessage_t value) => this.Value = value;
            
            public readonly Networking.SteamNetworkingMessage_t Value;
            
            public bool Equals(ISteamNetworkingMessage other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is ISteamNetworkingMessage other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator Networking.SteamNetworkingMessage_t(ISteamNetworkingMessage from) => from.Value;
            
            public static implicit operator ISteamNetworkingMessage(Networking.SteamNetworkingMessage_t from) => new ISteamNetworkingMessage(from);
            
            public static bool operator ==(ISteamNetworkingMessage left, ISteamNetworkingMessage right) => left.Equals(right);
            
            public static bool operator !=(ISteamNetworkingMessage left, ISteamNetworkingMessage right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramErrMsg : IEquatable<SteamDatagramErrMsg>
        {
            public SteamDatagramErrMsg(Networking.SteamNetworkingErrMsg value) => this.Value = value;
            
            public readonly Networking.SteamNetworkingErrMsg Value;
            
            public bool Equals(SteamDatagramErrMsg other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is SteamDatagramErrMsg other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator Networking.SteamNetworkingErrMsg(SteamDatagramErrMsg from) => from.Value;
            
            public static implicit operator SteamDatagramErrMsg(Networking.SteamNetworkingErrMsg from) => new SteamDatagramErrMsg(from);
            
            public static bool operator ==(SteamDatagramErrMsg left, SteamDatagramErrMsg right) => left.Equals(right);
            
            public static bool operator !=(SteamDatagramErrMsg left, SteamDatagramErrMsg right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Max length of diagnostic error message
        /// </summary>
        public const int k_cchMaxSteamNetworkingErrMsg = 1024;
        
        /// <summary>
        /// Max length, in bytes (including null terminator) of the reason string
        /// when a connection is closed.
        /// </summary>
        public const int k_cchSteamNetworkingMaxConnectionCloseReason = 128;
        
        /// <summary>
        /// Max length, in bytes (include null terminator) of debug description
        /// of a connection.
        /// </summary>
        public const int k_cchSteamNetworkingMaxConnectionDescription = 128;
        
        /// <summary>
        /// We don't have a certificate for the remote host.
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Unauthenticated = 1;
        
        /// <summary>
        /// Information is being sent out over a wire unencrypted (by this library)
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Unencrypted = 2;
        
        /// <summary>
        /// Internal loopback buffers.  Won't be true for localhost.  (You can check the address to determine that.)  This implies k_nSteamNetworkConnectionInfoFlags_FastLAN
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers = 4;
        
        /// <summary>
        /// The connection is "fast" and "reliable".  Either internal/localhost (check the address to find out), or the peer is on the same LAN.  (Probably.  It's based on the address and the ping time, this is actually hard to determine unambiguously).
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Fast = 8;
        
        /// <summary>
        /// The connection is relayed somehow (SDR or TURN).
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_Relayed = 16;
        
        /// <summary>
        /// We're taking advantage of dual-wifi multi-path
        /// </summary>
        public const int k_nSteamNetworkConnectionInfoFlags_DualWifi = 32;
        
        /// <summary>
        /// Max size of a single message that we can SEND.
        /// Note: We might be wiling to receive larger messages,
        /// and our peer might, too.
        /// </summary>
        public const int k_cbMaxSteamNetworkingSocketsMessageSizeSend = 512 * 1024;
        
        /// <summary>
        /// Send the message unreliably. Can be lost.  Messages *can* be larger than a
        /// single MTU (UDP packet), but there is no retransmission, so if any piece
        /// of the message is lost, the entire message will be dropped.
        /// </summary>
        /// <remarks>
        /// The sending API does have some knowledge of the underlying connection, so
        /// if there is no NAT-traversal accomplished or there is a recognized adjustment
        /// happening on the connection, the packet will be batched until the connection
        /// is open again.Migration note: This is not exactly the same as k_EP2PSendUnreliable!  You
        /// probably want k_ESteamNetworkingSendType_UnreliableNoNagle
        /// </remarks>
        public const int k_nSteamNetworkingSend_Unreliable = 0;
        
        /// <summary>
        /// Disable Nagle's algorithm.
        /// By default, Nagle's algorithm is applied to all outbound messages.  This means
        /// that the message will NOT be sent immediately, in case further messages are
        /// sent soon after you send this, which can be grouped together.  Any time there
        /// is enough buffered data to fill a packet, the packets will be pushed out immediately,
        /// but partially-full packets not be sent until the Nagle timer expires.  See
        /// ISteamNetworkingSockets::FlushMessagesOnConnection, ISteamNetworkingMessages::FlushMessagesToUser
        /// </summary>
        /// <remarks>
        /// NOTE: Don't just send every message without Nagle because you want packets to get there
        /// quicker.  Make sure you understand the problem that Nagle is solving before disabling it.
        /// If you are sending small messages, often many at the same time, then it is very likely that
        /// it will be more efficient to leave Nagle enabled.  A typical proper use of this flag is
        /// when you are sending what you know will be the last message sent for a while (e.g. the last
        /// in the server simulation tick to a particular client), and you use this flag to flush all
        /// messages.
        /// </remarks>
        public const int k_nSteamNetworkingSend_NoNagle = 1;
        
        /// <summary>
        /// Send a message unreliably, bypassing Nagle's algorithm for this message and any messages
        /// currently pending on the Nagle timer.  This is equivalent to using k_ESteamNetworkingSend_Unreliable
        /// and then immediately flushing the messages using ISteamNetworkingSockets::FlushMessagesOnConnection
        /// or ISteamNetworkingMessages::FlushMessagesToUser.  (But using this flag is more efficient since you
        /// only make one API call.)
        /// </summary>
        public const int k_nSteamNetworkingSend_UnreliableNoNagle = k_nSteamNetworkingSend_Unreliable | k_nSteamNetworkingSend_NoNagle;
        
        /// <summary>
        /// If the message cannot be sent very soon (because the connection is still doing some initial
        /// handshaking, route negotiations, etc), then just drop it.  This is only applicable for unreliable
        /// messages.  Using this flag on reliable messages is invalid.
        /// </summary>
        public const int k_nSteamNetworkingSend_NoDelay = 4;
        
        /// <summary>
        /// Send an unreliable message, but if it cannot be sent relatively quickly, just drop it instead of queuing it.
        /// This is useful for messages that are not useful if they are excessively delayed, such as voice data.
        /// NOTE: The Nagle algorithm is not used, and if the message is not dropped, any messages waiting on the
        /// Nagle timer are immediately flushed.
        /// </summary>
        /// <remarks>
        /// A message will be dropped under the following circumstances:
        /// - the connection is not fully connected.  (E.g. the "Connecting" or "FindingRoute" states)
        /// - there is a sufficiently large number of messages queued up already such that the current message
        /// will not be placed on the wire in the next ~200ms or so.If a message is dropped for these reasons, k_EResultIgnored will be returned.
        /// </remarks>
        public const int k_nSteamNetworkingSend_UnreliableNoDelay = k_nSteamNetworkingSend_Unreliable | k_nSteamNetworkingSend_NoDelay | k_nSteamNetworkingSend_NoNagle;
        
        /// <summary>
        /// Reliable message send. Can send up to k_cbMaxSteamNetworkingSocketsMessageSizeSend bytes in a single message. 
        /// Does fragmentation/re-assembly of messages under the hood, as well as a sliding window for
        /// efficient sends of large chunks of data.
        /// </summary>
        /// <remarks>
        /// The Nagle algorithm is used.  See notes on k_ESteamNetworkingSendType_Unreliable for more details.
        /// See k_ESteamNetworkingSendType_ReliableNoNagle, ISteamNetworkingSockets::FlushMessagesOnConnection,
        /// ISteamNetworkingMessages::FlushMessagesToUserMigration note: This is NOT the same as k_EP2PSendReliable, it's more like k_EP2PSendReliableWithBuffering
        /// </remarks>
        public const int k_nSteamNetworkingSend_Reliable = 8;
        
        /// <summary>
        /// Send a message reliably, but bypass Nagle's algorithm.
        /// </summary>
        /// <remarks>
        /// Migration note: This is equivalent to k_EP2PSendReliable
        /// </remarks>
        public const int k_nSteamNetworkingSend_ReliableNoNagle = k_nSteamNetworkingSend_Reliable | k_nSteamNetworkingSend_NoNagle;
        
        /// <summary>
        /// By default, message sending is queued, and the work of encryption and talking to
        /// the operating system sockets, etc is done on a service thread.  This is usually a
        /// a performance win when messages are sent from the "main thread".  However, if this
        /// flag is set, and data is ready to be sent immediately (either from this message
        /// or earlier queued data), then that work will be done in the current thread, before
        /// the current call returns.  If data is not ready to be sent (due to rate limiting
        /// or Nagle), then this flag has no effect.
        /// </summary>
        /// <remarks>
        /// This is an advanced flag used to control performance at a very low level.  For
        /// most applications running on modern hardware with more than one CPU core, doing
        /// the work of sending on a service thread will yield the best performance.  Only
        /// use this flag if you have a really good reason and understand what you are doing.
        /// Otherwise you will probably just make performance worse.
        /// </remarks>
        public const int k_nSteamNetworkingSend_UseCurrentThread = 16;
        
        /// <summary>
        /// When sending a message using ISteamNetworkingMessages, automatically re-establish
        /// a broken session, without returning k_EResultNoConnection.  Without this flag,
        /// if you attempt to send a message, and the session was proactively closed by the
        /// peer, or an error occurred that disrupted communications, then you must close the
        /// session using ISteamNetworkingMessages::CloseSessionWithUser before attempting to
        /// send another message.  (Or you can simply add this flag and retry.)  In this way,
        /// the disruption cannot go unnoticed, and a more clear order of events can be
        /// ascertained. This is especially important when reliable messages are used, since
        /// if the connection is disrupted, some of those messages will not have been delivered,
        /// and it is in general not possible to know which.  Although a
        /// SteamNetworkingMessagesSessionFailed_t callback will be posted when an error occurs
        /// to notify you that a failure has happened, callbacks are asynchronous, so it is not
        /// possible to tell exactly when it happened.  And because the primary purpose of
        /// ISteamNetworkingMessages is to be like UDP, there is no notification when a peer closes
        /// the session.
        /// </summary>
        /// <remarks>
        /// If you are not using any reliable messages (e.g. you are using ISteamNetworkingMessages
        /// exactly as a transport replacement for UDP-style datagrams only), you may not need to
        /// know when an underlying connection fails, and so you may not need this notification.
        /// </remarks>
        public const int k_nSteamNetworkingSend_AutoRestartBrokenSession = 32;
        
        /// <summary>
        /// Max possible length of a ping location, in string format.  This is
        /// an extremely conservative worst case value which leaves room for future
        /// syntax enhancements.  Most strings in practice are a lot shorter.
        /// If you are storing many of these, you will very likely benefit from
        /// using dynamic memory.
        /// </summary>
        public const int k_cchMaxSteamNetworkingPingLocationString = 1024;
        
        /// <summary>
        /// Special values that are returned by some functions that return a ping.
        /// </summary>
        public const int k_nSteamNetworkingPing_Failed = -1;
        
        public const int k_nSteamNetworkingPing_Unknown = -2;
        
        /// <summary>
        /// Special value - use user defaults
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default = -1;
        
        /// <summary>
        /// Do not do any ICE work at all or share any IP addresses with peer
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable = 0;
        
        /// <summary>
        /// Relayed connection via TURN server.
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay = 1;
        
        /// <summary>
        /// host addresses that appear to be link-local or RFC1918 addresses
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private = 2;
        
        /// <summary>
        /// STUN reflexive addresses, or host address that isn't a "private" address
        /// </summary>
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public = 4;
        
        public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All = 0x7fffffff;
        
        /// <summary>
        /// Unpack integer to string representation, including terminating '
        /// \
        /// 0'
        /// </summary>
        /// <remarks>
        /// See also SteamNetworkingPOPIDRender
        /// </remarks>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void GetSteamNetworkingLocationPOPStringFromID(Networking.SteamNetworkingPOPID id, ref sbyte[] szCode);
    }
}
