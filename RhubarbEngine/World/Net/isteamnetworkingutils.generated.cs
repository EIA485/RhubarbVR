//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Steam
{
    using System.Runtime.InteropServices;
    
    public static partial class Networking
    {
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct SteamDatagramRelayAuthTicket : IEquatable<SteamDatagramRelayAuthTicket>
        {
            private readonly IntPtr _handle;
            
            public SteamDatagramRelayAuthTicket(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(SteamDatagramRelayAuthTicket other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is SteamDatagramRelayAuthTicket other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(SteamDatagramRelayAuthTicket left, SteamDatagramRelayAuthTicket right) => left.Equals(right);
            
            public static bool operator !=(SteamDatagramRelayAuthTicket left, SteamDatagramRelayAuthTicket right) => !left.Equals(right);
        }
        
        /// <summary>
        /// A struct used to describe our readiness to use the relay network.
        /// To do this we first need to fetch the network configuration,
        /// which describes what POPs are available.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamRelayNetworkStatus_t
        {
            public enum SteamRelayNetworkStatus_tAnonymousEnum : int
            {
                Icallback = unchecked((int)2000 + 1),
            }
            
            /// <summary>
            /// Summary status.  When this is "current", initialization has
            /// completed.  Anything else means you are not ready yet, or
            /// there is a significant problem.
            /// </summary>
            public Networking.ESteamNetworkingAvailability m_eAvail;
            
            /// <summary>
            /// Nonzero if latency measurement is in progress (or pending,
            /// awaiting a prerequisite).
            /// </summary>
            public int m_bPingMeasurementInProgress;
            
            /// <summary>
            /// Status obtaining the network config.  This is a prerequisite
            /// for relay network access.
            /// </summary>
            /// <remarks>
            /// Failure to obtain the network config almost always indicates
            /// a problem with the local internet connection.
            /// </remarks>
            public Networking.ESteamNetworkingAvailability m_eAvailNetworkConfig;
            
            /// <summary>
            /// Current ability to communicate with ANY relay.  Note that
            /// the complete failure to communicate with any relays almost
            /// always indicates a problem with the local Internet connection.
            /// (However, just because you can reach a single relay doesn't
            /// mean that the local connection is in perfect health.)
            /// </summary>
            public Networking.ESteamNetworkingAvailability m_eAvailAnyRelay;
            
            /// <summary>
            /// Non-localized English language status.  For diagnostic/debugging
            /// purposes only.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string m_debugMsg;
        }
        
        /// <summary>
        /// -----------------------------------------------------------------------------
        /// Misc networking utilities for checking the local networking environment
        /// and estimating pings.
        /// </summary>
        public interface ISteamNetworkingUtils
        {
            /// <summary>
            /// Allocate and initialize a message object.  Usually the reason
            /// you call this is to pass it to ISteamNetworkingSockets::SendMessages.
            /// The returned object will have all of the relevant fields cleared to zero.
            /// </summary>
            /// <remarks>
            /// Optionally you can also request that this system allocate space to
            /// hold the payload itself.  If cbAllocateBuffer is nonzero, the system
            /// will allocate memory to hold a payload of at least cbAllocateBuffer bytes.
            /// m_pData will point to the allocated buffer, m_cbSize will be set to the
            /// size, and m_pfnFreeData will be set to the proper function to free up
            /// the buffer.If cbAllocateBuffer=0, then no buffer is allocated.  m_pData will be NULL,
            /// m_cbSize will be zero, and m_pfnFreeData will be NULL.  You will need to
            /// set each of these.
            /// </remarks>
            ref Networking.SteamNetworkingMessage_t AllocateMessage(int cbAllocateBuffer);
            
            /// <summary>
            /// Fetch current status of the relay network.
            /// </summary>
            /// <remarks>
            /// SteamRelayNetworkStatus_t is also a callback.  It will be triggered on
            /// both the user and gameserver interfaces any time the status changes, or
            /// ping measurement starts or stops.SteamRelayNetworkStatus_t::m_eAvail is returned.  If you want
            /// more details, you can pass a non-NULL value.
            /// </remarks>
            Networking.ESteamNetworkingAvailability GetRelayNetworkStatus(ref Networking.SteamRelayNetworkStatus_t pDetails);
            
            /// <summary>
            /// Return location info for the current host.  Returns the approximate
            /// age of the data, in seconds, or -1 if no data is available.
            /// </summary>
            /// <remarks>
            /// It takes a few seconds to initialize access to the relay network.  If
            /// you call this very soon after calling InitRelayNetworkAccess,
            /// the data may not be available yet.This always return the most up-to-date information we have available
            /// right now, even if we are in the middle of re-calculating ping times.
            /// </remarks>
            float GetLocalPingLocation(ref Networking.SteamNetworkPingLocation_t result);
            
            /// <summary>
            /// Estimate the round-trip latency between two arbitrary locations, in
            /// milliseconds.  This is a conservative estimate, based on routing through
            /// the relay network.  For most basic relayed connections, this ping time
            /// will be pretty accurate, since it will be based on the route likely to
            /// be actually used.
            /// </summary>
            /// <remarks>
            /// If a direct IP route is used (perhaps via NAT traversal), then the route
            /// will be different, and the ping time might be better.  Or it might actually
            /// be a bit worse!  Standard IP routing is frequently suboptimal!But even in this case, the estimate obtained using this method is a
            /// reasonable upper bound on the ping time.  (Also it has the advantage
            /// of returning immediately and not sending any packets.)In a few cases we might not able to estimate the route.  In this case
            /// a negative value is returned.  k_nSteamNetworkingPing_Failed means
            /// the reason was because of some networking difficulty.  (Failure to
            /// ping, etc)  k_nSteamNetworkingPing_Unknown is returned if we cannot
            /// currently answer the question for some other reason.Do you need to be able to do this from a backend/matchmaking server?
            /// You are looking for the "game coordinator" library.
            /// </remarks>
            int EstimatePingTimeBetweenTwoLocations(ref Networking.SteamNetworkPingLocation_t location1, ref Networking.SteamNetworkPingLocation_t location2);
            
            /// <summary>
            /// Same as EstimatePingTime, but assumes that one location is the local host.
            /// This is a bit faster, especially if you need to calculate a bunch of
            /// these in a loop to find the fastest one.
            /// </summary>
            /// <remarks>
            /// In rare cases this might return a slightly different estimate than combining
            /// GetLocalPingLocation with EstimatePingTimeBetweenTwoLocations.  That's because
            /// this function uses a slightly more complete set of information about what
            /// route would be taken.
            /// </remarks>
            int EstimatePingTimeFromLocalHost(ref Networking.SteamNetworkPingLocation_t remoteLocation);
            
            /// <summary>
            /// Convert a ping location into a text format suitable for sending over the wire.
            /// The format is a compact and human readable.  However, it is subject to change
            /// so please do not parse it yourself.  Your buffer must be at least
            /// k_cchMaxSteamNetworkingPingLocationString bytes.
            /// </summary>
            void ConvertPingLocationToString(ref Networking.SteamNetworkPingLocation_t location, IntPtr pszBuf, int cchBufSize);
            
            /// <summary>
            /// Parse back SteamNetworkPingLocation_t string.  Returns false if we couldn't understand
            /// the string.
            /// </summary>
            [return:MarshalAs(UnmanagedType.U1)]
            bool ParsePingLocationString([MarshalAs(UnmanagedType.LPStr)] string pszString, ref Networking.SteamNetworkPingLocation_t result);
            
            /// <summary>
            /// Check if the ping data of sufficient recency is available, and if
            /// it's too old, start refreshing it.
            /// </summary>
            /// <remarks>
            /// Please only call this function when you *really* do need to force an
            /// immediate refresh of the data.  (For example, in response to a specific
            /// user input to refresh this information.)  Don't call it "just in case",
            /// before every connection, etc.  That will cause extra traffic to be sent
            /// for no benefit. The library will automatically refresh the information
            /// as needed.Returns true if sufficiently recent data is already available.Returns false if sufficiently recent data is not available.  In this
            /// case, ping measurement is initiated, if it is not already active.
            /// (You cannot restart a measurement already in progress.)You can use GetRelayNetworkStatus or listen for SteamRelayNetworkStatus_t
            /// to know when ping measurement completes.
            /// </remarks>
            [return:MarshalAs(UnmanagedType.U1)]
            bool CheckPingDataUpToDate(float flMaxAgeSeconds);
            
            /// <summary>
            /// Fetch ping time of best available relayed route from this host to
            /// the specified data center.
            /// </summary>
            int GetPingToDataCenter(Networking.SteamNetworkingPOPID popID, ref Networking.SteamNetworkingPOPID pViaRelayPoP);
            
            /// <summary>
            /// Get *direct* ping time to the relays at the data center.
            /// </summary>
            int GetDirectPingToPOP(Networking.SteamNetworkingPOPID popID);
            
            /// <summary>
            /// Get number of network points of presence in the config
            /// </summary>
            int GetPOPCount();
            
            /// <summary>
            /// Get list of all POP IDs.  Returns the number of entries that were filled into
            /// your list.
            /// </summary>
            int GetPOPList(ref Networking.SteamNetworkingPOPID list, int nListSz);
            
            /// <summary>
            /// Fetch current timestamp.  This timer has the following properties:
            /// </summary>
            /// <remarks>
            /// - Monotonicity is guaranteed.
            /// - The initial value will be at least 24*3600*30*1e6, i.e. about
            /// 30 days worth of microseconds.  In this way, the timestamp value of
            /// 0 will always be at least "30 days ago".  Also, negative numbers
            /// will never be returned.
            /// - Wraparound / overflow is not a practical concern.If you are running under the debugger and stop the process, the clock
            /// might not advance the full wall clock time that has elapsed between
            /// calls.  If the process is not blocked from normal operation, the
            /// timestamp values will track wall clock time, even if you don't call
            /// the function frequently.The value is only meaningful for this run of the process.  Don't compare
            /// it to values obtained on another computer, or other runs of the same process.
            /// </remarks>
            Networking.SteamNetworkingMicroseconds GetLocalTimestamp();
            
            /// <summary>
            /// Set a function to receive network-related information that is useful for debugging.
            /// This can be very useful during development, but it can also be useful for troubleshooting
            /// problems with tech savvy end users.  If you have a console or other log that customers
            /// can examine, these log messages can often be helpful to troubleshoot network issues.
            /// (Especially any warning/error messages.)
            /// </summary>
            /// <remarks>
            /// The detail level indicates what message to invoke your callback on.  Lower numeric
            /// value means more important, and the value you pass is the lowest priority (highest
            /// numeric value) you wish to receive callbacks for.The value here controls the detail level for most messages.  You can control the
            /// detail level for various subsystems (perhaps only for certain connections) by
            /// adjusting the configuration values k_ESteamNetworkingConfig_LogLevel_Xxxxx.Except when debugging, you should only use k_ESteamNetworkingSocketsDebugOutputType_Msg
            /// or k_ESteamNetworkingSocketsDebugOutputType_Warning.  For best performance, do NOT
            /// request a high detail level and then filter out messages in your callback.  This incurs
            /// all of the expense of formatting the messages, which are then discarded.  Setting a high
            /// priority value (low numeric value) here allows the library to avoid doing this work.IMPORTANT: This may be called from a service thread, while we own a mutex, etc.
            /// Your output function must be threadsafe and fast!  Do not make any other
            /// Steamworks calls from within the handler.
            /// </remarks>
            void SetDebugOutputFunction(Networking.ESteamNetworkingSocketsDebugOutputType eDetailLevel, Networking.FSteamNetworkingSocketsDebugOutput pfnFunc);
            
            Networking.ESteamNetworkingFakeIPType GetIPv4FakeIPType(uint nIPv4);
            
            /// <summary>
            /// Get the real identity associated with a given FakeIP.
            /// </summary>
            /// <remarks>
            /// On failure, returns:
            /// - k_EResultInvalidParam: the IP is not a FakeIP.
            /// - k_EResultNoMatch: we don't recognize that FakeIP and don't know the corresponding identity.FakeIP's used by active connections, or the FakeIPs assigned to local identities,
            /// will always work.  FakeIPs for recently destroyed connections will continue to
            /// return results for a little while, but not forever.  At some point, we will forget
            /// FakeIPs to save space.  It's reasonably safe to assume that you can read back the
            /// real identity of a connection very soon after it is destroyed.  But do not wait
            /// indefinitely.
            /// </remarks>
            Networking.EResult GetRealIdentityForFakeIP(ref Networking.SteamNetworkingIPAddr fakeIP, ref Networking.SteamNetworkingIdentity pOutRealIdentity);
            
            /// <summary>
            /// Set a configuration value.
            /// - eValue: which value is being set
            /// - eScope: Onto what type of object are you applying the setting?
            /// - scopeArg: Which object you want to change?  (Ignored for global scope).  E.g. connection handle, listen socket handle, interface pointer, etc.
            /// - eDataType: What type of data is in the buffer at pValue?  This must match the type of the variable exactly!
            /// - pArg: Value to set it to.  You can pass NULL to remove a non-global setting at this scope,
            /// causing the value for that object to use global defaults.  Or at global scope, passing NULL
            /// will reset any custom value and restore it to the system default.
            /// NOTE: When setting pointers (e.g. callback functions), do not pass the function pointer directly.
            /// Your argument should be a pointer to a function pointer.
            /// </summary>
            [return:MarshalAs(UnmanagedType.U1)]
            bool SetConfigValue(Networking.ESteamNetworkingConfigValue eValue, Networking.ESteamNetworkingConfigScope eScopeType, long scopeObj, Networking.ESteamNetworkingConfigDataType eDataType, IntPtr pArg);
            
            /// <summary>
            /// Get a configuration value.
            /// - eValue: which value to fetch
            /// - eScopeType: query setting on what type of object
            /// - eScopeArg: the object to query the setting for
            /// - pOutDataType: If non-NULL, the data type of the value is returned.
            /// - pResult: Where to put the result.  Pass NULL to query the required buffer size.  (k_ESteamNetworkingGetConfigValue_BufferTooSmall will be returned.)
            /// - cbResult: IN: the size of your buffer.  OUT: the number of bytes filled in or required.
            /// </summary>
            Networking.ESteamNetworkingGetConfigValueResult GetConfigValue(Networking.ESteamNetworkingConfigValue eValue, Networking.ESteamNetworkingConfigScope eScopeType, long scopeObj, ref Networking.ESteamNetworkingConfigDataType pOutDataType, IntPtr pResult, ref Networking.size_t cbResult);
            
            /// <summary>
            /// Get info about a configuration value.  Returns the name of the value,
            /// or NULL if the value doesn't exist.  Other output parameters can be NULL
            /// if you do not need them.
            /// </summary>
            [return:MarshalAs(UnmanagedType.LPStr)]
            string GetConfigValueInfo(Networking.ESteamNetworkingConfigValue eValue, ref Networking.ESteamNetworkingConfigDataType pOutDataType, ref Networking.ESteamNetworkingConfigScope pOutScope);
            
            /// <summary>
            /// Iterate the list of all configuration values in the current environment that it might
            /// be possible to display or edit using a generic UI.  To get the first iterable value,
            /// pass k_ESteamNetworkingConfig_Invalid.  Returns k_ESteamNetworkingConfig_Invalid
            /// to signal end of list.
            /// </summary>
            /// <remarks>
            /// The bEnumerateDevVars argument can be used to include "dev" vars.  These are vars that
            /// are recommended to only be editable in "debug" or "dev" mode and typically should not be
            /// shown in a retail environment where a malicious local user might use this to cheat.
            /// </remarks>
            Networking.ESteamNetworkingConfigValue IterateGenericEditableConfigValues(Networking.ESteamNetworkingConfigValue eCurrent, [MarshalAs(UnmanagedType.U1)] bool bEnumerateDevVars);
            
            /// <summary>
            /// String conversions.  You'll usually access these using the respective
            /// inline methods.
            /// </summary>
            void SteamNetworkingIPAddr_ToString(ref Networking.SteamNetworkingIPAddr addr, IntPtr buf, Networking.size_t cbBuf, [MarshalAs(UnmanagedType.U1)] bool bWithPort);
            
            [return:MarshalAs(UnmanagedType.U1)]
            bool SteamNetworkingIPAddr_ParseString(ref Networking.SteamNetworkingIPAddr pAddr, [MarshalAs(UnmanagedType.LPStr)] string pszStr);
            
            Networking.ESteamNetworkingFakeIPType SteamNetworkingIPAddr_GetFakeIPType(ref Networking.SteamNetworkingIPAddr addr);
            
            void SteamNetworkingIdentity_ToString(ref Networking.SteamNetworkingIdentity identity, IntPtr buf, Networking.size_t cbBuf);
            
            [return:MarshalAs(UnmanagedType.U1)]
            bool SteamNetworkingIdentity_ParseString(ref Networking.SteamNetworkingIdentity pIdentity, [MarshalAs(UnmanagedType.LPStr)] string pszStr);
        }
        
        /// <summary>
        /// Utility class for printing a SteamNetworkingIdentity.
        /// E.g. printf( "Identity is '%s'@n ", SteamNetworkingIdentityRender( identity ).c_str() );
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIdentityRender
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string buf;
        }
        
        /// <summary>
        /// Utility class for printing a SteamNetworkingIPAddrRender.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct SteamNetworkingIPAddrRender
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 48)]
            public string buf;
        }
        
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern ref Networking.ISteamNetworkingUtils SteamNetworkingUtils_LibV4();
        
        /// <summary>
        /// Call direct to static functions
        /// </summary>
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingIPAddr_ToString(in Networking.SteamNetworkingIPAddr pAddr, IntPtr buf, Networking.size_t cbBuf, [MarshalAs(UnmanagedType.U1)] bool bWithPort);
        
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamNetworkingIPAddr_ParseString(ref Networking.SteamNetworkingIPAddr pAddr, [MarshalAs(UnmanagedType.LPStr)] string pszStr);
        
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern Networking.ESteamNetworkingFakeIPType SteamNetworkingIPAddr_GetFakeIPType(in Networking.SteamNetworkingIPAddr pAddr);
        
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        public static extern void SteamNetworkingIdentity_ToString(in Networking.SteamNetworkingIdentity pIdentity, IntPtr buf, Networking.size_t cbBuf);
        
        [DllImport(Library, CallingConvention = CallingConvention.Cdecl)]
        [return:MarshalAs(UnmanagedType.U1)]
        public static extern bool SteamNetworkingIdentity_ParseString(ref Networking.SteamNetworkingIdentity pIdentity, Networking.size_t sizeofIdentity, [MarshalAs(UnmanagedType.LPStr)] string pszStr);
    }
}
